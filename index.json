[{"id":3,"pagetitle":"Home","title":"Description","ref":"/Piccolo/dev/#Description","content":" Description Piccolo.jl  is a meta-package for quantum optimal control using the Pade Integrator Collocation (Piccolo) method. This package reexports the following packages QuantumCollocation.jl NamedTrajectories.jl TrajectoryIndexingUtils.jl PiccoloQuantumObjects.jl PiccoloPlots.jl For documentation please see the individual packages."},{"id":4,"pagetitle":"Home","title":"Usage","ref":"/Piccolo/dev/#Usage","content":" Usage Just run using Piccolo"},{"id":5,"pagetitle":"Home","title":"Installation","ref":"/Piccolo/dev/#Installation","content":" Installation This package is registered! To install enter the Julia REPL, type  ]  to enter pkg mode, activate your environment  activate , and then run  pkg> add Piccolo \"Technologies are ways of commandeering nature: the sky belongs to those who know how to fly; the sea belongs to those who know how to swim and navigate.\" – Simone de Beauvoir"},{"id":8,"pagetitle":"Contribution Guide","title":"Contribution Guide","ref":"/Piccolo/dev/contribution_guide/#Contribution-Guide","content":" Contribution Guide"},{"id":9,"pagetitle":"Contribution Guide","title":"Introduction","ref":"/Piccolo/dev/contribution_guide/#Introduction","content":" Introduction We welcome contributiuons to Piccolo.jl! This document outlines the guidelines for contributing to the project. If you know what you want to see, but are unsure of the best way to achieve it, add an issue on the relevant repository  (like QuantumCollocation.jl)  and start a discussion with the community! "},{"id":10,"pagetitle":"Contribution Guide","title":"Tips for Visual Studio Code","ref":"/Piccolo/dev/contribution_guide/#Tips-for-Visual-Studio-Code","content":" Tips for Visual Studio Code Julia extension  You can run Julia notebooks and much more with  the Julia extension . Upon opening your project folder in VS code and attempting to run an  .ipynb , you will see that VS Code finds the interpreters managed by juliaup and defaults to using the environment based on the  Project.toml  in the project directory. Fonts  VS Code will not display all characters allowed by Julia. You can change the editor font family in the settings to  'JuliaMono'  to get full support. If you don't want to mix and mash, you can create a new VS Code settings profile for working in Julia at  File>Preferences>Profile . Tests  Tests should automatically populate in VS Code when working with a Piccolo package. For example, just by adding the  QuantumCollocation.jl  folder to your workspace, you should see tests appear if you click on the  Testing  sidebar icon. If you run one of these tests, a new Julia kernel is spawned for the test. You can find the kernel if you click on the  Julia  sidebar icon (after installing the Julia extensions). Sometimes, for the tests to recognize new changes, you may need to manually kill this kernel to see your changes reflected."},{"id":11,"pagetitle":"Contribution Guide","title":"Developing","ref":"/Piccolo/dev/contribution_guide/#Developing","content":" Developing Install Julia Juliaup  is an installer and version manager. This is one useful way to manage Julia versions and keep up with the latest changes. After installing, run  julia  to obtain the Julia  REPL . Julia environments (Documentation)  Your project's environment is stored in  Project.toml . You can interactively add packages to an environment by using the Julia command line  REPL  and  package manager .  Start Julia in the project folder. Type  ]  to enter the package manager. Type  activate .  to activate or create an environment specified by  Project.toml  located in the current folder. Separately, you generate a manifest (solving the versions to create a valid environment) by running  instantiate ; instantiate will check that the environment is correct after you add all the packages you want. Adding packages (Documentation)  The initial cell for a Piccolo notebook might look something like the following: # Standard packages\nusing LinearAlgebra\nusing CairoMakie\n\n# Piccolo\nusing Piccolo First off are the standard packages (these are like Numpy and Matplotlib). Open the package manager in the current environment (type  julia ,  ] , and  activate . ), type  add LinearAlgebra  to install and precompile  LinearAlgebra . Same with  CairoMakie . Second, let's install  Piccolo . We do  add Piccolo  to get the entire ecosystem as a bundle from the Julia repository. Sometimes you will want to develop individual Piccolo packages, so our header might look like # Standard packages\nusing LinearAlgebra\nusing CairoMakie\n\n# Piccolo packages\nusing QuantumCollocation\nusing NamedTrajectories These are two packages ( QuantumCollocation ,  NamedTrajetories ) inside  Piccolo .  As a developer, we want to use the git repositories directly from  the harmoniqs Quantum Github page . Clone, then add the local packages to the Project file with e.g.  dev ../relative/path/to/repo/QuantumCollocation . This command installs the development version of  QuantumCollocation  pointing to the local Github code instead of the package repository. You can repeat this for the others, also. Revise Revise.jl  will let you edit source code, update packages, and reload the changes in a notebook–-automatically! This is a great tool for development.  add Revise  from the REPL and then include it before any packages you intend to edit: using Revise\nusing QuantumCollocation"},{"id":12,"pagetitle":"Contribution Guide","title":"Documentation","ref":"/Piccolo/dev/contribution_guide/#Documentation","content":" Documentation Documentation is built using  Documenter.jl  and uses  Literate.jl  to generate markdown files from scripts stored in  docs/literate . To build the documentation locally, start Julia with the docs environment: julia --project=docs Then (for ease of development) load the following packages: using Revise, LiveServer, QuantumCollocation To  live-serve  the docs, run servedocs(literate_dir=\"docs/literate\", skip_dir=\"docs/src/generated\") The extra arguments prevent an infinite loop caused by the generated Literate files. If the  index.md  is also dynamically generated from the  README.md , run servedocs(literate_dir=\"docs/literate\", skip_dir=\"docs/src/generated\", skip_files=[\"docs/src/index.md\"]) Changes made to files in the docs directory should be automatically reflected in the live server. To reflect changes in the source code (e.g. doc strings), since we are using Revise, simply kill the live server running in the REPL (with, e.g., Ctrl-C) and restart it with the above command. "},{"id":13,"pagetitle":"Contribution Guide","title":"Writing tests","ref":"/Piccolo/dev/contribution_guide/#Writing-tests","content":" Writing tests Tests are implemented using the  TestItems.jl  package.  @testitem \"Hadamard gate\" begin\n    H_drift, H_drives = GATES[:Z], [GATES[:X], GATES[:Y]]\n    U_goal = GATES[:H]\n    T = 51\n    Δt = 0.2\n\n    prob = UnitarySmoothPulseProblem(\n        H_drift, H_drives, U_goal, T, Δt,\n        ipopt_options=IpoptOptions(print_level=1)\n    )\n\n    solve!(prob, max_iter=100)\n    @test unitary_rollout_fidelity(prob) > 0.99\nend Individual tests will populate in the Testing panel in VSCode. All tests are integrated into the base test system for CI, which occurs at each PR submission. Tests should be included in the same file as the code they test, so  problem templates/unitary smooth pulse problem.jl  contains the test items for  UnitarySmoothPulseProblem ."},{"id":14,"pagetitle":"Contribution Guide","title":"Reporting Issues","ref":"/Piccolo/dev/contribution_guide/#Reporting-Issues","content":" Reporting Issues Issue templates are available on GitHub. We are happy to take feature requests!"},{"id":17,"pagetitle":"Multilevel Transmon","title":"Multilevel Transmon","ref":"/Piccolo/dev/generated/multilevel_transmon/#Multilevel-Transmon","content":" Multilevel Transmon In this example we will look at a multilevel transmon qubit with a Hamiltonian given by \\[\\hat{H}(t) = -\\frac{\\delta}{2} \\hat{n}(\\hat{n} - 1) + u_1(t) (\\hat{a} + \\hat{a}^\\dagger) + u_2(t) i (\\hat{a} - \\hat{a}^\\dagger)\\] where  $\\hat{n} = \\hat{a}^\\dagger \\hat{a}$  is the number operator,  $\\hat{a}$  is the annihilation operator,  $\\delta$  is the anharmonicity, and  $u_1(t)$  and  $u_2(t)$  are control fields. We will use the following parameter values: \\[\\begin{aligned}\n\\delta &= 0.2 \\text{ GHz}\\\\\n\\abs{u_i(t)} &\\leq 0.2 \\text{ GHz}\\\\\nT_0 &= 10 \\text{ ns}\\\\\n\\end{aligned}\\] For convenience, we have defined the  TransmonSystem  function in the  QuantumSystemTemplates  module, which returns a  QuantumSystem  object for a transmon qubit. We will use this function to define the system."},{"id":18,"pagetitle":"Multilevel Transmon","title":"Setting up the problem","ref":"/Piccolo/dev/generated/multilevel_transmon/#Setting-up-the-problem","content":" Setting up the problem To begin, let's load the necessary packages, define the system parameters, and create a a  QuantumSystem  object using the  TransmonSystem  function. using Piccolo\nusing SparseArrays\nusing Random;\nRandom.seed!(123);\n\n# define the time parameters\n\nT₀ = 10     # total time in ns\nT = 50      # number of time steps\nΔt = T₀ / T # time step\n\n# define the system parameters\nlevels = 5\nδ = 0.2\n\n# add a bound to the controls\na_bound = 0.2\ndda_bound = 1.0\n\n# create the system\nsys = TransmonSystem(levels = levels, δ = δ)\n\n# let's look at the parameters of the system\nsys.params Dict{Symbol, Any} with 8 entries:\n  :lab_frame_type => :duffing\n  :ω              => 4.0\n  :lab_frame      => false\n  :δ              => 0.2\n  :mutiply_by_2π  => true\n  :drives         => true\n  :levels         => 5\n  :frame_ω        => 4.0 Since this is a multilevel transmon and we want to implement an, let's say,  $X$  gate on the qubit subspace, i.e., the first two levels we can utilize the  EmbeddedOperator  type to define the target operator. # define the target operator\nop = EmbeddedOperator(:X, sys)\n\n# show the full operator\nop.operator |> sparse 5×5 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      1.0+0.0im      ⋅          ⋅          ⋅    \n 1.0+0.0im      ⋅          ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅     We can then pass this embedded operator to the  UnitarySmoothPulseProblem  template to create # create the problem\nprob = UnitarySmoothPulseProblem(sys, op, T, Δt; a_bound = a_bound, dda_bound = dda_bound)\n\n# solve the problem\nsolve!(prob; max_iter = 50)     building dynamics from integrators...\n        constructing knot point dynamics functions...\n        constructing full dynamics derivative functions...\n    building evaluator...\n    initializing optimizer...\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt\n        applying constraint: time step all equal constraint\n    finished.\n\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************\n\nThis is Ipopt version 3.14.17, running with linear solver MUMPS 5.7.3.\n\nNumber of nonzeros in equality constraint Jacobian...:   298610\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:        0\n\nTotal number of variables............................:     2794\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:      244\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     2695\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  6.2433007e-04 9.95e-01 9.32e-05   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  5.1669714e+00 6.70e-01 6.55e+01  -0.7 9.76e-01    -  8.13e-01 1.00e+00f  1\n   2  2.3808363e+01 1.53e-01 8.57e+01  -0.7 1.01e+00    -  6.89e-01 8.36e-01h  1\n   3  2.4924767e+01 5.90e-02 8.79e+01  -1.0 7.33e-01    -  9.99e-01 9.72e-01h  1\n   4  7.1761664e-01 6.29e-02 4.66e+01  -0.4 5.21e-01    -  1.00e+00 1.00e+00f  1\n   5  2.7823285e+00 6.29e-02 5.43e+01   0.2 5.39e+00    -  8.66e-01 1.78e-02h  5\n   6  5.3642466e-01 2.37e-02 1.12e+02  -0.2 3.33e-01    -  8.85e-01 1.00e+00f  1\n   7  5.4913713e+00 2.51e-03 2.56e+01  -1.2 1.24e-01    -  1.00e+00 1.00e+00h  1\n   8  4.8092825e+00 6.46e-04 1.42e+01  -1.8 5.50e-02    -  9.98e-01 1.00e+00f  1\n   9  1.8582530e+00 2.88e-03 2.21e+01  -3.0 1.15e-01    -  1.00e+00 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10  2.5070236e+00 1.00e-03 7.89e+00  -3.6 7.39e-02    -  1.00e+00 1.00e+00h  1\n  11  1.1546870e+00 2.58e-02 8.30e+01  -4.0 2.62e-01    -  1.00e+00 1.00e+00f  1\n  12  2.1771844e+00 3.02e-03 3.22e+01  -4.1 9.48e-02    -  1.00e+00 1.00e+00h  1\n  13  8.4230191e-01 2.53e-03 3.62e+01  -4.1 1.28e-01    -  1.00e+00 1.00e+00f  1\n  14  1.6600297e-01 1.05e-02 9.45e+01  -4.0 2.14e-01    -  1.00e+00 1.00e+00f  1\n  15  1.7476459e+00 1.09e-02 5.14e+01  -4.0 2.24e-01    -  1.00e+00 1.00e+00h  1\n  16  5.0318716e-01 2.50e-03 5.00e+01  -4.1 1.45e-01    -  1.00e+00 1.00e+00h  1\n  17  4.1250647e-01 2.67e-03 5.29e+01  -4.0 4.98e-01    -  1.00e+00 2.50e-01f  3\n  18  2.3556710e-01 1.48e-03 2.69e+01  -4.0 9.09e-02    -  1.00e+00 1.00e+00f  1\n  19  3.9614360e-02 2.15e-03 1.14e+01  -4.0 1.35e-01    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20  1.6690402e-01 1.54e-03 3.25e+00  -4.0 9.81e-02    -  1.00e+00 1.00e+00h  1\n  21  1.6682602e-01 1.86e-03 1.41e+01  -4.0 9.22e-02    -  1.00e+00 1.00e+00h  1\n  22  1.5561009e-01 3.01e-03 2.82e+01  -4.0 9.66e-02    -  1.00e+00 1.00e+00H  1\n  23  2.4767322e-01 3.51e-04 6.38e+00  -4.0 4.09e-02    -  1.00e+00 1.00e+00h  1\n  24  1.0704316e-01 1.87e-03 1.04e+02  -4.0 2.00e-01    -  1.00e+00 5.00e-01f  2\n  25  3.8285378e-02 1.17e-01 6.64e+01  -3.5 2.20e+00    -  1.00e+00 3.53e-01f  2\n  26  2.4324815e+00 2.50e-02 3.30e+01  -4.0 3.71e-01    -  1.00e+00 1.00e+00h  1\n  27  1.0851897e+00 6.50e-03 5.26e+01  -4.1 2.18e-01    -  1.00e+00 1.00e+00h  1\n  28  2.2034448e-01 6.96e-03 4.04e+01  -4.1 2.30e-01    -  1.00e+00 1.00e+00f  1\n  29  9.1105427e-01 9.70e-03 4.40e+01  -4.1 2.83e-01    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  30  3.1688137e-01 3.54e-03 4.36e+01  -4.1 1.59e-01    -  1.00e+00 1.00e+00h  1\n  31  1.9542321e-01 4.20e-03 5.62e+01  -4.1 3.99e-01    -  1.00e+00 2.50e-01f  3\n  32  1.6188014e-01 8.37e-04 2.57e+01  -4.1 9.33e-02    -  1.00e+00 1.00e+00h  1\n  33  1.8522718e-01 4.70e-04 7.78e+00  -4.0 5.20e-02    -  1.00e+00 5.00e-01h  2\n  34  1.1070016e-01 6.76e-03 6.15e+01  -4.0 2.54e-01    -  1.00e+00 1.00e+00h  1\n  35  1.2621230e-01 2.10e-03 4.29e+01  -4.1 1.21e-01    -  1.00e+00 1.00e+00h  1\n  36  4.8697872e-02 3.23e-03 4.90e+01  -4.1 9.41e-02    -  1.00e+00 1.00e+00h  1\n  37  1.3289272e-02 2.50e-03 4.57e+01  -4.1 1.19e-01    -  1.00e+00 5.00e-01h  2\n  38  5.3312712e-03 2.83e-03 5.24e+01  -4.0 1.11e-01    -  1.00e+00 1.00e+00h  1\n  39  8.8894334e-03 2.47e-03 5.22e+01  -4.0 1.59e-01    -  1.00e+00 2.50e-01h  3\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  40  2.5919805e-02 2.24e-03 4.71e+01  -4.0 4.27e-01    -  1.00e+00 2.50e-01h  3\n  41  1.2230357e-02 1.56e-03 4.85e+01  -4.0 8.55e-02    -  1.00e+00 1.00e+00h  1\n  42  1.0784345e-02 7.65e-03 5.16e+01  -3.6 1.95e+00    -  1.00e+00 7.75e-02h  3\n  43  3.6234166e-03 1.22e-03 4.88e+01  -3.7 8.32e-02    -  1.00e+00 1.00e+00h  1\n  44  2.3340099e-03 1.25e-03 5.09e+01  -4.0 1.75e-01    -  1.00e+00 2.50e-01h  3\n  45  2.2704479e-03 1.23e-03 5.07e+01  -4.0 1.35e-01    -  1.00e+00 2.50e-01h  3\n  46  2.8820613e-03 1.20e-03 4.91e+01  -4.0 3.02e-01    -  1.00e+00 6.25e-02h  5\n  47  2.7242093e-03 1.71e-03 5.03e+01  -4.0 1.49e-01    -  1.00e+00 1.00e+00h  1\n  48  2.3645264e-03 1.46e-02 5.01e+01  -4.1 1.55e-01    -  1.00e+00 1.00e+00h  1\n  49  2.3338425e-03 7.74e-03 4.97e+01  -4.1 1.46e-01    -  1.00e+00 5.00e-01h  2\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50  1.8480801e-03 8.74e-03 5.00e+01  -4.1 4.22e-01    -  1.00e+00 2.50e-01h  3\n\nNumber of Iterations....: 50\n\n                                   (scaled)                 (unscaled)\nObjective...............:   1.8480800982574378e-03    1.8480800982574378e-03\nDual infeasibility......:   4.9956295451190108e+01    4.9956295451190108e+01\nConstraint violation....:   8.7378664547032581e-03    8.7378664547032581e-03\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   9.7510129146677015e-05    9.7510129146677015e-05\nOverall NLP error.......:   4.9956295451190108e+01    4.9956295451190108e+01\n\n\nNumber of objective function evaluations             = 98\nNumber of objective gradient evaluations             = 51\nNumber of equality constraint evaluations            = 98\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 51\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 0\nTotal seconds in IPOPT                               = 11.303\n\nEXIT: Maximum Number of Iterations Exceeded. Let's look at the fidelity in the subspace println(\n    \"Fidelity: \",\n    unitary_rollout_fidelity(prob.trajectory, sys; subspace = op.subspace),\n) Fidelity: 0.9881694667268889 and plot the result using the  plot_unitary_populations  function. plot_unitary_populations(prob.trajectory)"},{"id":19,"pagetitle":"Multilevel Transmon","title":"Leakage suppresion","ref":"/Piccolo/dev/generated/multilevel_transmon/#Leakage-suppresion","content":" Leakage suppresion As can be seen from the above plot, there is a substantial amount of leakage into the higher levels during the evolution. To mitigate this, we have implemented the ability to add a cost to populating the leakage levels, in particular this is an  $L_1$  norm cost, which is implemented via slack variables and should ideally drive those leakage populations down to zero. To implement this, pass  leakage_suppresion=true  and  R_leakage={value}  to the  UnitarySmoothPulseProblem  template. # create the a leakage suppression problem, initializing with the previous solution\n\nprob_leakage = UnitarySmoothPulseProblem(\n    sys,\n    op,\n    T,\n    Δt;\n    a_bound = a_bound,\n    dda_bound = dda_bound,\n    leakage_suppression = true,\n    R_leakage = 1e-1,\n    a_guess = prob.trajectory.a,\n)\n\n# solve the problem\n\nsolve!(prob_leakage; max_iter = 50)     building dynamics from integrators...\n        constructing knot point dynamics functions...\n        constructing full dynamics derivative functions...\n    building evaluator...\n    initializing optimizer...\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt\n        applying constraint: time step all equal constraint\n    finished.\nThis is Ipopt version 3.14.17, running with linear solver MUMPS 5.7.3.\n\nNumber of nonzeros in equality constraint Jacobian...:   298610\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:        0\n\nTotal number of variables............................:     2794\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:      244\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     2695\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  6.9057165e-01 1.02e-02 3.06e-01   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  4.2654390e+00 2.51e-03 4.13e+01  -1.5 3.08e-01    -  8.27e-01 1.00e+00H  1\n   2  3.2714777e+00 5.94e-03 9.94e+01  -1.5 1.78e-01    -  9.99e-01 1.00e+00f  1\n   3  3.6455396e-02 4.46e-04 7.70e+01  -3.1 7.69e-02    -  1.00e+00 1.00e+00f  1\n   4  2.0619565e-01 4.48e-05 2.14e+01  -3.8 5.47e-02    -  9.97e-01 1.00e+00H  1\n   5  1.4723107e-01 6.56e-05 1.67e+00  -4.0 2.03e-02    -  1.00e+00 1.00e+00h  1\n   6  1.5854127e-01 1.87e-05 6.20e-01  -4.0 1.09e-02    -  1.00e+00 1.00e+00h  1\n   7  1.5049355e-01 2.12e-05 9.04e-01  -4.0 1.11e-02    -  1.00e+00 1.00e+00h  1\n   8  3.2081903e-02 1.99e-03 1.03e+01  -4.1 1.12e-01    -  1.00e+00 1.00e+00f  1\n   9  1.7072904e-01 8.52e-04 9.84e+01  -4.0 7.87e-02    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10  9.5780790e-02 1.68e-03 6.77e+01  -4.1 3.94e-01    -  1.00e+00 2.36e-01h  3\n  11  4.2737337e-02 1.47e-03 3.32e+01  -4.1 1.54e-01    -  1.00e+00 1.25e-01h  4\n  12  4.0417611e-02 4.86e-04 6.88e+01  -4.1 4.79e-02    -  1.00e+00 1.00e+00h  1\n  13  2.1735469e-02 1.63e-04 4.01e+01  -4.1 3.45e-02    -  1.00e+00 1.00e+00h  1\n  14  8.6009543e-03 8.26e-05 2.79e+01  -4.0 2.26e-02    -  1.00e+00 1.00e+00h  1\n  15  6.5438537e-03 1.28e-04 1.37e+01  -4.0 3.32e-02    -  1.00e+00 1.00e+00h  1\n  16  4.2405852e-03 1.24e-04 1.13e+02  -4.0 2.03e-01    -  1.00e+00 3.12e-02h  6\n  17  9.7710542e-03 6.03e-05 1.10e+01  -4.0 2.28e-02    -  1.00e+00 5.00e-01h  2\n  18  4.9183784e-03 6.80e-05 1.40e+01  -4.1 1.54e-01    -  1.00e+00 1.25e-01h  4\n  19  2.1661168e-03 7.13e-05 8.46e+01  -3.3 4.26e+00    -  1.00e+00 1.04e-03h  9\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20  3.7031120e-03 5.27e-05 3.21e+01  -4.0 3.62e-02    -  1.00e+00 5.00e-01h  2\n  21  5.8465973e-03 3.21e-05 3.00e+01  -4.0 2.23e-02    -  1.00e+00 5.00e-01h  2\n  22  2.0865762e-03 2.21e-04 7.05e+01  -4.0 8.44e-02    -  1.00e+00 5.00e-01h  2\n  23  8.5308428e-03 1.51e-04 6.82e+01  -4.0 5.87e-02    -  1.00e+00 5.00e-01h  2\n  24  4.6081884e-03 2.97e-04 2.59e+01  -4.1 1.99e-01    -  1.00e+00 2.50e-01h  3\n  25  4.7036846e-03 1.41e-04 4.94e+01  -4.1 3.61e-02    -  1.00e+00 1.00e+00h  1\n  26  2.9992028e-03 1.03e-03 4.61e+01  -4.1 1.08e-01    -  1.00e+00 1.00e+00h  1\n  27  3.1653837e-03 5.38e-04 4.81e+01  -4.1 5.97e-02    -  1.00e+00 1.00e+00h  1\n  28  2.3150131e-03 5.45e-04 5.04e+01  -4.1 1.80e+00    -  1.43e-01 7.56e-03h  8\n  29  1.7269353e-03 2.94e-02 5.05e+01  -4.1 5.73e-01    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  30  3.6992979e-03 2.61e-02 4.82e+01  -3.8 9.28e-01    -  1.00e+00 2.24e-01h  3\n  31  1.3286407e-02 2.52e-02 5.06e+01  -3.9 1.13e+00    -  1.00e+00 6.98e-02h  4\n  32  7.3201802e-03 1.95e-02 5.01e+01  -3.9 5.13e-01    -  1.00e+00 5.00e-01h  2\n  33  3.1301567e-03 1.84e-02 4.87e+01  -3.9 1.58e+00    -  7.21e-01 1.09e-01h  3\n  34  5.2194969e-03 1.17e-02 4.96e+01  -3.9 2.59e-01    -  1.00e+00 1.00e+00h  1\n  35  1.1368311e-02 5.68e-03 4.96e+01  -3.9 2.18e-01    -  1.00e+00 1.00e+00H  1\n  36  9.4390788e-03 4.98e-03 4.94e+01  -3.9 2.51e-01    -  1.00e+00 1.00e+00h  1\n  37  6.3081191e-03 2.66e-03 4.93e+01  -3.9 1.20e-01    -  1.00e+00 1.00e+00h  1\n  38  2.0181156e-03 8.33e-03 4.90e+01  -3.9 2.16e-01    -  1.00e+00 1.00e+00h  1\n  39  3.9076128e-03 7.61e-03 4.95e+01  -3.7 3.30e-01    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  40  2.8472727e-03 6.03e-03 4.95e+01  -3.8 2.83e-01    -  1.00e+00 1.00e+00h  1\n  41  2.1038696e-03 2.14e-02 4.90e+01  -3.8 3.03e-01    -  1.00e+00 1.00e+00H  1\n  42  1.4981178e-03 1.88e-02 4.95e+01  -3.8 3.49e-01    -  1.00e+00 1.25e-01h  4\n  43  3.0613144e-03 5.16e-03 4.92e+01  -4.0 1.93e-01    -  1.00e+00 1.00e+00h  1\n  44  1.6872944e-03 2.61e-03 4.92e+01  -4.1 3.03e-01    -  1.00e+00 5.00e-01h  2\n  45  1.0668637e-03 2.55e-03 4.93e+01  -4.0 1.59e+00    -  1.00e+00 2.55e-02h  5\n  46  1.3642193e-03 1.05e-03 4.91e+01  -4.0 8.21e-02    -  1.00e+00 1.00e+00h  1\n  47  1.0057123e-03 7.50e-04 4.93e+01  -4.0 6.10e-02    -  1.00e+00 1.00e+00h  1\n  48  9.4644943e-04 4.12e-03 4.92e+01  -4.0 2.06e-01    -  1.00e+00 1.00e+00h  1\n  49  6.9557146e-04 4.90e-03 4.92e+01  -4.0 2.97e-01    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50  7.2533182e-04 6.31e-03 4.92e+01  -4.0 7.12e-01    -  1.00e+00 2.50e-01h  3\n\nNumber of Iterations....: 50\n\n                                   (scaled)                 (unscaled)\nObjective...............:   7.2533182187648729e-04    7.2533182187648729e-04\nDual infeasibility......:   4.9248405578477154e+01    4.9248405578477154e+01\nConstraint violation....:   6.3053991614157034e-03    6.3053991614157034e-03\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   1.2679486561253169e-04    1.2679486561253169e-04\nOverall NLP error.......:   4.9248405578477154e+01    4.9248405578477154e+01\n\n\nNumber of objective function evaluations             = 135\nNumber of objective gradient evaluations             = 51\nNumber of equality constraint evaluations            = 135\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 51\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 0\nTotal seconds in IPOPT                               = 5.236\n\nEXIT: Maximum Number of Iterations Exceeded. Let's look at the fidelity in the subspace println(\n    \"Fidelity: \",\n    unitary_rollout_fidelity(prob_leakage.trajectory, sys; subspace = op.subspace),\n) Fidelity: 0.9920354750659017 and plot the result using the  plot_unitary_populations  function from PiccoloPlots.jl plot_unitary_populations(prob_leakage.trajectory) Here we can see that the leakage populations have been driven substantially down. This page was generated using  Literate.jl ."},{"id":22,"pagetitle":"Quickstart","title":"Quickstart Guide","ref":"/Piccolo/dev/generated/quickstart/#Quickstart-Guide","content":" Quickstart Guide To set up and solve a quantum optimal control problems we provide high level problem templates to quickly get started. For unitary gate problems, where we want to realize a gate  $U_{\\text{goal}}$ , with a system Hamiltonian of the form, \\[H(t) = H_0 + \\sum_i a^i(t) H_i\\] there is the  UnitarySmoothPulseProblem  constructor which only requires the drift Hamiltonian,  $H_0$ the drive Hamiltonians,  $\\qty{H_i}$ the target unitary,  $U_{\\text{goal}}$ the number of timesteps,  $T$ the (initial) time step size,  $\\Delta t$"},{"id":23,"pagetitle":"Quickstart","title":"Smooth Pulse Problems","ref":"/Piccolo/dev/generated/quickstart/#Smooth-Pulse-Problems","content":" Smooth Pulse Problems For example, to create a problem for a single qubit  $X$  gate (with a bound on the drive of  $|a^i| < a_{\\text{bound}}$ ), i.e., with system hamiltonian \\[H(t) = \\frac{\\omega}{2} \\sigma_z + a^1(t) \\sigma_x + a^2(t) \\sigma_y\\] we can do the following: using Piccolo\n\n# set time parameters\nT = 50\nΔt = 0.2\n\n# define drift and drive Hamiltonians\nH_drift = 0.2 * PAULIS.Z\nH_drives = [PAULIS.X, PAULIS.Y]\n\n# create a QuantumSystem from the Hamiltonians\nsystem = QuantumSystem(H_drift, H_drives)\n\n# define target unitary\nU_goal = GATES.X\n\n# set bounds on the drive\na_bound = 0.2\ndda_bound = 0.1\n\n# build the problem\nprob = UnitarySmoothPulseProblem(\n    system,\n    U_goal,\n    T,\n    Δt;\n    a_bound = a_bound,\n    dda_bound = dda_bound,\n)\n\n# solve the problem\nsolve!(prob; max_iter = 50)     building dynamics from integrators...\n        constructing knot point dynamics functions...\n        constructing full dynamics derivative functions...\n    building evaluator...\n    initializing optimizer...\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt\n        applying constraint: time step all equal constraint\n    finished.\nThis is Ipopt version 3.14.17, running with linear solver MUMPS 5.7.3.\n\nNumber of nonzeros in equality constraint Jacobian...:    17546\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:        0\n\nTotal number of variables............................:      736\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:      244\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:      637\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  5.6307135e-04 3.97e-01 5.90e-05   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  5.4190138e+01 5.43e-02 3.72e+01  -0.9 1.08e+00    -  2.76e-02 9.87e-01h  1\n   2  4.6308351e+01 3.68e-02 3.04e+01  -0.6 1.30e+00    -  1.00e+00 4.81e-01f  1\n   3  1.6973036e+01 1.94e-02 3.03e+01  -0.7 7.50e-01    -  9.90e-01 4.76e-01f  1\n   4  1.4300626e+01 9.40e-03 8.29e+01  -0.9 7.64e-01    -  9.96e-01 9.50e-01h  1\n   5  7.4610678e+00 6.94e-03 6.21e+01  -0.6 2.99e-01    -  5.79e-01 2.52e-01f  1\n   6  1.2267991e+01 5.40e-03 7.33e+01  -1.1 4.51e-01    -  4.98e-01 5.69e-01h  1\n   7  1.7065490e-01 3.24e-03 4.49e+01  -1.1 3.09e-01    -  9.99e-01 1.00e+00f  1\n   8  6.0996265e+00 8.75e-05 4.33e+01  -2.1 6.27e-02    -  1.00e+00 1.00e+00h  1\n   9  3.8925630e+00 1.21e-04 4.48e+01  -2.8 5.06e-02    -  1.00e+00 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10  1.4983946e+00 1.15e-03 4.17e+01  -0.9 2.23e+00    -  1.00e+00 6.93e-02f  1\n  11  1.0833803e+00 5.76e-04 9.08e+01  -1.1 3.01e-01    -  1.00e+00 7.50e-01H  1\n  12  4.5664490e-01 6.33e-04 5.04e+01  -1.8 1.94e-01    -  1.00e+00 5.00e-01f  2\n  13  4.4934791e-01 4.84e-04 5.04e+01  -1.5 1.09e-01    -  1.00e+00 1.00e+00f  1\n  14  2.1162469e-02 3.84e-05 7.46e+01  -2.1 3.12e-02    -  1.00e+00 1.00e+00f  1\n  15  4.6622144e-01 3.47e-05 9.29e+01  -2.7 6.07e-02    -  1.00e+00 1.00e+00H  1\n  16  1.2824669e-01 1.12e-04 7.25e+01  -2.4 3.40e-02    -  1.00e+00 1.00e+00f  1\n  17  8.2158238e-02 2.49e-04 2.43e+01  -2.5 2.07e-01    -  4.76e-01 2.27e-01f  3\n  18  1.8287871e-01 2.35e-04 3.44e+01  -2.5 9.58e-02    -  9.98e-01 7.54e-01H  1\n  19  9.2460686e-02 5.68e-05 5.16e+01  -2.5 6.16e-02    -  1.00e+00 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20  4.7278228e-04 4.73e-05 4.92e+01  -2.7 2.48e-02    -  1.00e+00 1.00e+00f  1\n  21  4.7454281e-04 4.73e-05 5.08e+01  -2.0 1.41e+00    -  1.00e+00 2.10e-05h 14\n  22  4.2800931e-04 1.24e-05 5.31e+01  -2.1 1.65e-02    -  1.00e+00 1.00e+00h  1\n  23  4.5994849e-04 7.54e-06 5.18e+01  -3.3 1.19e-02    -  1.00e+00 1.00e+00h  1\n  24  4.3009438e-04 4.75e-06 5.06e+01  -4.0 1.45e-02    -  1.00e+00 1.00e+00h  1\n  25  5.4442265e-04 2.42e-05 4.86e+01  -3.7 8.68e-02    -  1.00e+00 5.00e-01h  2\n  26  4.7473324e-04 5.23e-06 4.89e+01  -3.8 1.83e-02    -  1.00e+00 1.00e+00h  1\n  27  4.5406236e-04 7.62e-06 5.03e+01  -3.8 1.87e-02    -  1.00e+00 5.00e-01h  2\n  28  4.2105104e-04 7.08e-06 5.09e+01  -3.8 8.87e-03    -  1.00e+00 1.00e+00h  1\n  29  4.3034760e-04 6.99e-06 4.91e+01  -3.8 8.52e-02    -  1.00e+00 1.56e-02h  7\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  30  4.1471068e-04 1.17e-05 4.90e+01  -3.8 8.28e-03    -  1.00e+00 1.00e+00h  1\n  31  4.1667112e-04 9.46e-07 5.11e+01  -4.0 3.42e-03    -  1.00e+00 1.00e+00h  1\n  32  4.0963836e-04 1.12e-05 4.85e+01  -4.0 8.49e-03    -  1.00e+00 1.00e+00h  1\n  33  4.1563562e-04 1.22e-06 5.13e+01  -4.1 4.20e-03    -  1.00e+00 1.00e+00h  1\n  34  4.1208956e-04 3.84e-06 5.11e+01  -4.1 7.16e-03    -  1.00e+00 1.00e+00h  1\n  35  4.0851137e-04 3.97e-06 4.84e+01  -4.1 4.14e-03    -  1.00e+00 1.00e+00h  1\n  36  4.1304859e-04 1.30e-06 5.21e+01  -4.1 4.04e-03    -  1.00e+00 1.00e+00h  1\n  37  4.1063139e-04 5.21e-07 5.17e+01  -4.1 2.83e-03    -  1.00e+00 1.00e+00h  1\n  38  4.1349538e-04 2.30e-06 4.54e+01  -4.0 5.61e-03    -  1.00e+00 1.00e+00h  1\n  39  4.0933491e-04 8.26e-07 4.75e+01  -4.1 2.90e-03    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  40  4.1198410e-04 3.14e-07 5.17e+01  -4.1 1.82e-03    -  1.00e+00 1.00e+00h  1\n  41  4.1127838e-04 2.58e-07 5.20e+01  -4.0 2.37e-03    -  1.00e+00 2.50e-01h  3\n  42  4.0815404e-04 2.51e-07 4.76e+01  -4.1 4.88e-03    -  1.00e+00 2.50e-01h  3\n  43  4.0875847e-04 3.48e-07 5.22e+01  -4.1 1.32e-03    -  1.00e+00 1.00e+00h  1\n  44  4.0902310e-04 3.42e-08 4.67e+01  -4.1 7.97e-04    -  1.00e+00 1.00e+00h  1\n  45  4.0911881e-04 1.01e-07 4.55e+01  -4.0 1.22e-03    -  1.00e+00 5.00e-01h  2\n  46  4.0888894e-04 3.45e-08 5.71e+01  -4.1 6.44e-04    -  1.00e+00 1.00e+00h  1\n  47  4.0903369e-04 1.80e-08 4.23e+01  -4.1 3.65e-04    -  1.00e+00 1.00e+00h  1\n  48  4.1323930e-04 3.43e-06 4.53e+01  -4.1 5.06e-03    -  1.00e+00 1.00e+00h  1\n  49  4.1031875e-04 3.14e-06 5.45e+01  -4.1 3.95e-03    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50  4.0843331e-04 3.44e-07 4.71e+01  -4.1 2.26e-03    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 50\n\n                                   (scaled)                 (unscaled)\nObjective...............:   4.0843331022243112e-04    4.0843331022243112e-04\nDual infeasibility......:   4.7126814277052439e+01    4.7126814277052439e+01\nConstraint violation....:   3.4372635648871608e-07    3.4372635648871608e-07\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   7.9999652601767538e-05    7.9999652601767538e-05\nOverall NLP error.......:   4.7126814277052439e+01    4.7126814277052439e+01\n\n\nNumber of objective function evaluations             = 102\nNumber of objective gradient evaluations             = 51\nNumber of equality constraint evaluations            = 102\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 51\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 0\nTotal seconds in IPOPT                               = 0.962\n\nEXIT: Maximum Number of Iterations Exceeded. The above output comes from the Ipopt.jl solver. The problem's trajectory has been updated with the solution. We can see the final control amplitudes and the final unitary by accessing the  a  and  Ũ⃗  fields of the trajectory. size(prob.trajectory.a) |> println\nsize(prob.trajectory.Ũ⃗) |> println (2, 50)\n(8, 50) The  Ũ⃗  field is a vectorized representation of the unitary, which we can convert back to a matrix using the  iso_vec_to_operator  function exported by PiccoloQuantumObjects.jl. iso_vec_to_operator(prob.trajectory.Ũ⃗[:, end]) |> pretty_print 2×2 Matrix{ComplexF64}:\n -0.00151457+2.96891e-5im  -0.000126106-1.0im\n 0.000126106-1.0im          -0.00151457-2.96891e-5im To see the final fidelity we can use the  unitary_rollout_fidelity  function exported by QuantumCollocation.jl. println(\"Final fidelity: \", unitary_rollout_fidelity(prob.trajectory, system)) Final fidelity: 0.9999976875824873 We can also easily plot the solutions using the  plot  function exported by NamedTrajectories.jl. plot(prob.trajectory, [:Ũ⃗, :a])"},{"id":24,"pagetitle":"Quickstart","title":"Minimum Time Problems","ref":"/Piccolo/dev/generated/quickstart/#Minimum-Time-Problems","content":" Minimum Time Problems We can also easily set up and solve a minimum time problem, where we enforce a constraint on the final fidelity: \\[\\mathcal{F}(U_T, U_{\\text{goal}}) \\geq \\mathcal{F}_{\\text{min}}\\] Using the problem we just solved we can do the following: # final fidelity constraint\nfinal_fidelity = 0.99\n\nmin_time_prob = UnitaryMinimumTimeProblem(prob, system; final_fidelity = final_fidelity)\n\nsolve!(min_time_prob; max_iter = 50)     building dynamics from integrators...\n        constructing knot point dynamics functions...\n        constructing full dynamics derivative functions...\n    building evaluator...\n    initializing optimizer...\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt\n        applying constraint: time step all equal constraint\n    finished.\nThis is Ipopt version 3.14.17, running with linear solver MUMPS 5.7.3.\n\nNumber of nonzeros in equality constraint Jacobian...:    17546\nNumber of nonzeros in inequality constraint Jacobian.:        8\nNumber of nonzeros in Lagrangian Hessian.............:        0\n\nTotal number of variables............................:      736\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:      244\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:      637\nTotal number of inequality constraints...............:        1\n        inequality constraints with only lower bounds:        1\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  1.2445102e+01 3.44e-07 1.98e-01   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.1470599e+01 5.44e-04 1.71e+00  -1.7 6.98e-02    -  9.99e-01 1.00e+00f  1\n   2  1.0823427e+01 4.14e-04 2.09e+00  -2.3 7.23e-02    -  1.00e+00 6.97e-01f  1\n   3  9.5924080e+00 2.10e-03 1.00e+02  -2.0 2.79e-01    -  1.00e+00 3.72e-01f  1\n   4  1.0081008e+01 6.13e-04 5.00e+01  -1.7 1.31e-01    -  1.00e+00 1.00e+00f  1\n   5  9.5891670e+00 3.32e-04 4.23e+01  -2.0 1.02e-01    -  1.00e+00 1.00e+00f  1\n   6  9.3306675e+00 2.40e-04 7.13e+01  -2.4 1.14e-01    -  1.00e+00 5.44e-01f  1\n   7  8.9217193e+00 2.15e-04 2.13e+01  -2.7 6.83e-02    -  1.00e+00 9.59e-01f  1\n   8  9.2226326e+00 1.59e-04 5.51e-01  -2.3 3.64e-02    -  1.00e+00 1.00e+00h  1\n   9  9.0453261e+00 9.14e-05 1.97e+01  -2.8 2.26e-02    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10  8.9788843e+00 4.42e-05 1.45e+01  -3.3 2.38e-02    -  1.00e+00 7.27e-01h  1\n  11  8.9760668e+00 1.97e-05 4.27e+00  -3.0 2.61e-02    -  9.62e-01 1.00e+00h  1\n  12  8.9372567e+00 1.72e-05 4.38e+00  -3.4 1.51e-02    -  1.00e+00 9.37e-01h  1\n  13  8.9180037e+00 1.72e-05 2.34e+00  -4.0 2.27e-02    -  1.00e+00 6.97e-01h  1\n  14  8.9098777e+00 1.14e-05 6.85e-01  -4.0 3.47e-02    -  1.00e+00 7.08e-01h  1\n  15  8.9080568e+00 5.71e-06 3.19e-01  -4.0 6.15e-02    -  1.00e+00 5.35e-01h  1\n  16  8.9069605e+00 2.94e-06 1.49e-01  -4.0 5.60e-02    -  1.00e+00 6.63e-01h  1\n  17  8.9070487e+00 2.69e-07 8.48e-03  -4.0 9.86e-03    -  1.00e+00 1.00e+00h  1\n  18  8.9070900e+00 8.06e-09 1.63e-02  -4.0 9.18e-04    -  1.00e+00 1.00e+00h  1\n  19  8.9070916e+00 6.59e-10 1.06e-03  -4.0 2.31e-04    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20  8.9070915e+00 1.46e-11 1.07e-04  -4.0 3.01e-05    -  1.00e+00 1.00e+00h  1\n  21  8.9070914e+00 7.86e-13 9.06e-06  -4.0 1.07e-05    -  1.00e+00 1.00e+00h  1\n  22  8.9070914e+00 2.73e-13 1.73e-05  -4.0 7.20e-06    -  1.00e+00 1.00e+00h  1\n  23  8.9070913e+00 2.31e-14 4.85e-06  -4.0 3.28e-06    -  1.00e+00 1.00e+00h  1\n  24  8.9070913e+00 9.99e-16 1.15e-06  -4.0 7.30e-07    -  1.00e+00 1.00e+00h  1\n  25  8.9070913e+00 6.49e-16 3.39e-07  -4.0 5.23e-07    -  1.00e+00 1.00e+00h  1\n  26  8.9052893e+00 1.21e-07 7.77e-03  -4.1 2.76e-03    -  1.00e+00 1.00e+00f  1\n  27  8.9071006e+00 1.26e-07 5.12e-04  -4.0 2.88e-03    -  1.00e+00 1.00e+00h  1\n  28  8.9052186e+00 7.60e-08 1.52e-02  -4.1 4.40e-03    -  1.00e+00 1.00e+00h  1\n  29  8.9070881e+00 7.16e-08 2.11e-04  -4.0 4.33e-03    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  30  8.9052224e+00 1.31e-07 5.57e-03  -4.1 4.29e-03    -  1.00e+00 1.00e+00h  1\n  31  8.9070904e+00 1.29e-07 3.72e-04  -4.0 4.19e-03    -  1.00e+00 1.00e+00h  1\n  32  8.9052089e+00 2.15e-07 1.88e-02  -4.1 4.71e-03    -  1.00e+00 1.00e+00h  1\n  33  8.9070778e+00 2.15e-07 5.18e-04  -4.0 4.68e-03    -  1.00e+00 1.00e+00h  1\n  34  8.9052254e+00 1.45e-07 1.28e-03  -4.1 4.12e-03    -  1.00e+00 1.00e+00h  1\n  35  8.9052258e+00 1.06e-08 1.47e-02  -4.1 1.13e-03    -  1.00e+00 1.00e+00h  1\n  36  8.9070755e+00 1.06e-07 3.73e-04  -4.0 4.07e-03    -  1.00e+00 1.00e+00h  1\n  37  8.9052254e+00 1.45e-07 7.61e-04  -4.1 4.09e-03    -  1.00e+00 1.00e+00h  1\n  38  8.8993114e+00 7.33e-07 1.42e-02  -6.1 1.62e-02    -  8.39e-01 7.99e-01f  1\n  39  8.9070359e+00 1.13e-06 7.83e-03  -4.0 1.50e-02    -  1.00e+00 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  40  8.9051787e+00 8.10e-07 3.14e-02  -4.1 6.61e-03    -  1.00e+00 1.00e+00h  1\n  41  8.9068725e+00 8.67e-07 2.29e-03  -4.0 6.15e-03    -  1.00e+00 1.00e+00h  1\n  42  8.9052250e+00 1.41e-07 1.64e-03  -4.1 3.85e-03    -  1.00e+00 1.00e+00h  1\n  43  8.9052252e+00 2.87e-09 1.38e-03  -4.1 6.18e-04    -  1.00e+00 1.00e+00h  1\n  44  8.9070916e+00 1.39e-07 2.75e-03  -4.0 3.98e-03    -  1.00e+00 1.00e+00f  1\n  45  8.9052255e+00 1.25e-07 3.63e-04  -4.1 4.00e-03    -  1.00e+00 1.00e+00h  1\n  46  8.8997459e+00 1.42e-06 3.47e-02  -6.1 1.61e-02    -  8.43e-01 7.41e-01f  1\n  47  8.8978912e+00 3.28e-06 6.84e-02  -6.1 2.16e-02    -  9.04e-01 9.40e-01h  1\n  48  8.8987337e+00 2.69e-06 5.80e-03  -4.9 1.85e-02    -  1.00e+00 1.00e+00f  1\n  49  8.9070416e+00 1.31e-06 9.32e-03  -4.0 1.44e-02    -  1.00e+00 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50  8.9052426e+00 1.71e-07 3.57e-02  -4.1 4.72e-03    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 50\n\n                                   (scaled)                 (unscaled)\nObjective...............:   8.9052426469861601e+00    8.9052426469861601e+00\nDual infeasibility......:   3.5731791311526193e-02    3.5731791311526193e-02\nConstraint violation....:   1.7105092508379327e-07    1.7105092508379327e-07\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   9.4350239722294468e-05    9.4350239722294468e-05\nOverall NLP error.......:   3.5731791311526193e-02    3.5731791311526193e-02\n\n\nNumber of objective function evaluations             = 51\nNumber of objective gradient evaluations             = 51\nNumber of equality constraint evaluations            = 51\nNumber of inequality constraint evaluations          = 51\nNumber of equality constraint Jacobian evaluations   = 51\nNumber of inequality constraint Jacobian evaluations = 51\nNumber of Lagrangian Hessian evaluations             = 0\nTotal seconds in IPOPT                               = 2.789\n\nEXIT: Maximum Number of Iterations Exceeded. We can see that the final fidelity is indeed greater than the minimum fidelity we set. println(\"Final fidelity:    \", unitary_rollout_fidelity(min_time_prob.trajectory, system)) Final fidelity:    0.9975771244834203 and that the duration of the pulse has decreased. initial_duration = get_times(prob.trajectory)[end]\nmin_time_duration = get_times(min_time_prob.trajectory)[end]\n\nprintln(\"Initial duration:  \", initial_duration)\nprintln(\"Minimum duration:  \", min_time_duration)\nprintln(\"Duration decrease: \", initial_duration - min_time_duration)\n\n# We can also plot the solutions for the minimum time problem, and see that the control amplitudes saturate the bound.\nplot(min_time_prob.trajectory, [:Ũ⃗, :a]) This page was generated using  Literate.jl ."},{"id":27,"pagetitle":"-","title":"Library","ref":"/Piccolo/dev/lib/#Library","content":" Library"},{"id":30,"pagetitle":"Release Notes","title":"Release Notes","ref":"/Piccolo/dev/release_notes/#Release-Notes","content":" Release Notes The format is based on  Keep a Changelog , and this project adheres to  Semantic Versioning ."},{"id":31,"pagetitle":"Release Notes","title":"[v0.3.1] - 2024-10-17","ref":"/Piccolo/dev/release_notes/#[v0.3.1]-2024-10-17","content":" [v0.3.1] - 2024-10-17"},{"id":32,"pagetitle":"Release Notes","title":"Fixed","ref":"/Piccolo/dev/release_notes/#Fixed","content":" Fixed Fixed and added tests to  RydbergChainSystem"},{"id":33,"pagetitle":"Release Notes","title":"[v0.3.0] - 2024-10-10","ref":"/Piccolo/dev/release_notes/#[v0.3.0]-2024-10-10","content":" [v0.3.0] - 2024-10-10"},{"id":34,"pagetitle":"Release Notes","title":"Added","ref":"/Piccolo/dev/release_notes/#Added","content":" Added PiccoloOptions  to handle custome problem settings."},{"id":35,"pagetitle":"Release Notes","title":"Changed","ref":"/Piccolo/dev/release_notes/#Changed","content":" Changed Refactored trajectory initialization functions Improved documentation Typo fixes"},{"id":36,"pagetitle":"Release Notes","title":"[v0.2.0] - 2024-02-22","ref":"/Piccolo/dev/release_notes/#[v0.2.0]-2024-02-22","content":" [v0.2.0] - 2024-02-22"},{"id":37,"pagetitle":"Release Notes","title":"Added","ref":"/Piccolo/dev/release_notes/#Added-2","content":" Added EmbeddedOperator  to handle subspace gate optimization and leakage suppression Plotting methods for unitary populations"},{"id":38,"pagetitle":"Release Notes","title":"Changed","ref":"/Piccolo/dev/release_notes/#Changed-2","content":" Changed New quantum systems interface Transmon system template Restructured the code base for easier quantum system and problem template development"},{"id":39,"pagetitle":"Release Notes","title":"Removed","ref":"/Piccolo/dev/release_notes/#Removed","content":" Removed Stale examples "},{"id":40,"pagetitle":"Release Notes","title":"Fixed","ref":"/Piccolo/dev/release_notes/#Fixed-2","content":" Fixed Robustness improvements objective test fixes "},{"id":43,"pagetitle":"Home","title":"PiccoloQuantumObjects","ref":"/PiccoloQuantumObjects/dev/#PiccoloQuantumObjects","content":" PiccoloQuantumObjects PiccoloQuantumObjects.jl  is a Julia package for working with quantum objects. It provides tools for constructing and manipulating quantum states and operators. It is designed to be used with other packages in the  Piccolo.jl  ecosystem, such as  QuantumCollocation.jl  and  NamedTrajectories.jl ."},{"id":44,"pagetitle":"Home","title":"Installation","ref":"/PiccoloQuantumObjects/dev/#Installation","content":" Installation This package is registered! To install, enter the Julia REPL, type  ]  to enter pkg mode, and then run: pkg> add PiccoloQuantumObjects"},{"id":45,"pagetitle":"Home","title":"Usage","ref":"/PiccoloQuantumObjects/dev/#Usage","content":" Usage The following example demonstrates how to create a quantum state, create a quantum operator, and apply the operator to the state: using PiccoloQuantumObjects\n\n# Create a quantum state\nstate = ket_from_string(\"g\", [2])\n\n# Create a quantum operator\noperator = PAULIS.X\n\n# Apply the operator to the state\nnew_state = operator * state\n\n# Transform the state to its real representation\nnew_iso_state = ket_to_iso(new_state)\n\n# Transform back\niso_to_ket(new_iso_state)"},{"id":48,"pagetitle":"Isomorphisms","title":"Isomorphisms","ref":"/PiccoloQuantumObjects/dev/generated/isomorphisms/#Isomorphisms","content":" Isomorphisms using PiccoloQuantumObjects\nusing SparseArrays # for visualization Linear algebra operations on quantum objects are often performed on real vectors and matrices. We provide isomorphisms to convert between complex and real representations of quantum objects. These isomorphisms are used internally by the  QuantumSystem  type to perform quantum dynamics."},{"id":49,"pagetitle":"Isomorphisms","title":"Quantum state isomorphisms","ref":"/PiccoloQuantumObjects/dev/generated/isomorphisms/#Quantum-state-isomorphisms","content":" Quantum state isomorphisms ket_to_iso  is the real isomorphism of a quantum state  ψ ∈ ℂⁿ iso_to_ket  is the inverse isomorphism of a real vector  ψ̃ ∈ ℝ²ⁿ ψ = [1; 2] + im * [3; 4]\nψ̃ = ket_to_iso(ψ) 4-element Vector{Int64}:\n 1\n 2\n 3\n 4 iso_to_ket(ψ̃) 2-element Vector{Complex{Int64}}:\n 1 + 3im\n 2 + 4im"},{"id":50,"pagetitle":"Isomorphisms","title":"Quantum operator isomorphisms","ref":"/PiccoloQuantumObjects/dev/generated/isomorphisms/#Quantum-operator-isomorphisms","content":" Quantum operator isomorphisms We often need to convert a complex matrix  U  to a real vector  Ũ⃗ . We provoide the following isomorphisms to convert between the two representations. iso_vec_to_operator (Ũ⃗::AbstractVector{ℝ}) operator_to_iso_vec (U::AbstractVector{ℂ}) iso_vec_to_iso_operator (Ũ⃗::AbstractVector{ℝ}) iso_operator_to_iso_vec (Ũ::AbstractMatrix{ℝ}) iso_operator_to_operator (Ũ::AbstractMatrix{ℝ}) operator_to_iso_operator (U::AbstractMatrix{ℂ}) In additon, we provide  mat (x::AbstractVector)  to convert a vector  x  into a square matrix, as the inverse to Base's  vec . Julia uses column-major order. U = [1 5; 2 6] + im * [3 7; 4 8]\nŨ⃗ = operator_to_iso_vec(U) 8-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8 iso_vec_to_operator(Ũ⃗) 2×2 Matrix{Complex{Int64}}:\n 1+3im  5+7im\n 2+4im  6+8im"},{"id":51,"pagetitle":"Isomorphisms","title":"Density matrix isomorphisms","ref":"/PiccoloQuantumObjects/dev/generated/isomorphisms/#Density-matrix-isomorphisms","content":" Density matrix isomorphisms The isomorphisms for density matrices are: density_to_iso_vec (ρ::AbstractMatrix{ℂ}) iso_vec_to_density (ρ̃::AbstractVector{ℝ}) Warning The isomorphism  density_to_iso_vec  is not the same as  operator_to_iso_vec . ρ = [1 2; 3 4] + im * [5 6; 7 8]\nρ̃⃗ = density_to_iso_vec(ρ) 8-element Vector{Int64}:\n 1\n 3\n 2\n 4\n 5\n 7\n 6\n 8"},{"id":52,"pagetitle":"Isomorphisms","title":"Quantum dynamics isomorphisms","ref":"/PiccoloQuantumObjects/dev/generated/isomorphisms/#Quantum-dynamics-isomorphisms","content":" Quantum dynamics isomorphisms The quantum dynamics isomorphisms, which correspond to these state transformations, are handled internally by the  QuantumSystem  type. The  Isomorphisms.iso  isomorphism of a Hamiltonian  $H$  is: \\[\\text{iso}(H) := \\widetilde{H} = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] where  $\\Im(H)$  and  $\\Re(H)$  are the imaginary and real parts of  $H$  and the tilde indicates the standard isomorphism of a complex valued matrix: \\[\\widetilde{H} := \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] Hence, the generator  Isomorphisms.G  associated to a Hamiltonian  $H$  is: \\[G(H) := \\text{iso}(- i \\widetilde{H}) = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Im(H) - \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Re(H)\\] This page was generated using  Literate.jl ."},{"id":55,"pagetitle":"Quantum Objects","title":"Quantum Objects","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#Quantum-Objects","content":" Quantum Objects using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n⊗ = kron; Quantum states and operators are represented as complex vectors and matrices. We provide a number of convenient ways to construct these objects. We also provide some tools for working with these objects, such as embedding operators in larger Hilbert spaces and selecting subspace indices."},{"id":56,"pagetitle":"Quantum Objects","title":"Quantum states","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#Quantum-states","content":" Quantum states We can construct quantum states from bitstrings or string representations. The string representations use atomic notation (ground state  g , excited state  e , etc.). Ground state in a 2-level system. ket_from_string(\"g\", [2]) 2-element Vector{ComplexF64}:\n 1.0 + 0.0im\n 0.0 + 0.0im Superposition state coupled to a ground state in two 2-level systems. ket_from_string(\"(g+e)g\", [2,2]) 4-element Vector{ComplexF64}:\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im |01⟩  in a 2-qubit system. ket_from_bitstring(\"01\") 4-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im"},{"id":57,"pagetitle":"Quantum Objects","title":"Quantum operators","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#Quantum-operators","content":" Quantum operators Frequently used operators are provided in  PAULIS  and  GATES ."},{"id":58,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.Gates.GATES","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.Gates.GATES-generated-quantum_objects","content":" PiccoloQuantumObjects.Gates.GATES  —  Constant A constant dictionary  GATES  containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix. GATES[:I]  - Identity: Leaves the state unchanged. GATES[:X]  - Pauli-X (NOT): Flips the qubit state. GATES[:Y]  - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere. GATES[:Z]  - Pauli-Z: Flips the phase of the qubit state. GATES[:H]  - Hadamard: Creates superposition by transforming basis states. GATES[:CX]  - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1⟩. GATES[:CZ]  - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1⟩. GATES[:XI]  - Complex: A gate for complex operations. GATES[:sqrtiSWAP]  - Square root of iSWAP: Partially swaps two qubits with a phase. source Quantum operators can also be constructed from strings. operator_from_string(\"X\") 2×2 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im operator_from_string(\"XZ\") 4×4 Matrix{ComplexF64}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im Annihilation and creation operators are provided for oscillator systems. a = annihilate(3) 3×3 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im      0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.41421+0.0im\n 0.0+0.0im  0.0+0.0im      0.0+0.0im a⁺ = create(3) 3×3 Matrix{ComplexF64}:\n 0.0-0.0im      0.0-0.0im  0.0-0.0im\n 1.0-0.0im      0.0-0.0im  0.0-0.0im\n 0.0-0.0im  1.41421-0.0im  0.0-0.0im a'a 3×3 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  2.0+0.0im"},{"id":59,"pagetitle":"Quantum Objects","title":"Random operators","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#Random-operators","content":" Random operators The  haar_random  function draws random unitary operators according to the Haar measure. haar_random(3) 3×3 Matrix{ComplexF64}:\n  0.631949+0.315518im  -0.372998+0.0946842im     0.4866-0.340905im\n -0.531964-0.404798im  -0.590164+0.177632im    0.407819-0.0836065im\n  0.161068+0.16822im   -0.590893+0.35058im    -0.544388+0.421117im If we want to generate random operations that are close to the identity, we can use the  haar_identity  function. haar_identity(2, 0.1) 2×2 Matrix{ComplexF64}:\n   0.991663+0.07004im    0.106357-0.0196648im\n -0.0989777-0.0436101im   0.98117+0.160024im A smaller radius means the random operator is closer to the identity. haar_identity(2, 0.01) 2×2 Matrix{ComplexF64}:\n  0.999752-0.000210482im  -0.0135633+0.0176608im\n 0.0136849+0.0175667im       0.99973-0.0066914im"},{"id":60,"pagetitle":"Quantum Objects","title":"Embedded operators","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#Embedded-operators","content":" Embedded operators Sometimes we want to embed a quantum operator into a larger Hilbert space,  $\\mathcal{H}$ , which we decompose into subspace and leakage components: \\[    \\mathcal{H} = \\mathcal{H}_{\\text{subspace}} \\oplus \\mathcal{H}_{\\text{leakage}},\\] In quantum computing, the computation is encoded in a  subspace , while the remaining  leakage  states should be avoided."},{"id":61,"pagetitle":"Quantum Objects","title":"The embed and unembed functions","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#The-embed-and-unembed-functions","content":" The  embed  and  unembed  functions The  embed  function allows to embed a quantum operator in a larger Hilbert space."},{"id":62,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.embed-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.embed  —  Function embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int) Embed an  operator  in the  subspace  of a larger matrix of size  levels x levels . source embed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator) Embed the  subspace_operator  in the subspace of a larger  embedded_operator . source The  unembed  function allows to unembed a quantum operator from a larger Hilbert space."},{"id":63,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.unembed-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Function unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}) Unembed a subspace operator from the  matrix . This is equivalent to calling  matrix[subspace, subspace] . source unembed(embedded_op::EmbeddedOperator)::Matrix{ComplexF64} Unembed an embedded operator, returning the original operator. source unembed(op::AbstractMatrix, embedded_op::EmbeddedOperator) Unembed a sub-matrix from the  op  at the subspace defined by  embedded_op . source Embed a two-level X gate into a multilevel system. levels = 3\nX = GATES[:X]\nsubspace_indices = 1:2\nX_embedded = embed(X, subspace_indices, levels) 3×3 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im  0.0+0.0im\n 1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im Unembed to retrieve the original operator. X_original = unembed(X_embedded, subspace_indices) 2×2 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im"},{"id":64,"pagetitle":"Quantum Objects","title":"The EmbeddedOperator type","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#The-EmbeddedOperator-type","content":" The  EmbeddedOperator  type The  EmbeddedOperator  type stores information about an operator embedded in the subspace of a larger quantum system."},{"id":65,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Type EmbeddedOperator Embedded operator type to represent an operator embedded in a subspace of a larger quantum system. Fields operator::Matrix{ComplexF64} : Embedded operator of size    prod(subsystem_levels) x prod(subsystem_levels) . subspace::Vector{Int} : Indices of the subspace the operator is embedded in. subsystem_levels::Vector{Int} : Levels of the subsystems in the composite system. source We construct an embedded operator in the same manner as the  embed  function."},{"id":66,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{Matrix{<:Number}, AbstractVector{Int64}, AbstractVector{Int64}}-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int}) Create an embedded operator. The  operator  is embedded at the  subspace  of the system spanned by the  subsystem_levels . source Embed an X gate in the first qubit's subspace within two 3-level systems. gate = GATES[:X] ⊗ GATES[:I]\nsubsystem_levels = [3, 3]\nsubspace_indices = get_subspace_indices([1:2, 1:2], subsystem_levels)\nembedded_operator = EmbeddedOperator(gate, subspace_indices, subsystem_levels) EmbeddedOperator(ComplexF64[0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im; … ; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im], [1, 2, 4, 5], [3, 3]) Show the full operator. embedded_operator.operator .|> real |> sparse 9×9 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅  Get the original operator back. unembed(embedded_operator) .|> real |> sparse 4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅    ⋅   1.0   ⋅ \n  ⋅    ⋅    ⋅   1.0\n 1.0   ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅  Embedded operators for composite systems are also supported."},{"id":67,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n) Embed the  subspace_operator  into the provided  subspaces  of a composite system, where the  subsystem_indices  list the subspaces at which the operator is defined, and the  subsystem_levels  list the levels of the subsystems in which the operator is embedded. source This is a two step process. The provided subspace operator is  lift -ed  from the  subsystem_indices  where  it is defined into the space spanned by the composite system's  subspaces . The lifted operator is embedded into the full Hilbert space spanned by the   subsystem_levels . Embed a CZ gate with control qubit 1 and target qubit 3 into a composite system made up of three 3-level systems. An identity is performed on qubit 2. subsystem_levels = [3, 3, 3]\nsubspaces = [1:2, 1:2, 1:2]\nembedded_operator = EmbeddedOperator(GATES[:CZ], [1, 3], subspaces, subsystem_levels)\nunembed(embedded_operator) .|> real |> sparse 8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n 1.0   ⋅    ⋅    ⋅    ⋅     ⋅    ⋅     ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅     ⋅    ⋅     ⋅ \n  ⋅    ⋅   1.0   ⋅    ⋅     ⋅    ⋅     ⋅ \n  ⋅    ⋅    ⋅   1.0   ⋅     ⋅    ⋅     ⋅ \n  ⋅    ⋅    ⋅    ⋅   1.0    ⋅    ⋅     ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅   -1.0   ⋅     ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅     ⋅   1.0    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅     ⋅    ⋅   -1.0"},{"id":68,"pagetitle":"Quantum Objects","title":"Subspace and leakage indices","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#Subspace-and-leakage-indices","content":" Subspace and leakage indices"},{"id":69,"pagetitle":"Quantum Objects","title":"The get_subspace_indices function","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#The-get_subspace_indices-function","content":" The  get_subspace_indices  function The  get_subspace_indices  function is a convenient way to get the indices of a subspace in a larger quantum system."},{"id":70,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices  —  Function get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)\nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator) Get the indices for the provided subspace of the quantum system. source Its dual function is  get_leakage_indices . get_subspace_indices(1:2, 5) |> collect, get_leakage_indices(1:2, 5) |> collect ([1, 2], [3, 4, 5]) Composite systems are supported. Get the indices of the two-qubit subspace within two 3-level systems. get_subspace_indices([1:2, 1:2], [3, 3]) 4-element Vector{Int64}:\n 1\n 2\n 4\n 5 Qubits are assumed if the indices are not provided. get_subspace_indices([3, 3]) 4-element Vector{Int64}:\n 1\n 2\n 4\n 5 get_leakage_indices([3, 3]) 5-element Vector{Int64}:\n 3\n 6\n 7\n 8\n 9"},{"id":71,"pagetitle":"Quantum Objects","title":"Excitation number restrictions","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#Excitation-number-restrictions","content":" Excitation number restrictions Sometimes we want to cap the number of excitations we allow across a composite system. For example, if we want to restrict ourselves to the ground and single excitation states of two 3-level systems: get_enr_subspace_indices(1, [3, 3]) 3-element Vector{Int64}:\n 1\n 2\n 4"},{"id":72,"pagetitle":"Quantum Objects","title":"The get_iso_vec_subspace_indices function","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#The-get_iso_vec_subspace_indices-function","content":" The  get_iso_vec_subspace_indices  function For isomorphic operators, the  get_iso_vec_subspace_indices  function can be used to find the appropriate vector indices of the equivalent operator subspace. See also,  Isomorphisms#Quantum-operator-isomorphisms ."},{"id":73,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices  —  Function get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator) Get the indices for the subspace in the isomorphic vector space for operators. source Its dual function is  get_iso_vec_leakage_indices , which by default only returns the leakage indices of the blocks: \\[\\mathcal{H}_{\\text{subspace}} \\otimes \\mathcal{H}_{\\text{subspace}},\\quad\n\\mathcal{H}_{\\text{subspace}} \\otimes \\mathcal{H}_{\\text{leakage}},\\quad\n\\mathcal{H}_{\\text{leakage}} \\otimes \\mathcal{H}_{\\text{subspace}}\\] allowing for leakage-suppressing code to disregard the uncoupled pure-leakage space. get_iso_vec_subspace_indices(1:2, 3) 8-element Vector{Int64}:\n  1\n  2\n  4\n  5\n  7\n  8\n 10\n 11 without_pure_leakage = get_iso_vec_leakage_indices(1:2, 3) 8-element Vector{Int64}:\n  3\n  6\n  9\n 12\n 13\n 14\n 16\n 17 Show the pure-leakage indices. with_pure_leakage = get_iso_vec_leakage_indices(1:2, 3, ignore_pure_leakage=false)\nsetdiff(with_pure_leakage, without_pure_leakage) 2-element Vector{Int64}:\n 15\n 18 The pure-leakage indices can grow quickly! without_pure_leakage = get_iso_vec_leakage_indices([1:2, 1:2], [4, 4])\nwith_pure_leakage = get_iso_vec_leakage_indices([1:2, 1:2], [4, 4], ignore_pure_leakage=false)\nsetdiff(with_pure_leakage, without_pure_leakage) |> length 288 This page was generated using  Literate.jl ."},{"id":76,"pagetitle":"Quantum Systems","title":"Abstract Quantum Systems","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#Abstract-Quantum-Systems","content":" Abstract Quantum Systems using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n⊗ = kron;"},{"id":77,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem  —  Type AbstractQuantumSystem Abstract type for defining systems. source"},{"id":78,"pagetitle":"Quantum Systems","title":"Quantum Systems","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#Quantum-Systems","content":" Quantum Systems The  QuantumSystem  type is used to represent a quantum system with a drift Hamiltonian and a set of drive Hamiltonians, \\[H = H_{\\text{drift}} + \\sum_i a_i H_{\\text{drives}}^{(i)}\\]"},{"id":79,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystems.QuantumSystem  —  Type QuantumSystem <: AbstractQuantumSystem A struct for storing quantum dynamics and the appropriate gradients. Fields H::Function : The Hamiltonian function, excluding dissipation: a -> H(a). G::Function : The isomorphic generator function, including dissipation, a -> G(a). ∂G::Function : The generator jacobian function, a -> ∂G(a). levels::Int : The number of levels in the system. n_drives::Int : The number of drives in the system. Constructors QuantumSystem(H drift::AbstractMatrix{<:Number}, H drives::Vector{<:AbstractMatrix{<:Number}}; kwargs...) QuantumSystem(H_drift::AbstractMatrix{<:Number}; kwargs...) QuantumSystem(H_drives::Vector{<:AbstractMatrix{<:Number}}; kwargs...) QuantumSystem(H::Function, n_drives::Int; kwargs...) source QuantumSystem 's are containers for quantum dynamics. Internally, they compute the necessary isomorphisms to perform the dynamics in a real vector space. H_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsystem = QuantumSystem(H_drift, H_drives)\n\na_drives = [1, 0]\nsystem.H(a_drives) 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n 1.0+0.0im   1.0+0.0im\n 1.0+0.0im  -1.0+0.0im To extract the drift and drive Hamiltonians from a  QuantumSystem , use the  get_drift  and  get_drives  functions. get_drift(system) |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n 1.0+0.0im       ⋅    \n     ⋅      -1.0+0.0im Get the X drive. drives = get_drives(system)\ndrives[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      1.0+0.0im\n 1.0+0.0im      ⋅     And the Y drive. drives[2] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      0.0-1.0im\n 0.0+1.0im      ⋅     Note We can also construct a  QuantumSystem  directly from a Hamiltonian function. Internally,  ForwardDiff.jl  is used to compute the drives. H(a) = PAULIS[:Z] + a[1] * PAULIS[:X] + a[2] * PAULIS[:Y]\nsystem = QuantumSystem(H, 2)\nget_drives(system)[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      1.0+0.0im\n 1.0+0.0im      ⋅     Create a noise model with a confusion matrix. function H(a; C::Matrix{Float64}=[1.0 0.0; 0.0 1.0])\n    b = C * a\n    return b[1] * PAULIS.X + b[2] * PAULIS.Y\nend\n\nC_matrix = [0.99 0.01; -0.01 1.01]\nsystem = QuantumSystem(a -> H(a, C=C_matrix), 2; params=Dict(:C => C_matrix))\nconfused_drives = get_drives(system)\nconfused_drives[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n      ⋅       0.99+0.01im\n 0.99-0.01im       ⋅     confused_drives[2] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n      ⋅       0.01-1.01im\n 0.01+1.01im       ⋅    "},{"id":80,"pagetitle":"Quantum Systems","title":"Open quantum systems","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#Open-quantum-systems","content":" Open quantum systems We can also construct an  OpenQuantumSystem  with Lindblad dynamics, enabling a user to pass a list of dissipation operators."},{"id":81,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem  —  Type OpenQuantumSystem <: AbstractQuantumSystem A struct for storing open quantum dynamics and the appropriate gradients. Additional fields dissipation_operators::Vector{AbstractMatrix} : The dissipation operators. See also  QuantumSystem . Constructors OpenQuantumSystem(       H drift::AbstractMatrix{<:Number},       H drives::AbstractVector{<:AbstractMatrix{<:Number}}       dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}};       kwargs...   ) OpenQuantumSystem(       H drift::Matrix{<:Number}, H drives::AbstractVector{Matrix{<:Number}};       dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],       kwargs...   ) OpenQuantumSystem(H_drift::Matrix{<:Number}; kwargs...) OpenQuantumSystem(H_drives::Vector{Matrix{<:Number}}; kwargs...) OpenQuantumSystem(H::Function, n_drives::Int; kwargs...) source Add a dephasing and annihilation error channel. H_drives = [PAULIS[:X]]\na = annihilate(2)\ndissipation_operators = [a'a, a]\nsystem = OpenQuantumSystem(H_drives, dissipation_operators=dissipation_operators)\nsystem.dissipation_operators[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 1 stored entry:\n     ⋅          ⋅    \n     ⋅      1.0+0.0im system.dissipation_operators[2] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 1 stored entry:\n     ⋅      1.0+0.0im\n     ⋅          ⋅     Warning The Hamiltonian part  system.H  excludes the Lindblad operators. This is also true for functions that report properties of  system.H , such as  get_drift ,  get_drives , and  is_reachable . get_drift(system) |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 0 stored entries:\n     ⋅          ⋅    \n     ⋅          ⋅    "},{"id":82,"pagetitle":"Quantum Systems","title":"Composite quantum systems","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#Composite-quantum-systems","content":" Composite quantum systems A  CompositeQuantumSystem  is constructed from a list of subsystems and their interactions. The interaction, in the form of drift or drive Hamiltonian, acts on the full Hilbert space. The subsystems, with their own drift and drive Hamiltonians, are internally lifted to the full Hilbert space. system_1 = QuantumSystem([PAULIS[:X]])\nsystem_2 = QuantumSystem([PAULIS[:Y]])\nH_drift = PAULIS[:Z] ⊗ PAULIS[:Z]\nsystem = CompositeQuantumSystem(H_drift, [system_1, system_2]); The drift Hamiltonian is the ZZ coupling. get_drift(system) |> sparse 4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n 1.0+0.0im       ⋅           ⋅          ⋅    \n     ⋅      -1.0+0.0im       ⋅          ⋅    \n     ⋅           ⋅      -1.0+0.0im      ⋅    \n     ⋅           ⋅           ⋅      1.0+0.0im The drives are the X and Y operators on the first and second subsystems. drives = get_drives(system)\ndrives[1] |> sparse 4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n     ⋅          ⋅      1.0+0.0im      ⋅    \n     ⋅          ⋅          ⋅      1.0+0.0im\n 1.0+0.0im      ⋅          ⋅          ⋅    \n     ⋅      1.0+0.0im      ⋅          ⋅     drives[2] |> sparse 4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n     ⋅      0.0-1.0im      ⋅          ⋅    \n 0.0+1.0im      ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅      0.0-1.0im\n     ⋅          ⋅      0.0+1.0im      ⋅    "},{"id":83,"pagetitle":"Quantum Systems","title":"The lift function","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#The-lift-function","content":" The  lift  function To lift operators acting on a subsystem into the full Hilbert space, use  lift ."},{"id":84,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.CompositeQuantumSystems.lift","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#PiccoloQuantumObjects.CompositeQuantumSystems.lift-generated-quantum_systems","content":" PiccoloQuantumObjects.CompositeQuantumSystems.lift  —  Function lift(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...) Lift an  operator  acting on the  i -th subsystem within  subsystem_levels  to an operator acting on the entire system spanning  subsystem_levels . source Create an  a + a'  operator acting on the 1st subsystem of a qutrit and qubit system. subspace_levels = [3, 2]\nlift(create(3) + annihilate(3), 1, subspace_levels) .|> real |> sparse 6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n  ⋅    ⋅   1.0       ⋅        ⋅        ⋅ \n  ⋅    ⋅    ⋅       1.0       ⋅        ⋅ \n 1.0   ⋅    ⋅        ⋅       1.41421   ⋅ \n  ⋅   1.0   ⋅        ⋅        ⋅       1.41421\n  ⋅    ⋅   1.41421   ⋅        ⋅        ⋅ \n  ⋅    ⋅    ⋅       1.41421   ⋅        ⋅  Create IXI operator on the 2nd qubit in a 3-qubit system. lift(PAULIS[:X], 2, 3) .|> real |> sparse 8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n  ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ \n 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅  Create an XX operator acting on qubits 3 and 4 in a 4-qubit system. lift([PAULIS[:X], PAULIS[:X]], [3, 4], 4) .|> real |> sparse 16×16 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:\n⎡⡠⠊⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⡠⠊⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⡠⠊⠀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⡠⠊⎦ We can also lift an operator that entangles different subspaces by passing the indices of the entangled subsystems. #_Here's another way to create an XX operator acting on qubits 3 and 4 in a 4-qubit system._\nlift(kron(PAULIS[:X], PAULIS[:X]), [3, 4], 4) .|> real |> sparse 16×16 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:\n⎡⡠⠊⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⡠⠊⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⡠⠊⠀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⡠⠊⎦ Lift a CX gate acting on the 1st and 3rd qubits in a 3-qubit system. The result is independent of the state of the second qubit. lift(GATES[:CX], [1, 3], 3) .|> real |> sparse 8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅ "},{"id":85,"pagetitle":"Quantum Systems","title":"Reachability tests","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#Reachability-tests","content":" Reachability tests Whether a quantum system can be used to reach a target state or operator can be tested by computing the dynamical Lie algebra. Access to this calculation is provided by the  is_reachable  function."},{"id":86,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystemUtils.is_reachable  —  Function is_reachable(gate, hamiltonians; kwargs...) Check if the  gate  is reachable using the given  hamiltonians . Arguments gate::AbstractMatrix : target gate hamiltonians::AbstractVector{<:AbstractMatrix} : generators of the Lie algebra Keyword Arguments subspace::AbstractVector{<:Int}=1:size(gate, 1) : subspace indices compute_basis::Bool=true : compute the basis or use the Hamiltonians directly remove_trace::Bool=true : remove trace from generators verbose::Bool=true : print information about the operator algebra atol::Float32=eps(Float32) : absolute tolerance See also  QuantumSystemUtils.operator_algebra . source is_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...) Check if the  gate  is reachable using the given  system . Keyword Arguments use_drift::Bool=true : include drift Hamiltonian in the generators kwargs... : keyword arguments for  is_reachable source Y can be reached by commuting Z and X. system = QuantumSystem(PAULIS[:Z], [PAULIS[:X]])\nis_reachable(PAULIS[:Y], system) true Y cannot be reached by X alone. system = QuantumSystem([PAULIS[:X]])\nis_reachable(PAULIS[:Y], system) false"},{"id":87,"pagetitle":"Quantum Systems","title":"Direct sums","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#Direct-sums","content":" Direct sums The direct sum of two quantum systems is constructed with the  direct_sum  function."},{"id":88,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.DirectSums.direct_sum","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#PiccoloQuantumObjects.DirectSums.direct_sum-generated-quantum_systems","content":" PiccoloQuantumObjects.DirectSums.direct_sum  —  Function direct_sum(A::AbstractMatrix, B::AbstractMatrix) Returns the direct sum of two matrices. source direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC) Returns the direct sum of two sparse matrices. source direct_sum(Ã⃗::AbstractVector, B̃⃗::AbstractVector) Returns the direct sum of two iso_vec operators. source direct_sum(sys1::QuantumSystem, sys2::QuantumSystem) Returns the direct sum of two  QuantumSystem  objects. source Create a pair of non-interacting qubits. system_1 = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]])\nsystem_2 = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]])\nsystem = direct_sum(system_1, system_2)\nget_drift(system) |> sparse 4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n 1.0+0.0im       ⋅          ⋅           ⋅    \n     ⋅      -1.0+0.0im      ⋅           ⋅    \n     ⋅           ⋅      1.0+0.0im       ⋅    \n     ⋅           ⋅          ⋅      -1.0+0.0im This page was generated using  Literate.jl ."},{"id":91,"pagetitle":"Rollouts","title":"Rollouts and fidelity","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#Rollouts-and-fidelity","content":" Rollouts and fidelity using PiccoloQuantumObjects\nusing NamedTrajectories\nusing SparseArrays # for visualization\nusing LinearAlgebra Rollouts are simulations of a quantum system. In a rollout, controls are integrated forward in time using the dynamics implied by a provided quantum systems. The defualt is to use zero-order hold integration to simulate the evolution–-that is, the controls are held constant between time steps. For quantum states, the Schrödinger equation is used: \\[\\psi(t + \\Delta t) = \\exp\\left(-i H(\\mathbf{a}(t)) \\Delta t\\right) \\psi(t)\\] The visited states are collected into a matrix of size  (2n, T) , for the isomorphic Hilbert space dimension  2n  and timesteps  T . Note All of the returned rollout are assumed to be real valued. It is helpful to use the appropriate isomorphisms to convert between real and complex quantum objects, and  eachcol  to iterate over the rollout columns. There are rollouts for each kind of quantum object:  quantum states ,  unitary operators , and  density operators . A fidelity function is also provided for each kind of quantum objectand a rollout fidelity function compares the final state of a rollout to a goal state."},{"id":92,"pagetitle":"Rollouts","title":"Fidelity functions","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#Fidelity-functions","content":" Fidelity functions The fidelity functions are used to measure how close two quantum states or operators are to each other. fidelity  calculates the fidelity between two quantum states. unitary_fidelity  calculates the fidelity between two unitary operators. State fidelity . ψ = GATES.X * [1.0, 0.0]\nψ_goal = [0.0, 1.0]\nfidelity(ψ, ψ_goal) 1.0 Unitary fidelity of orthogonal operations. U = GATES.Y\nU_goal = GATES.X\nunitary_fidelity(U, U_goal) 0.0"},{"id":93,"pagetitle":"Rollouts","title":"Quantum State Rollouts","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#Quantum-State-Rollouts","content":" Quantum State Rollouts The  rollout  function simulates the evolution of a real valued quantum state under given controls and quantum system."},{"id":94,"pagetitle":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.rollout","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#PiccoloQuantumObjects.Rollouts.rollout-generated-rollouts","content":" PiccoloQuantumObjects.Rollouts.rollout  —  Function rollout(\n    ψ̃_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout(\n    ψ_init::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout(\n    inits::AbstractVector{<:AbstractVector},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n) Rollout a quantum state  ψ̃_init  under the control  controls  for a time  Δt  using the system  system . If  exp_vector_product  is  true , the integrator is expected to have a signature like the exponential action,  expv . Otherwise, it is expected to have a signature like  exp . Types should allow for autodifferentiable controls and times. source"},{"id":95,"pagetitle":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.rollout_fidelity","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#PiccoloQuantumObjects.Rollouts.rollout_fidelity-generated-rollouts","content":" PiccoloQuantumObjects.Rollouts.rollout_fidelity  —  Function rollout_fidelity(\n    ψ̃_init::AbstractVector{<:Real},\n    ψ̃_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout_fidelity(\n    ψ_init::AbstractVector{<:Complex},\n    ψ_goal::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout_fidelity(\n    trajectory::NamedTrajectory,\n    system::AbstractQuantumSystem\n) Calculate the fidelity between the final state of a rollout and a goal state. source The rollout is a matrix of size  (2n, T) . T = 10\nψ_init = ComplexF64[1.0, 0.0]\ncontrols = rand(2, T)\nΔt = fill(0.1, T)\nsystem = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]])\nψ̃_rollout = rollout(ψ_init, controls, Δt, system)\nψ̃_rollout |> size (4, 10)"},{"id":96,"pagetitle":"Rollouts","title":"Quantum State Rollout Fidelity","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#Quantum-State-Rollout-Fidelity","content":" Quantum State Rollout Fidelity States must be cast to complex for the rollout to know the difference between real and isomorphic states. ψ_goal = ComplexF64[0.0, 1.0]\nrollout_fidelity(ψ_init, ψ_goal, controls, Δt, system) 0.35853397781331753 Warning Don't forget to convert the quantum state to the appropriate isomorphism before calculating the fidelity. fidelity(iso_to_ket(ψ̃_rollout[:, end]), ψ_goal) 0.35853397781331753 The initial state and goal are often inferred from the properly configured trajectory of a control problem. components = (ψ̃ = zeros(Float64, size(ψ̃_rollout)), a = controls, Δt = Δt)\ntraj = NamedTrajectory(\n    components;\n    timestep=:Δt,\n    controls=:a,\n    initial=(ψ̃ = ket_to_iso(ψ_init),),\n    goal=(ψ̃ = ket_to_iso(ψ_goal),),\n)\nrollout_fidelity(traj, system) 0.35853397781331753 Note The rollout fidelity is not the same thing as the fidelity of the final trajectory state. fidelity(iso_to_ket(traj.ψ̃[:, end]), ψ_goal) 0.0"},{"id":97,"pagetitle":"Rollouts","title":"Unitary Rollouts","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#Unitary-Rollouts","content":" Unitary Rollouts"},{"id":98,"pagetitle":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.unitary_rollout","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#PiccoloQuantumObjects.Rollouts.unitary_rollout-generated-rollouts","content":" PiccoloQuantumObjects.Rollouts.unitary_rollout  —  Function unitary_rollout(\n    Ũ⃗_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n) Rollout a isomorphic unitary operator  Ũ⃗_init  under the control  controls  for a time  Δt  using the system  system . Arguments Ũ⃗_init::AbstractVector{<:Real} : Initial unitary vector controls::AbstractMatrix{<:Real} : Control matrix Δt::AbstractVector : Time steps system::AbstractQuantumSystem : Quantum system Keyword Arguments show_progress::Bool=false : Show progress bar integrator::Function=expv : Integrator function exp_vector_product::Bool : Infer whether the integrator is an exponential-vector product source"},{"id":99,"pagetitle":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity-generated-rollouts","content":" PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity  —  Function unitary_rollout_fidelity(\n    Ũ⃗_init::AbstractVector{<:Real},\n    Ũ⃗_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    Ũ⃗_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_init::AbstractMatrix{<:Complex},\n    U_goal::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_goal::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_goal::EmbeddedOperator,\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    subspace::AbstractVector{Int}=U_goal.subspace,\n    kwargs...\n)\nunitary_rollout_fidelity(\n    traj::NamedTrajectory,\n    sys::AbstractQuantumSystem;\n    kwargs...\n) Calculate the fidelity between the final state of a unitary rollout and a goal state.  If the initial unitary is not provided, the identity operator is assumed. If  phases  and  phase_operators  are provided, the free phase unitary fidelity is calculated. source Ũ⃗_rollout = unitary_rollout(controls, Δt, system)\nŨ⃗_rollout |> size (8, 10) Convert to unitary operators, and have a look at the initial unitary. iso_vec_to_operator.(eachcol(Ũ⃗_rollout[:, 1])) |> first 2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im"},{"id":100,"pagetitle":"Rollouts","title":"Open Quantum System Rollouts","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#Open-Quantum-System-Rollouts","content":" Open Quantum System Rollouts"},{"id":101,"pagetitle":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.open_rollout","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#PiccoloQuantumObjects.Rollouts.open_rollout-generated-rollouts","content":" PiccoloQuantumObjects.Rollouts.open_rollout  —  Function open_rollout(\n    ρ⃗₁::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::OpenQuantumSystem;\n    kwargs...\n) Rollout a quantum state  ρ⃗₁  under the control  controls  for a time  Δt Arguments ρ⃗₁::AbstractVector{<:Complex} : Initial state vector controls::AbstractMatrix{<:Real} : Control matrix Δt::AbstractVector : Time steps system::OpenQuantumSystem : Quantum system Keyword Arguments show_progress::Bool=false : Show progress bar integrator::Function=expv : Integrator function exp_vector_product::Bool : Infer whether the integrator is an exponential-vector product source"},{"id":102,"pagetitle":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.open_rollout_fidelity","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#PiccoloQuantumObjects.Rollouts.open_rollout_fidelity-generated-rollouts","content":" PiccoloQuantumObjects.Rollouts.open_rollout_fidelity  —  Function open_rollout_fidelity(\n    ρ⃗₁::AbstractVector{<:Complex},\n    ρ⃗₂::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::OpenQuantumSystem\n)\nopen_rollout_fidelity(\n    ρ₁::AbstractMatrix{<:Complex},\n    ρ₂::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::OpenQuantumSystem\n)\nopen_rollout_fidelity(\n    traj::NamedTrajectory,\n    system::OpenQuantumSystem;\n    state_name::Symbol=:ρ⃗̃,\n    control_name::Symbol=:a,\n    kwargs...\n) Calculate the fidelity between the final state of an open quantum system rollout and a goal state. source Open rollouts require open quantum systems . open_system = OpenQuantumSystem(system)\n\nρ_init = ψ_init * ψ_init'\nρ̃⃗_rollout = open_rollout(ρ_init, controls, Δt, open_system)\nρ̃⃗_rollout |> size (8, 10) This page was generated using  Literate.jl ."},{"id":105,"pagetitle":"Library","title":"Quantum Systems","ref":"/PiccoloQuantumObjects/dev/lib/#Quantum-Systems","content":" Quantum Systems"},{"id":106,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem  —  Type AbstractQuantumSystem Abstract type for defining systems. source"},{"id":107,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem  —  Type OpenQuantumSystem <: AbstractQuantumSystem A struct for storing open quantum dynamics and the appropriate gradients. Additional fields dissipation_operators::Vector{AbstractMatrix} : The dissipation operators. See also  QuantumSystem . Constructors OpenQuantumSystem(       H drift::AbstractMatrix{<:Number},       H drives::AbstractVector{<:AbstractMatrix{<:Number}}       dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}};       kwargs...   ) OpenQuantumSystem(       H drift::Matrix{<:Number}, H drives::AbstractVector{Matrix{<:Number}};       dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],       kwargs...   ) OpenQuantumSystem(H_drift::Matrix{<:Number}; kwargs...) OpenQuantumSystem(H_drives::Vector{Matrix{<:Number}}; kwargs...) OpenQuantumSystem(H::Function, n_drives::Int; kwargs...) source"},{"id":108,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.QuantumSystem  —  Type QuantumSystem <: AbstractQuantumSystem A struct for storing quantum dynamics and the appropriate gradients. Fields H::Function : The Hamiltonian function, excluding dissipation: a -> H(a). G::Function : The isomorphic generator function, including dissipation, a -> G(a). ∂G::Function : The generator jacobian function, a -> ∂G(a). levels::Int : The number of levels in the system. n_drives::Int : The number of drives in the system. Constructors QuantumSystem(H drift::AbstractMatrix{<:Number}, H drives::Vector{<:AbstractMatrix{<:Number}}; kwargs...) QuantumSystem(H_drift::AbstractMatrix{<:Number}; kwargs...) QuantumSystem(H_drives::Vector{<:AbstractMatrix{<:Number}}; kwargs...) QuantumSystem(H::Function, n_drives::Int; kwargs...) source"},{"id":109,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.get_drift","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystems.get_drift-Tuple{AbstractQuantumSystem}","content":" PiccoloQuantumObjects.QuantumSystems.get_drift  —  Method get_drift(sys::AbstractQuantumSystem) Returns the drift Hamiltonian of the system. source"},{"id":110,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.get_drives","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystems.get_drives-Tuple{AbstractQuantumSystem}","content":" PiccoloQuantumObjects.QuantumSystems.get_drives  —  Method get_drives(sys::AbstractQuantumSystem) Returns the drive Hamiltonians of the system. source"},{"id":111,"pagetitle":"Library","title":"Composite Quantum Systems","ref":"/PiccoloQuantumObjects/dev/lib/#Composite-Quantum-Systems","content":" Composite Quantum Systems"},{"id":112,"pagetitle":"Library","title":"PiccoloQuantumObjects.CompositeQuantumSystems.CompositeQuantumSystem","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.CompositeQuantumSystems.CompositeQuantumSystem","content":" PiccoloQuantumObjects.CompositeQuantumSystems.CompositeQuantumSystem  —  Type CompositeQuantumSystem <: AbstractQuantumSystem A composite quantum system consisting of  subsystems . Couplings between subsystems can be additionally defined. Subsystem drives are always appended to any new coupling drives. source"},{"id":113,"pagetitle":"Library","title":"PiccoloQuantumObjects.CompositeQuantumSystems.lift","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.CompositeQuantumSystems.lift","content":" PiccoloQuantumObjects.CompositeQuantumSystems.lift  —  Function lift(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...) Lift an  operator  acting on the  i -th subsystem within  subsystem_levels  to an operator acting on the entire system spanning  subsystem_levels . source"},{"id":114,"pagetitle":"Library","title":"Gates","ref":"/PiccoloQuantumObjects/dev/lib/#Gates","content":" Gates"},{"id":115,"pagetitle":"Library","title":"PiccoloQuantumObjects.Gates.GATES","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Gates.GATES","content":" PiccoloQuantumObjects.Gates.GATES  —  Constant A constant dictionary  GATES  containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix. GATES[:I]  - Identity: Leaves the state unchanged. GATES[:X]  - Pauli-X (NOT): Flips the qubit state. GATES[:Y]  - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere. GATES[:Z]  - Pauli-Z: Flips the phase of the qubit state. GATES[:H]  - Hadamard: Creates superposition by transforming basis states. GATES[:CX]  - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1⟩. GATES[:CZ]  - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1⟩. GATES[:XI]  - Complex: A gate for complex operations. GATES[:sqrtiSWAP]  - Square root of iSWAP: Partially swaps two qubits with a phase. source"},{"id":116,"pagetitle":"Library","title":"PiccoloQuantumObjects.Gates.PAULIS","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Gates.PAULIS","content":" PiccoloQuantumObjects.Gates.PAULIS  —  Constant The 2×2 Pauli matrics and identity. source"},{"id":117,"pagetitle":"Library","title":"Embedded Operators","ref":"/PiccoloQuantumObjects/dev/lib/#Embedded-Operators","content":" Embedded Operators"},{"id":118,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator","content":" PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator  —  Type AbstractPiccoloOperator Union type for operators. source"},{"id":119,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Type EmbeddedOperator Embedded operator type to represent an operator embedded in a subspace of a larger quantum system. Fields operator::Matrix{ComplexF64} : Embedded operator of size    prod(subsystem_levels) x prod(subsystem_levels) . subspace::Vector{Int} : Indices of the subspace the operator is embedded in. subsystem_levels::Vector{Int} : Levels of the subsystems in the composite system. source"},{"id":120,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n) Embed the  subspace_operator  into the provided  subspaces  of a composite system, where the  subsystem_indices  list the subspaces at which the operator is defined, and the  subsystem_levels  list the levels of the subsystems in which the operator is embedded. source"},{"id":121,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, CompositeQuantumSystem}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    composite_system::CompositeQuantumSystem\n) Embed the  subspace_operator  into the provided  subspaces  of a composite system. source"},{"id":122,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int}) Create an embedded operator. The  operator  is embedded at the  subspace  of the system spanned by the  subsystem_levels . source"},{"id":123,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, QuantumSystem}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(subspace_operator::AbstractMatrix{<:Number}, system::QuantumSystem; kwargs...) Embed the  subspace_operator  into a quantum  system . source"},{"id":124,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.embed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","content":" PiccoloQuantumObjects.EmbeddedOperators.embed  —  Method embed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator) Embed the  subspace_operator  in the subspace of a larger  embedded_operator . source"},{"id":125,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.embed-Union{Tuple{R}, Tuple{AbstractMatrix{R}, AbstractVector{Int64}, Int64}} where R<:Number","content":" PiccoloQuantumObjects.EmbeddedOperators.embed  —  Method embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int) Embed an  operator  in the  subspace  of a larger matrix of size  levels x levels . source"},{"id":126,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices-Tuple{Int64, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices  —  Method get_enr_subspace_indices(excitation_restriction::Int, subsystem_levels::AbstractVector{Int}) Get the indices for the subspace of the quantum system with an excitation restriction. source"},{"id":127,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices  —  Function get_iso_vec_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_iso_vec_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_iso_vec_leakage_indices(op::EmbeddedOperator) Get the indices for the leakage in the isomorphic vector space for operators. source"},{"id":128,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices  —  Function get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator) Get the indices for the subspace in the isomorphic vector space for operators. source"},{"id":129,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices  —  Function get_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_leakage_indices(op::EmbeddedOperator) Get the indices for the states that are outside of the provided subspace of the quantum system. source"},{"id":130,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices  —  Function get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)\nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator) Get the indices for the provided subspace of the quantum system. source"},{"id":131,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Method unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}) Unembed a subspace operator from the  matrix . This is equivalent to calling  matrix[subspace, subspace] . source"},{"id":132,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Method unembed(op::AbstractMatrix, embedded_op::EmbeddedOperator) Unembed a sub-matrix from the  op  at the subspace defined by  embedded_op . source"},{"id":133,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{EmbeddedOperator}","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Method unembed(embedded_op::EmbeddedOperator)::Matrix{ComplexF64} Unembed an embedded operator, returning the original operator. source"},{"id":134,"pagetitle":"Library","title":"Isomorphisims","ref":"/PiccoloQuantumObjects/dev/lib/#Isomorphisims","content":" Isomorphisims"},{"id":135,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.G","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.G-Tuple{AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.G  —  Method G(H::AbstractMatrix)::Matrix{Float64} Returns the isomorphism of  $-iH$ , i.e.  $G(H) = \\text{iso}(-iH)$ . See also  Isomorphisms.iso ,  Isomorphisms.H . source"},{"id":136,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.H","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.H-Tuple{AbstractMatrix{<:Real}}","content":" PiccoloQuantumObjects.Isomorphisms.H  —  Method H(G::AbstractMatrix{<:Real}) Returns the inverse of  $G(H) = iso(-iH)$ , i.e. returns H. See also  Isomorphisms.iso ,  Isomorphisms.G . source"},{"id":137,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ad_vec","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.ad_vec-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","content":" PiccoloQuantumObjects.Isomorphisms.ad_vec  —  Method ad_vec(H::AbstractMatrix{ℂ}; anti::Bool=false) where ℂ <: Number Returns the vectorized adjoint action of a matrix  H : \\[\\text{ad_vec}(H) = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes H - (-1)^{\\text{anti}} \\mqty(0 & 1 \\\\ 1 & 0) \\otimes H^*\\] source"},{"id":138,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec-Tuple{AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec  —  Method density_to_iso_vec(ρ::AbstractMatrix{<:Number}) Returns the isomorphism  ρ⃗̃ = ket_to_iso(vec(ρ))  of a density matrix  ρ source"},{"id":139,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso-Tuple{AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.iso  —  Method iso(H::AbstractMatrix{<:Number}) Returns the isomorphism of  $H$ : \\[iso(H) = \\widetilde{H} = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] where  $\\Im(H)$  and  $\\Re(H)$  are the imaginary and real parts of  $H$  and the tilde  indicates the standard isomorphism of a complex valued matrix: \\[\\widetilde{H} = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] See also  Isomorphisms.G ,  Isomorphisms.H . source"},{"id":140,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_D","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso_D-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","content":" PiccoloQuantumObjects.Isomorphisms.iso_D  —  Method iso_D(L::AbstractMatrix{ℂ}) where ℂ <: Number Returns the isomorphic representation of the Lindblad dissipator  L . source"},{"id":141,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec-Union{Tuple{AbstractMatrix{ℝ}}, Tuple{ℝ}} where ℝ<:Real","content":" PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec  —  Method iso_operator_to_iso_vec(Ũ::AbstractMatrix{ℝ}) where ℝ <: Real Convert a real matrix  Ũ  representing an isomorphism operator into a real vector. source"},{"id":142,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator-Tuple{Any}","content":" PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator  —  Method iso_operator_to_operator(Ũ) source"},{"id":143,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_to_ket","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso_to_ket-Tuple{AbstractVector{<:Real}}","content":" PiccoloQuantumObjects.Isomorphisms.iso_to_ket  —  Method iso_to_ket(ψ̃::AbstractVector{<:Real}) Convert a real isomorphism vector  ψ̃  into a ket vector. source"},{"id":144,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density-Tuple{AbstractVector{<:Real}}","content":" PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density  —  Method iso_vec_to_density(ρ⃗̃::AbstractVector{<:Real}) Returns the density matrix  ρ  from its isomorphism  ρ⃗̃ source"},{"id":145,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator-Union{Tuple{AbstractVector{ℝ}}, Tuple{ℝ}} where ℝ<:Real","content":" PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator  —  Method iso_vec_to_iso_operator(Ũ⃗::AbstractVector{ℝ}) where ℝ <: Real Convert a real vector  Ũ⃗  into a real matrix representing an isomorphism operator. source"},{"id":146,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator-Union{Tuple{AbstractVector{ℝ}}, Tuple{ℝ}} where ℝ<:Real","content":" PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator  —  Method iso_vec_to_operator(Ũ⃗::AbstractVector{ℝ}) where ℝ <: Real Convert a real vector  Ũ⃗  into a complex matrix representing an operator. source"},{"id":147,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ket_to_iso","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.ket_to_iso-Tuple{AbstractVector{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.ket_to_iso  —  Method ket_to_iso(ψ::AbstractVector{<:Number}) Convert a ket vector  ψ  into a complex vector with real and imaginary parts. source"},{"id":148,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.mat","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.mat-Tuple{AbstractVector}","content":" PiccoloQuantumObjects.Isomorphisms.mat  —  Method mat(x::AbstractVector) Convert a vector  x  into a square matrix. The length of  x  must be a perfect square. source"},{"id":149,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator-Tuple{Any}","content":" PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator  —  Method operator_to_iso_operator(U) source"},{"id":150,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","content":" PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec  —  Method operator_to_iso_vec(U::AbstractMatrix{ℂ}) where ℂ <: Number Convert a complex matrix  U  representing an operator into a real vector. source"},{"id":151,"pagetitle":"Library","title":"Quantum Object Utilities","ref":"/PiccoloQuantumObjects/dev/lib/#Quantum-Object-Utilities","content":" Quantum Object Utilities"},{"id":152,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.annihilate","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumObjectUtils.annihilate-Tuple{Int64}","content":" PiccoloQuantumObjects.QuantumObjectUtils.annihilate  —  Method annihilate(levels::Int) Get the annihilation operator for a system with  levels . source"},{"id":153,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.create","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumObjectUtils.create-Tuple{Int64}","content":" PiccoloQuantumObjects.QuantumObjectUtils.create  —  Method create(levels::Int) Get the creation operator for a system with  levels . source"},{"id":154,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.haar_identity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumObjectUtils.haar_identity-Tuple{Int64, Number}","content":" PiccoloQuantumObjects.QuantumObjectUtils.haar_identity  —  Method haar_identity(n::Int, radius::Number) Generate a random unitary matrix close to the identity matrix using the Haar measure for an  n -dimensional system with a given  radius . The smaller the radius, the closer the matrix will be to the identity. source"},{"id":155,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.haar_random","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumObjectUtils.haar_random-Tuple{Int64}","content":" PiccoloQuantumObjects.QuantumObjectUtils.haar_random  —  Method haar_random(n::Int) Generate a random unitary matrix using the Haar measure for an  n -dimensional system. source"},{"id":156,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring-Tuple{String}","content":" PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring  —  Method ket_from_bitstring(ket::String) Get the state vector for a qubit system given a ket string  ket  of 0s and 1s. source"},{"id":157,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string-Tuple{String, Vector{Int64}}","content":" PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string  —  Method ket_from_string(\n    ket::String,\n    levels::Vector{Int};\n    level_dict=Dict(:g => 0, :e => 1, :f => 2, :h => 3, :i => 4, :j => 5, :k => 6, :l => 7),\n    return_states=false\n) Construct a quantum state from a string ket representation. source"},{"id":158,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string-Tuple{String}","content":" PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string  —  Method operator_from_string(operator::String; lookup=PAULIS) Reduce the string (each character is one key) via operators from a dictionary. source"},{"id":159,"pagetitle":"Library","title":"Quantum System Utilities","ref":"/PiccoloQuantumObjects/dev/lib/#Quantum-System-Utilities","content":" Quantum System Utilities"},{"id":160,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractQuantumSystem}","content":" PiccoloQuantumObjects.QuantumSystemUtils.is_reachable  —  Method is_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...) Check if the  gate  is reachable using the given  system . Keyword Arguments use_drift::Bool=true : include drift Hamiltonian in the generators kwargs... : keyword arguments for  is_reachable source"},{"id":161,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}}","content":" PiccoloQuantumObjects.QuantumSystemUtils.is_reachable  —  Method is_reachable(gate, hamiltonians; kwargs...) Check if the  gate  is reachable using the given  hamiltonians . Arguments gate::AbstractMatrix : target gate hamiltonians::AbstractVector{<:AbstractMatrix} : generators of the Lie algebra Keyword Arguments subspace::AbstractVector{<:Int}=1:size(gate, 1) : subspace indices compute_basis::Bool=true : compute the basis or use the Hamiltonians directly remove_trace::Bool=true : remove trace from generators verbose::Bool=true : print information about the operator algebra atol::Float32=eps(Float32) : absolute tolerance See also  QuantumSystemUtils.operator_algebra . source"},{"id":162,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra-Union{Tuple{Vector{<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","content":" PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra  —  Method operator_algebra(generators; kwargs...) Compute the Lie algebra basis for the given  generators . Arguments generators::Vector{<:AbstractMatrix} : generators of the Lie algebra Keyword Arguments return_layers::Bool=false : return the Lie tree layers normalize::Bool=false : normalize the basis verbose::Bool=false : print information remove_trace::Bool=true : remove trace from generators source"},{"id":163,"pagetitle":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}","content":" PiccoloQuantumObjects.DirectSums.direct_sum  —  Method direct_sum(A::AbstractMatrix, B::AbstractMatrix) Returns the direct sum of two matrices. source"},{"id":164,"pagetitle":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}","content":" PiccoloQuantumObjects.DirectSums.direct_sum  —  Method direct_sum(Ã⃗::AbstractVector, B̃⃗::AbstractVector) Returns the direct sum of two iso_vec operators. source"},{"id":165,"pagetitle":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}","content":" PiccoloQuantumObjects.DirectSums.direct_sum  —  Method direct_sum(sys1::QuantumSystem, sys2::QuantumSystem) Returns the direct sum of two  QuantumSystem  objects. source"},{"id":166,"pagetitle":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}","content":" PiccoloQuantumObjects.DirectSums.direct_sum  —  Method direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC) Returns the direct sum of two sparse matrices. source"},{"id":167,"pagetitle":"Library","title":"Rollouts","ref":"/PiccoloQuantumObjects/dev/lib/#Rollouts","content":" Rollouts"},{"id":168,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.fidelity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.fidelity-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Rollouts.fidelity  —  Method fidelity(ρ::AbstractMatrix{<:Number}, ρ_goal::AbstractMatrix{<:Number}) Calculate the fidelity between two density matrices  ρ  and  ρ_goal . source"},{"id":169,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.fidelity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.fidelity-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","content":" PiccoloQuantumObjects.Rollouts.fidelity  —  Method fidelity(ψ::AbstractVector{<:Number}, ψ_goal::AbstractVector{<:Number}) Calculate the fidelity between two quantum states  ψ  and  ψ_goal . source"},{"id":170,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.free_phase","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.free_phase-Union{Tuple{ℂ}, Tuple{AbstractVector{<:Real}, AbstractVector{<:AbstractMatrix{<:ℂ}}}} where ℂ<:Number","content":" PiccoloQuantumObjects.Rollouts.free_phase  —  Method free_phase(phases::AbstractVector{<:Real}, phase_operators::AbstractVector{<:AbstractMatrix{<:ℂ}}) Rotate the  phase_operators  by the  phases  and return the Kronecker product. source"},{"id":171,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.infer_is_evp","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.infer_is_evp-Tuple{Function}","content":" PiccoloQuantumObjects.Rollouts.infer_is_evp  —  Method infer_is_evp(integrator::Function) Infer whether the integrator is a exponential-vector product (EVP) function. If  true , the integrator is expected to have a signature like the exponential action,  expv . Otherwise, it is expected to have a signature like  exp . source"},{"id":172,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.open_rollout","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.open_rollout","content":" PiccoloQuantumObjects.Rollouts.open_rollout  —  Function open_rollout(\n    ρ⃗₁::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::OpenQuantumSystem;\n    kwargs...\n) Rollout a quantum state  ρ⃗₁  under the control  controls  for a time  Δt Arguments ρ⃗₁::AbstractVector{<:Complex} : Initial state vector controls::AbstractMatrix{<:Real} : Control matrix Δt::AbstractVector : Time steps system::OpenQuantumSystem : Quantum system Keyword Arguments show_progress::Bool=false : Show progress bar integrator::Function=expv : Integrator function exp_vector_product::Bool : Infer whether the integrator is an exponential-vector product source"},{"id":173,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.open_rollout","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.open_rollout-Tuple{AbstractMatrix{<:Complex}, AbstractMatrix{<:Real}, AbstractVector, OpenQuantumSystem}","content":" PiccoloQuantumObjects.Rollouts.open_rollout  —  Method open_rollout(\n    ρ₁::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::OpenQuantumSystem;\n    kwargs...\n) Rollout a density matrix  ρ₁  under the control  controls  and timesteps  Δt source"},{"id":174,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.open_rollout_fidelity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.open_rollout_fidelity","content":" PiccoloQuantumObjects.Rollouts.open_rollout_fidelity  —  Function open_rollout_fidelity(\n    ρ⃗₁::AbstractVector{<:Complex},\n    ρ⃗₂::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::OpenQuantumSystem\n)\nopen_rollout_fidelity(\n    ρ₁::AbstractMatrix{<:Complex},\n    ρ₂::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::OpenQuantumSystem\n)\nopen_rollout_fidelity(\n    traj::NamedTrajectory,\n    system::OpenQuantumSystem;\n    state_name::Symbol=:ρ⃗̃,\n    control_name::Symbol=:a,\n    kwargs...\n) Calculate the fidelity between the final state of an open quantum system rollout and a goal state. source"},{"id":175,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.rollout","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.rollout","content":" PiccoloQuantumObjects.Rollouts.rollout  —  Function rollout(\n    ψ̃_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout(\n    ψ_init::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout(\n    inits::AbstractVector{<:AbstractVector},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n) Rollout a quantum state  ψ̃_init  under the control  controls  for a time  Δt  using the system  system . If  exp_vector_product  is  true , the integrator is expected to have a signature like the exponential action,  expv . Otherwise, it is expected to have a signature like  exp . Types should allow for autodifferentiable controls and times. source"},{"id":176,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.rollout_fidelity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.rollout_fidelity","content":" PiccoloQuantumObjects.Rollouts.rollout_fidelity  —  Function rollout_fidelity(\n    ψ̃_init::AbstractVector{<:Real},\n    ψ̃_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout_fidelity(\n    ψ_init::AbstractVector{<:Complex},\n    ψ_goal::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout_fidelity(\n    trajectory::NamedTrajectory,\n    system::AbstractQuantumSystem\n) Calculate the fidelity between the final state of a rollout and a goal state. source"},{"id":177,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.unitary_fidelity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.unitary_fidelity-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Rollouts.unitary_fidelity  —  Method unitary_fidelity(U::AbstractMatrix{<:Number}, U_goal::AbstractMatrix{<:Number}) Calculate the fidelity between unitary operators  U  and  U_goal  in the  subspace . source"},{"id":178,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.unitary_free_phase_fidelity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.unitary_free_phase_fidelity-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector{<:Real}, AbstractVector{<:AbstractMatrix}}","content":" PiccoloQuantumObjects.Rollouts.unitary_free_phase_fidelity  —  Method unitary_free_phase_fidelity(\n    U::AbstractMatrix,\n    U_goal::AbstractMatrix,\n    phases::AbstractVector{<:Real},\n    phase_operators::AbstractVector{<:AbstractMatrix};\n    subspace::AbstractVector{Int}=axes(U, 1)\n) Calculate the fidelity between unitary operators  U  and  U_goal  in the  subspace , including the  phase  rotations about the  phase_operators . source"},{"id":179,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.unitary_rollout","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.unitary_rollout","content":" PiccoloQuantumObjects.Rollouts.unitary_rollout  —  Function unitary_rollout(\n    Ũ⃗_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n) Rollout a isomorphic unitary operator  Ũ⃗_init  under the control  controls  for a time  Δt  using the system  system . Arguments Ũ⃗_init::AbstractVector{<:Real} : Initial unitary vector controls::AbstractMatrix{<:Real} : Control matrix Δt::AbstractVector : Time steps system::AbstractQuantumSystem : Quantum system Keyword Arguments show_progress::Bool=false : Show progress bar integrator::Function=expv : Integrator function exp_vector_product::Bool : Infer whether the integrator is an exponential-vector product source"},{"id":180,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity","content":" PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity  —  Function unitary_rollout_fidelity(\n    Ũ⃗_init::AbstractVector{<:Real},\n    Ũ⃗_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    Ũ⃗_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_init::AbstractMatrix{<:Complex},\n    U_goal::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_goal::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_goal::EmbeddedOperator,\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    subspace::AbstractVector{Int}=U_goal.subspace,\n    kwargs...\n)\nunitary_rollout_fidelity(\n    traj::NamedTrajectory,\n    sys::AbstractQuantumSystem;\n    kwargs...\n) Calculate the fidelity between the final state of a unitary rollout and a goal state.  If the initial unitary is not provided, the identity operator is assumed. If  phases  and  phase_operators  are provided, the free phase unitary fidelity is calculated. source"},{"id":183,"pagetitle":"Home","title":"QuantumCollocation.jl","ref":"/QuantumCollocation/dev/#QuantumCollocation.jl","content":" QuantumCollocation.jl QuantumCollocation.jl  sets up and solves  quantum control problems  as nonlinear programs (NLPs). In this context, a generic quantum control problem looks like \\[\\begin{aligned}\n    \\arg \\min_{\\mathbf{Z}}\\quad & J(\\mathbf{Z}) \\\\\n    \\nonumber \\text{s.t.}\\qquad & \\mathbf{f}(\\mathbf{Z}) = 0 \\\\\n    \\nonumber & \\mathbf{g}(\\mathbf{Z}) \\le 0  \n\\end{aligned}\\] where  $\\mathbf{Z}$  is a trajectory  containing states and controls, from  NamedTrajectories.jl ."},{"id":184,"pagetitle":"Home","title":"Problem Templates","ref":"/QuantumCollocation/dev/#Problem-Templates","content":" Problem Templates Problem Templates  are reusable design patterns for setting up and solving common quantum control problems.  For example, a  UnitarySmoothPulseProblem  is tasked with generating a  pulse  sequence  $a_{1:T-1}$  in orderd to minimize infidelity, subject to constraints from the Schroedinger equation, \\[    \\begin{aligned}\n        \\arg \\min_{\\mathbf{Z}}\\quad & |1 - \\mathcal{F}(U_T, U_\\text{goal})|  \\\\\n        \\nonumber \\text{s.t.}\n        \\qquad & U_{t+1} = \\exp\\{- i H(a_t) \\Delta t_t \\} U_t, \\quad \\forall\\, t \\\\\n    \\end{aligned}\\] while a  UnitaryMinimumTimeProblem  minimizes time and constrains fidelity, \\[    \\begin{aligned}\n        \\arg \\min_{\\mathbf{Z}}\\quad & \\sum_{t=1}^T \\Delta t_t \\\\\n        \\qquad & U_{t+1} = \\exp\\{- i H(a_t) \\Delta t_t \\} U_t, \\quad \\forall\\, t \\\\\n        \\nonumber & \\mathcal{F}(U_T, U_\\text{goal}) \\ge 0.9999\n    \\end{aligned}\\] In each case, the dynamics between  knot points $(U_t, a_t)$  and  $(U_{t+1}, a_{t+1})$  are enforced as constraints on the states, which are free variables in the solver; this optimization framework is called  direct collocation . For details of our implementation please see our award-winning IEEE QCE 2023 paper,  Direct Collocation for Quantum Optimal Control . If you use QuantumCollocation.jl in your work, please cite :raised_hands:! Problem templates give the user the ability to add other constraints and objective functions to this problem and solve it efficiently using  Ipopt.jl  and  MathOptInterface.jl  under the hood."},{"id":185,"pagetitle":"Home","title":"Installation","ref":"/QuantumCollocation/dev/#Installation","content":" Installation This package is registered! To install, enter the Julia REPL, type  ]  to enter pkg mode, and then run: pkg> add QuantumCollocation"},{"id":186,"pagetitle":"Home","title":"Example","ref":"/QuantumCollocation/dev/#Example","content":" Example"},{"id":187,"pagetitle":"Home","title":"Single Qubit Hadamard Gate","ref":"/QuantumCollocation/dev/#Single-Qubit-Hadamard-Gate","content":" Single Qubit Hadamard Gate using QuantumCollocation\n\nT = 50\nΔt = 0.2\nsystem = QuantumSystem([PAULIS[:X], PAULIS[:Y]])\nU_goal = GATES.H\n\n# Hadamard Gate\nprob = UnitarySmoothPulseProblem(system, U_goal, T, Δt)\nsolve!(prob, max_iter=100)"},{"id":190,"pagetitle":"Problem Templates","title":"Problem Templates","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#Problem-Templates","content":" Problem Templates We provide a number of problem templates for making it simple and easy to set up and solve certain types of quantum optimal control problems. These templates all construct a  DirectTrajOptProblem  object, which stores all the parts of the optimal control problem. This page provides a brief overview of each problem template, broken down by the state of the problem being solved. Ket Problem Templates: Quantum State Smooth Pulse Problem Quantum State Minimum Time Problem Quantum State Sampling Problem Unitary Problem Templates: Unitary Smooth Pulse Problem Unitary Minimum Time Problem Unitary Sampling Problem"},{"id":191,"pagetitle":"Problem Templates","title":"Ket Problem Templates","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#Ket-Problem-Templates","content":" Ket Problem Templates"},{"id":192,"pagetitle":"Problem Templates","title":"Quantum State Smooth Pulse Problem","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#Quantum-State-Smooth-Pulse-Problem","content":" Quantum State Smooth Pulse Problem"},{"id":193,"pagetitle":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem-generated-man-problem_templates","content":" QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem  —  Function QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...) Create a quantum state smooth pulse problem. The goal is to find a control pulse  a(t)   that drives all of the initial states  ψ_inits  to the corresponding target states   ψ_goals  using  T  timesteps of size  Δt . This problem also controls the  first and  second derivatives of the control pulse,  da(t)  and  dda(t) , to ensure smoothness. Arguments system::AbstractQuantumSystem : The quantum system. or H_drift::AbstractMatrix{<:Number} : The drift Hamiltonian. H_drives::Vector{<:AbstractMatrix{<:Number}} : The control Hamiltonians. with ψ_inits::Vector{<:AbstractVector{<:ComplexF64}} : The initial states. ψ_goals::Vector{<:AbstractVector{<:ComplexF64}} : The target states. or ψ_init::AbstractVector{<:ComplexF64} : The initial state. ψ_goal::AbstractVector{<:ComplexF64} : The target state. with T::Int : The number of timesteps. Δt::Float64 : The timestep size. Keyword Arguments state_name::Symbol=:ψ̃ : The name of the state variable. control_name::Symbol=:a : The name of the control variable. timestep_name::Symbol=:Δt : The name of the timestep variable. init_trajectory::Union{NamedTrajectory, Nothing}=nothing : The initial trajectory. a_bound::Float64=1.0 : The bound on the control pulse. a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)) : The bounds on the control pulse. a_guess::Union{Matrix{Float64}, Nothing}=nothing : The initial guess for the control pulse. da_bound::Float64=Inf : The bound on the first derivative of the control pulse. da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)) : The bounds on the first derivative of the control pulse. dda_bound::Float64=1.0 : The bound on the second derivative of the control pulse. dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)) : The bounds on the second derivative of the control pulse. Δt_min::Float64=0.5 * Δt : The minimum timestep size. Δt_max::Float64=1.5 * Δt : The maximum timestep size. drive_derivative_σ::Float64=0.01 : The standard deviation of the drive derivative random initialization. Q::Float64=100.0 : The weight on the state objective. R=1e-2 : The weight on the control pulse and its derivatives. R_a::Union{Float64, Vector{Float64}}=R : The weight on the control pulse. R_da::Union{Float64, Vector{Float64}}=R : The weight on the first derivative of the control pulse. R_dda::Union{Float64, Vector{Float64}}=R : The weight on the second derivative of the control pulse. constraints::Vector{<:AbstractConstraint}=AbstractConstraint[] : The constraints. piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. source Each problem starts with a  QuantumSystem  object, which is used to define the system's Hamiltonian and control operators. The goal is to find a control pulse that drives the intial state,  ψ_init , to a target state,  ψ_goal . define the quantum system system = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y])\nψ_init = Vector{ComplexF64}([1.0, 0.0])\nψ_goal = Vector{ComplexF64}([0.0, 1.0])\nT = 51\nΔt = 0.2 0.2 create the smooth pulse problem state_prob = QuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt);     constructing QuantumStateSmoothPulseProblem...\n\tusing integrator: typeof(KetIntegrator)\n\tusing 1 initial state(s)\n\tapplying timesteps_all_equal constraint: Δt check the fidelity before solving println(\"Before: \", rollout_fidelity(state_prob.trajectory, system)) Before: 0.2702650322149119 solve the problem solve!(state_prob, max_iter=100, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of ψ̃\n        applying constraint: initial value of a\n        applying constraint: initial value of da\n        applying constraint: final value of a\n        applying constraint: final value of da\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt\n\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n****************************************************************************** check the fidelity after solving println(\"After: \", rollout_fidelity(state_prob.trajectory, system)) After: 0.9999999999792313 extract the control pulses state_prob.trajectory.a |> size (2, 51)"},{"id":194,"pagetitle":"Problem Templates","title":"Quantum State Minimum Time Problem","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#Quantum-State-Minimum-Time-Problem","content":" Quantum State Minimum Time Problem"},{"id":195,"pagetitle":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem-generated-man-problem_templates","content":" QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem  —  Function QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)\nQuantumStateMinimumTimeProblem(prob; kwargs...) Construct a  DirectTrajOptProblem  for the minimum time problem of reaching a target state. Keyword Arguments state_name::Symbol=:ψ̃ : The symbol for the state variables. final_fidelity::Union{Real, Nothing}=nothing : The final fidelity. D=1.0 : The cost weight on the time. piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. source create the minimum time problem min_state_prob = QuantumStateMinimumTimeProblem(state_prob, ψ_goal);     constructing QuantumStateMinimumTimeProblem...\n\tfinal fidelity: 1.0 check the previous duration println(\"Duration before: \", get_duration(state_prob.trajectory)) Duration before: 10.46338258283023 solve the minimum time problem solve!(min_state_prob, max_iter=100, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of ψ̃\n        applying constraint: initial value of a\n        applying constraint: initial value of da\n        applying constraint: final value of a\n        applying constraint: final value of da\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt check the new duration println(\"Duration after: \", get_duration(min_state_prob.trajectory)) Duration after: 3.681381318546689 the fidelity is preserved by a constraint println(\"Fidelity after: \", rollout_fidelity(min_state_prob.trajectory, system)) Fidelity after: 0.999985409162291"},{"id":196,"pagetitle":"Problem Templates","title":"Quantum State Sampling Problem","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#Quantum-State-Sampling-Problem","content":" Quantum State Sampling Problem"},{"id":197,"pagetitle":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem-generated-man-problem_templates","content":" QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem  —  Function source create a sampling problem driftless_system = QuantumSystem([PAULIS.X, PAULIS.Y])\nsampling_state_prob = QuantumStateSamplingProblem([system, driftless_system], ψ_init, ψ_goal, T, Δt);     constructing QuantumStateSamplingProblem...\n\tusing integrator: typeof(KetIntegrator)\n\tusing 2 initial state(s)\n\tapplying timesteps_all_equal constraint: Δt new keys are added to the trajectory for the new states println(sampling_state_prob.trajectory.state_names) (:ψ̃1_system_1, :a, :da, :ψ̃1_system_2) solve the sampling problem for a few iterations solve!(sampling_state_prob, max_iter=25, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of ψ̃1_system_1\n        applying constraint: initial value of a\n        applying constraint: initial value of da\n        applying constraint: initial value of ψ̃1_system_2\n        applying constraint: final value of a\n        applying constraint: final value of da\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt check the fidelity of the sampling problem (use the updated key to get the initial and goal) println(\"After (original system): \", rollout_fidelity(sampling_state_prob.trajectory, system, state_name=:ψ̃1_system_1))\nprintln(\"After (new system): \", rollout_fidelity(sampling_state_prob.trajectory, driftless_system, state_name=:ψ̃1_system_1)) After (original system): 0.9877387017241955\nAfter (new system): 0.9885756196665351 compare this to using the original problem on the new system println(\"After (new system, original `prob`): \", rollout_fidelity(state_prob.trajectory, driftless_system)) After (new system, original `prob`): 0.7760663640031801"},{"id":198,"pagetitle":"Problem Templates","title":"Unitary Problem Templates","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#Unitary-Problem-Templates","content":" Unitary Problem Templates"},{"id":199,"pagetitle":"Problem Templates","title":"Unitary Smooth Pulse Problem","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#Unitary-Smooth-Pulse-Problem","content":" Unitary Smooth Pulse Problem"},{"id":200,"pagetitle":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-generated-man-problem_templates","content":" QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem  —  Function UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator, T, Δt; kwargs...)\nUnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...) Construct a  DirectTrajOptProblem  for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e., \\[\\begin{aligned}\n\\underset{\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}, \\Delta t}{\\text{minimize}} & \\quad\nQ \\cdot \\ell\\qty(\\vec{\\tilde{U}}_T, \\vec{\\tilde{U}}_{\\text{goal}}) + \\frac{1}{2} \\sum_t \\qty(R_a a_t^2 + R_{\\dot{a}} \\dot{a}_t^2 + R_{\\ddot{a}} \\ddot{a}_t^2) \\\\\n\\text{ subject to } & \\quad \\vb{P}^{(n)}\\qty(\\vec{\\tilde{U}}_{t+1}, \\vec{\\tilde{U}}_t, a_t, \\Delta t_t) = 0 \\\\\n& \\quad a_{t+1} - a_t - \\dot{a}_t \\Delta t_t = 0 \\\\\n& \\quad \\dot{a}_{t+1} - \\dot{a}_t - \\ddot{a}_t \\Delta t_t = 0 \\\\\n& \\quad |a_t| \\leq a_{\\text{bound}} \\\\\n& \\quad |\\ddot{a}_t| \\leq \\ddot{a}_{\\text{bound}} \\\\\n& \\quad \\Delta t_{\\text{min}} \\leq \\Delta t_t \\leq \\Delta t_{\\text{max}} \\\\\n\\end{aligned}\\] where, for  $U \\in SU(N)$ , \\[\\ell\\qty(\\vec{\\tilde{U}}_T, \\vec{\\tilde{U}}_{\\text{goal}}) =\n\\abs{1 - \\frac{1}{N} \\abs{ \\tr \\qty(U_{\\text{goal}}, U_T)} }\\] is the  infidelity  objective function,  $Q$  is a weight,  $R_a$ ,  $R_{\\dot{a}}$ , and  $R_{\\ddot{a}}$  are weights on the regularization terms, and  $\\vb{P}^{(n)}$  is the  $n$ th-order Pade integrator. Arguments system::AbstractQuantumSystem : the system to be controlled or H_drift::AbstractMatrix{<:Number} : the drift hamiltonian H_drives::Vector{<:AbstractMatrix{<:Number}} : the control hamiltonians with goal::AbstractPiccoloOperator : the target unitary, either in the form of an  EmbeddedOperator  or a `Matrix{ComplexF64} T::Int : the number of timesteps Δt::Float64 : the (initial) time step size Keyword Arguments piccolo_options::PiccoloOptions=PiccoloOptions() : the options for the Piccolo solver state_name::Symbol = :Ũ⃗ : the name of the state control_name::Symbol = :a : the name of the control timestep_name::Symbol = :Δt : the name of the timestep init_trajectory::Union{NamedTrajectory, Nothing}=nothing : an initial trajectory to use a_guess::Union{Matrix{Float64}, Nothing}=nothing : an initial guess for the control pulses a_bound::Float64=1.0 : the bound on the control pulse a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)) : the bounds on the control pulses, one for each drive da_bound::Float64=Inf : the bound on the control pulse derivative da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)) : the bounds on the control pulse derivatives, one for each drive dda_bound::Float64=1.0 : the bound on the control pulse second derivative dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)) : the bounds on the control pulse second derivatives, one for each drive Δt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt) : the minimum time step size Δt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt) : the maximum time step size Q::Float64=100.0 : the weight on the infidelity objective R=1e-2 : the weight on the regularization terms R_a::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulses R_da::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulse derivatives R_dda::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulse second derivatives constraints::Vector{<:AbstractConstraint}=AbstractConstraint[] : the constraints to enforce source The  UnitarySmoothPulseProblem  is similar to the  QuantumStateSmoothPulseProblem , but instead of driving the system to a target state, the goal is to drive the system to a target unitary operator,  U_goal . system = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y])\nU_goal = GATES.H\nT = 51\nΔt = 0.2\n\nprob = UnitarySmoothPulseProblem(system, U_goal, T, Δt);     constructing UnitarySmoothPulseProblem...\n\tusing integrator: typeof(UnitaryIntegrator)\n\tcontrol derivative names: [:da, :dda]\n\tapplying timesteps_all_equal constraint: Δt check the fidelity before solving println(\"Before: \", unitary_rollout_fidelity(prob.trajectory, system)) Before: 0.22043303242736734 finding an optimal control is as simple as calling  solve! solve!(prob, max_iter=100, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: initial value of da\n        applying constraint: final value of a\n        applying constraint: final value of da\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt check the fidelity after solving println(\"After: \", unitary_rollout_fidelity(prob.trajectory, system)) After: 0.9996060497974855 The  NamedTrajectory  object stores the control pulse, state variables, and the time grid. extract the control pulses prob.trajectory.a |> size (2, 51)"},{"id":201,"pagetitle":"Problem Templates","title":"Unitary Minimum Time Problem","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#Unitary-Minimum-Time-Problem","content":" Unitary Minimum Time Problem"},{"id":202,"pagetitle":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem-generated-man-problem_templates","content":" QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem  —  Function UnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    trajectory::NamedTrajectory,\n    objective::Objective,\n    dynamics::TrajectoryDynamics,\n    constraints::AbstractVector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    prob::DirectTrajOptProblem;\n    kwargs...\n) Create a minimum-time problem for unitary control. \\[\\begin{aligned}\n\\underset{\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}, \\Delta t}{\\text{minimize}} & \\quad\nJ(\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}) + D \\sum_t \\Delta t_t \\\\\n\\text{ subject to } & \\quad \\vb{P}^{(n)}\\qty(\\vec{\\tilde{U}}_{t+1}, \\vec{\\tilde{U}}_t, a_t, \\Delta t_t) = 0 \\\\\n& c(\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}) = 0 \\\\\n& \\quad \\Delta t_{\\text{min}} \\leq \\Delta t_t \\leq \\Delta t_{\\text{max}} \\\\\n\\end{aligned}\\] Keyword Arguments piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. unitary_name::Symbol=:Ũ⃗ : The name of the unitary for the goal. final_fidelity::Float64=1.0 : The final fidelity constraint. D::Float64=1.0 : The scaling factor for the minimum-time objective. source The goal of this problem is to find the shortest time it takes to drive the system to a target unitary operator,  U_goal . The problem is solved by minimizing the sum of all of the time steps. It is constructed from  prob  in the previous example. min_prob = UnitaryMinimumTimeProblem(prob, U_goal);     constructing UnitaryMinimumTimeProblem...\n\tfinal fidelity: 1.0 check the previous duration println(\"Duration before: \", get_duration(prob.trajectory)) Duration before: 8.369711303490133 solve the minimum time problem solve!(min_prob, max_iter=100, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: initial value of da\n        applying constraint: final value of a\n        applying constraint: final value of da\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt check the new duration println(\"Duration after: \", get_duration(min_prob.trajectory)) Duration after: 5.775410534511182 the fidelity is preserved by a constraint println(\"Fidelity after: \", unitary_rollout_fidelity(min_prob.trajectory, system)) Fidelity after: 0.999999996816126"},{"id":203,"pagetitle":"Problem Templates","title":"Unitary Sampling Problem","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#Unitary-Sampling-Problem","content":" Unitary Sampling Problem"},{"id":204,"pagetitle":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySamplingProblem","ref":"/QuantumCollocation/dev/generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-generated-man-problem_templates","content":" QuantumCollocation.ProblemTemplates.UnitarySamplingProblem  —  Function UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...) A  UnitarySamplingProblem  is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control  pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty. Arguments systems::AbstractVector{<:AbstractQuantumSystem} : A vector of quantum systems. operators::AbstractVector{<:AbstractPiccoloOperator} : A vector of target operators. T::Int : The number of time steps. Δt::Union{Float64, Vector{Float64}} : The time step value or vector of time steps. Keyword Arguments system_labels::Vector{String} = string.(1:length(systems)) : The labels for each system. system_weights::Vector{Float64} = fill(1.0, length(systems)) : The weights for each system. init_trajectory::Union{NamedTrajectory, Nothing} = nothing : The initial trajectory. state_name::Symbol = :Ũ⃗ : The name of the state variable. control_name::Symbol = :a : The name of the control variable. timestep_name::Symbol = :Δt : The name of the timestep variable. constraints::Vector{<:AbstractConstraint} = AbstractConstraint[] : The constraints. a_bound::Float64 = 1.0 : The bound for the control amplitudes. a_bounds::Vector{Float64} = fill(a_bound, length(systems[1].G_drives)) : The bounds for the control amplitudes. a_guess::Union{Matrix{Float64}, Nothing} = nothing : The initial guess for the control amplitudes. da_bound::Float64 = Inf : The bound for the control first derivatives. da_bounds::Vector{Float64} = fill(da_bound, length(systems[1].G_drives)) : The bounds for the control first derivatives. dda_bound::Float64 = 1.0 : The bound for the control second derivatives. dda_bounds::Vector{Float64} = fill(dda_bound, length(systems[1].G_drives)) : The bounds for the control second derivatives. Δt_min::Float64 = 0.5 * Δt : The minimum time step size. Δt_max::Float64 = 1.5 * Δt : The maximum time step size. Q::Float64 = 100.0 : The fidelity weight. R::Float64 = 1e-2 : The regularization weight. R_a::Union{Float64, Vector{Float64}} = R : The regularization weight for the control amplitudes. R_da::Union{Float64, Vector{Float64}} = R : The regularization weight for the control first derivatives. R_dda::Union{Float64, Vector{Float64}} = R : The regularization weight for the control second derivatives. piccolo_options::PiccoloOptions = PiccoloOptions() : The Piccolo options. source A sampling problem is used to solve over multiple quantum systems with the same control. This can be useful for exploring robustness, for example. create a sampling problem driftless_system = QuantumSystem([PAULIS.X, PAULIS.Y])\nsampling_prob = UnitarySamplingProblem([system, driftless_system], U_goal, T, Δt);     constructing UnitarySamplingProblem...\n\tusing integrator: typeof(UnitaryIntegrator)\n\tusing 2 systems\n\tapplying timesteps_all_equal constraint: Δt new keys are addded to the trajectory for the new states println(sampling_prob.trajectory.state_names) (:Ũ⃗_system_1, :a, :da, :Ũ⃗_system_2) the  solve!  proceeds as in the  Quantum State Sampling Problem ] This page was generated using  Literate.jl ."},{"id":207,"pagetitle":"Library","title":"Library","ref":"/QuantumCollocation/dev/lib/#Library","content":" Library"},{"id":208,"pagetitle":"Library","title":"Problem Templates","ref":"/QuantumCollocation/dev/lib/#Problem-Templates","content":" Problem Templates"},{"id":209,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","content":" QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem  —  Function QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)\nQuantumStateMinimumTimeProblem(prob; kwargs...) Construct a  DirectTrajOptProblem  for the minimum time problem of reaching a target state. Keyword Arguments state_name::Symbol=:ψ̃ : The symbol for the state variables. final_fidelity::Union{Real, Nothing}=nothing : The final fidelity. D=1.0 : The cost weight on the time. piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. source"},{"id":210,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","content":" QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem  —  Function source"},{"id":211,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","content":" QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem  —  Function QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...) Create a quantum state smooth pulse problem. The goal is to find a control pulse  a(t)   that drives all of the initial states  ψ_inits  to the corresponding target states   ψ_goals  using  T  timesteps of size  Δt . This problem also controls the  first and  second derivatives of the control pulse,  da(t)  and  dda(t) , to ensure smoothness. Arguments system::AbstractQuantumSystem : The quantum system. or H_drift::AbstractMatrix{<:Number} : The drift Hamiltonian. H_drives::Vector{<:AbstractMatrix{<:Number}} : The control Hamiltonians. with ψ_inits::Vector{<:AbstractVector{<:ComplexF64}} : The initial states. ψ_goals::Vector{<:AbstractVector{<:ComplexF64}} : The target states. or ψ_init::AbstractVector{<:ComplexF64} : The initial state. ψ_goal::AbstractVector{<:ComplexF64} : The target state. with T::Int : The number of timesteps. Δt::Float64 : The timestep size. Keyword Arguments state_name::Symbol=:ψ̃ : The name of the state variable. control_name::Symbol=:a : The name of the control variable. timestep_name::Symbol=:Δt : The name of the timestep variable. init_trajectory::Union{NamedTrajectory, Nothing}=nothing : The initial trajectory. a_bound::Float64=1.0 : The bound on the control pulse. a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)) : The bounds on the control pulse. a_guess::Union{Matrix{Float64}, Nothing}=nothing : The initial guess for the control pulse. da_bound::Float64=Inf : The bound on the first derivative of the control pulse. da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)) : The bounds on the first derivative of the control pulse. dda_bound::Float64=1.0 : The bound on the second derivative of the control pulse. dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)) : The bounds on the second derivative of the control pulse. Δt_min::Float64=0.5 * Δt : The minimum timestep size. Δt_max::Float64=1.5 * Δt : The maximum timestep size. drive_derivative_σ::Float64=0.01 : The standard deviation of the drive derivative random initialization. Q::Float64=100.0 : The weight on the state objective. R=1e-2 : The weight on the control pulse and its derivatives. R_a::Union{Float64, Vector{Float64}}=R : The weight on the control pulse. R_da::Union{Float64, Vector{Float64}}=R : The weight on the first derivative of the control pulse. R_dda::Union{Float64, Vector{Float64}}=R : The weight on the second derivative of the control pulse. constraints::Vector{<:AbstractConstraint}=AbstractConstraint[] : The constraints. piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. source"},{"id":212,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","content":" QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem  —  Function UnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    trajectory::NamedTrajectory,\n    objective::Objective,\n    dynamics::TrajectoryDynamics,\n    constraints::AbstractVector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    prob::DirectTrajOptProblem;\n    kwargs...\n) Create a minimum-time problem for unitary control. \\[\\begin{aligned}\n\\underset{\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}, \\Delta t}{\\text{minimize}} & \\quad\nJ(\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}) + D \\sum_t \\Delta t_t \\\\\n\\text{ subject to } & \\quad \\vb{P}^{(n)}\\qty(\\vec{\\tilde{U}}_{t+1}, \\vec{\\tilde{U}}_t, a_t, \\Delta t_t) = 0 \\\\\n& c(\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}) = 0 \\\\\n& \\quad \\Delta t_{\\text{min}} \\leq \\Delta t_t \\leq \\Delta t_{\\text{max}} \\\\\n\\end{aligned}\\] Keyword Arguments piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. unitary_name::Symbol=:Ũ⃗ : The name of the unitary for the goal. final_fidelity::Float64=1.0 : The final fidelity constraint. D::Float64=1.0 : The scaling factor for the minimum-time objective. source"},{"id":213,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySamplingProblem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-Tuple{AbstractVector{<:PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem}, AbstractVector{<:PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator}, Int64, Union{Float64, Vector{Float64}}}","content":" QuantumCollocation.ProblemTemplates.UnitarySamplingProblem  —  Method UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...) A  UnitarySamplingProblem  is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control  pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty. Arguments systems::AbstractVector{<:AbstractQuantumSystem} : A vector of quantum systems. operators::AbstractVector{<:AbstractPiccoloOperator} : A vector of target operators. T::Int : The number of time steps. Δt::Union{Float64, Vector{Float64}} : The time step value or vector of time steps. Keyword Arguments system_labels::Vector{String} = string.(1:length(systems)) : The labels for each system. system_weights::Vector{Float64} = fill(1.0, length(systems)) : The weights for each system. init_trajectory::Union{NamedTrajectory, Nothing} = nothing : The initial trajectory. state_name::Symbol = :Ũ⃗ : The name of the state variable. control_name::Symbol = :a : The name of the control variable. timestep_name::Symbol = :Δt : The name of the timestep variable. constraints::Vector{<:AbstractConstraint} = AbstractConstraint[] : The constraints. a_bound::Float64 = 1.0 : The bound for the control amplitudes. a_bounds::Vector{Float64} = fill(a_bound, length(systems[1].G_drives)) : The bounds for the control amplitudes. a_guess::Union{Matrix{Float64}, Nothing} = nothing : The initial guess for the control amplitudes. da_bound::Float64 = Inf : The bound for the control first derivatives. da_bounds::Vector{Float64} = fill(da_bound, length(systems[1].G_drives)) : The bounds for the control first derivatives. dda_bound::Float64 = 1.0 : The bound for the control second derivatives. dda_bounds::Vector{Float64} = fill(dda_bound, length(systems[1].G_drives)) : The bounds for the control second derivatives. Δt_min::Float64 = 0.5 * Δt : The minimum time step size. Δt_max::Float64 = 1.5 * Δt : The maximum time step size. Q::Float64 = 100.0 : The fidelity weight. R::Float64 = 1e-2 : The regularization weight. R_a::Union{Float64, Vector{Float64}} = R : The regularization weight for the control amplitudes. R_da::Union{Float64, Vector{Float64}} = R : The regularization weight for the control first derivatives. R_dda::Union{Float64, Vector{Float64}} = R : The regularization weight for the control second derivatives. piccolo_options::PiccoloOptions = PiccoloOptions() : The Piccolo options. source"},{"id":214,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","content":" QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem  —  Function UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator, T, Δt; kwargs...)\nUnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...) Construct a  DirectTrajOptProblem  for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e., \\[\\begin{aligned}\n\\underset{\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}, \\Delta t}{\\text{minimize}} & \\quad\nQ \\cdot \\ell\\qty(\\vec{\\tilde{U}}_T, \\vec{\\tilde{U}}_{\\text{goal}}) + \\frac{1}{2} \\sum_t \\qty(R_a a_t^2 + R_{\\dot{a}} \\dot{a}_t^2 + R_{\\ddot{a}} \\ddot{a}_t^2) \\\\\n\\text{ subject to } & \\quad \\vb{P}^{(n)}\\qty(\\vec{\\tilde{U}}_{t+1}, \\vec{\\tilde{U}}_t, a_t, \\Delta t_t) = 0 \\\\\n& \\quad a_{t+1} - a_t - \\dot{a}_t \\Delta t_t = 0 \\\\\n& \\quad \\dot{a}_{t+1} - \\dot{a}_t - \\ddot{a}_t \\Delta t_t = 0 \\\\\n& \\quad |a_t| \\leq a_{\\text{bound}} \\\\\n& \\quad |\\ddot{a}_t| \\leq \\ddot{a}_{\\text{bound}} \\\\\n& \\quad \\Delta t_{\\text{min}} \\leq \\Delta t_t \\leq \\Delta t_{\\text{max}} \\\\\n\\end{aligned}\\] where, for  $U \\in SU(N)$ , \\[\\ell\\qty(\\vec{\\tilde{U}}_T, \\vec{\\tilde{U}}_{\\text{goal}}) =\n\\abs{1 - \\frac{1}{N} \\abs{ \\tr \\qty(U_{\\text{goal}}, U_T)} }\\] is the  infidelity  objective function,  $Q$  is a weight,  $R_a$ ,  $R_{\\dot{a}}$ , and  $R_{\\ddot{a}}$  are weights on the regularization terms, and  $\\vb{P}^{(n)}$  is the  $n$ th-order Pade integrator. Arguments system::AbstractQuantumSystem : the system to be controlled or H_drift::AbstractMatrix{<:Number} : the drift hamiltonian H_drives::Vector{<:AbstractMatrix{<:Number}} : the control hamiltonians with goal::AbstractPiccoloOperator : the target unitary, either in the form of an  EmbeddedOperator  or a `Matrix{ComplexF64} T::Int : the number of timesteps Δt::Float64 : the (initial) time step size Keyword Arguments piccolo_options::PiccoloOptions=PiccoloOptions() : the options for the Piccolo solver state_name::Symbol = :Ũ⃗ : the name of the state control_name::Symbol = :a : the name of the control timestep_name::Symbol = :Δt : the name of the timestep init_trajectory::Union{NamedTrajectory, Nothing}=nothing : an initial trajectory to use a_guess::Union{Matrix{Float64}, Nothing}=nothing : an initial guess for the control pulses a_bound::Float64=1.0 : the bound on the control pulse a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)) : the bounds on the control pulses, one for each drive da_bound::Float64=Inf : the bound on the control pulse derivative da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)) : the bounds on the control pulse derivatives, one for each drive dda_bound::Float64=1.0 : the bound on the control pulse second derivative dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)) : the bounds on the control pulse second derivatives, one for each drive Δt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt) : the minimum time step size Δt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt) : the maximum time step size Q::Float64=100.0 : the weight on the infidelity objective R=1e-2 : the weight on the regularization terms R_a::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulses R_da::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulse derivatives R_dda::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulse second derivatives constraints::Vector{<:AbstractConstraint}=AbstractConstraint[] : the constraints to enforce source"},{"id":215,"pagetitle":"Library","title":"Options","ref":"/QuantumCollocation/dev/lib/#Options","content":" Options"},{"id":216,"pagetitle":"Library","title":"QuantumCollocation.Options.PiccoloOptions","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.Options.PiccoloOptions","content":" QuantumCollocation.Options.PiccoloOptions  —  Type PiccoloOptions Options for the Piccolo quantum optimal control library. Fields verbose::Bool = true : Print verbose output timesteps_all_equal::Bool = true : Use equal timesteps rollout_integrator::Function = expv : Integrator to use for rollout geodesic = true : Use the geodesic to initialize the optimization. zero_initial_and_final_derivative::Bool=false : Zero the initial and final control pulse derivatives. complex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing : Name of the complex control norm constraint. complex_control_norm_constraint_radius::Float64 = 1.0 : Radius of the complex control norm constraint. bound_state::Bool = false : Bound the state. leakage_suppression::Bool = false : Suppress leakage. R_leakage::Float64 = 1.0 : Leakage suppression parameter. source"},{"id":217,"pagetitle":"Library","title":"Trajectory Initialization","ref":"/QuantumCollocation/dev/lib/#Trajectory-Initialization","content":" Trajectory Initialization"},{"id":218,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractVector{<:AbstractVector{ComplexF64}}, AbstractVector{<:AbstractVector{ComplexF64}}, Int64, Union{Real, AbstractVector{<:Real}}, Vararg{Any}}","content":" QuantumCollocation.TrajectoryInitialization.initialize_trajectory  —  Method initialize_trajectory Trajectory initialization of quantum states. source"},{"id":219,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Any, Any, Int64, Union{Real, AbstractVecOrMat{<:Real}}, Vararg{Any}}","content":" QuantumCollocation.TrajectoryInitialization.initialize_trajectory  —  Method initialize_trajectory Trajectory initialization of density matrices. source"},{"id":220,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator, Int64, Union{Real, AbstractVecOrMat{<:Real}}, Vararg{Any}}","content":" QuantumCollocation.TrajectoryInitialization.initialize_trajectory  —  Method initialize_trajectory Trajectory initialization of unitaries. source"},{"id":221,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Vector{<:AbstractMatrix{Float64}}, Vector{<:AbstractVector{Float64}}, Vector{<:AbstractVector{Float64}}, AbstractVector{Symbol}, Int64, Union{Float64, AbstractVecOrMat{<:Float64}}, Int64, Tuple{Vararg{Union{Tuple{AbstractVector{R}, AbstractVector{R}}, AbstractVector{R}} where R<:Real}}}","content":" QuantumCollocation.TrajectoryInitialization.initialize_trajectory  —  Method initialize_trajectory Initialize a trajectory for a control problem. The trajectory is initialized with data that should be consistently the same type (in this case, Float64). source"},{"id":222,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_geodesic","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.TrajectoryInitialization.unitary_geodesic","content":" QuantumCollocation.TrajectoryInitialization.unitary_geodesic  —  Function unitary_geodesic(\n    operator::EmbeddedOperator,\n    samples::Int;\n    kwargs...\n)\n\nunitary_geodesic(\n    U_goal::AbstractMatrix{<:Number},\n    samples::Int;\n    kwargs...\n)\n\nunitary_geodesic(\n    U₀::AbstractMatrix{<:Number},\n    U₁::AbstractMatrix{<:Number},\n    samples::Number;\n    kwargs...\n)\n\nunitary_geodesic(\n    U₀::AbstractMatrix{<:Number},\n    U₁::AbstractMatrix{<:Number},\n    timesteps::AbstractVector{<:Number};\n    return_generator=false\n) Compute a geodesic connecting two unitary operators. source"},{"id":223,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_geodesic","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.TrajectoryInitialization.unitary_geodesic-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, AbstractVector{<:Number}}","content":" QuantumCollocation.TrajectoryInitialization.unitary_geodesic  —  Method unitary_geodesic(U_init, U_goal, times; kwargs...) Compute the geodesic connecting U init and U goal at the specified times. Allows for the possibility of unequal times and ranges outside [0,1]. Arguments U_init::AbstractMatrix{<:Number} : The initial unitary operator. U_goal::AbstractMatrix{<:Number} : The goal unitary operator. times::AbstractVector{<:Number} : The times at which to evaluate the geodesic. Keyword Arguments return_unitary_isos::Bool=true : If true returns a matrix where each column is a unitary isovec, i.e. vec(vcat(real(U), imag(U))). If false, returns a vector of unitary matrices. return_generator::Bool=false : If true, returns the effective Hamiltonian generating the geodesic. source"},{"id":224,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Int64}","content":" QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation  —  Method unitary_linear_interpolation(\n    U_init::AbstractMatrix,\n    U_goal::AbstractMatrix,\n    samples::Int\n) Compute a linear interpolation of unitary operators with  samples  samples. source"},{"id":225,"pagetitle":"Library","title":"Trajectory Interpolations","ref":"/QuantumCollocation/dev/lib/#Trajectory-Interpolations","content":" Trajectory Interpolations"},{"id":226,"pagetitle":"Library","title":"Quantum System Templates","ref":"/QuantumCollocation/dev/lib/#Quantum-System-Templates","content":" Quantum System Templates"},{"id":227,"pagetitle":"Library","title":"QuantumCollocation.QuantumSystemTemplates.MultiTransmonSystem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.QuantumSystemTemplates.MultiTransmonSystem-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}}","content":" QuantumCollocation.QuantumSystemTemplates.MultiTransmonSystem  —  Method MultiTransmonSystem(\n    ωs::AbstractVector{Float64},\n    δs::AbstractVector{Float64},\n    gs::AbstractMatrix{Float64};\n    levels_per_transmon::Int = 3,\n    subsystem_levels::AbstractVector{Int} = fill(levels_per_transmon, length(ωs)),\n    lab_frame=false,\n    subsystems::AbstractVector{Int} = 1:length(ωs),\n    subsystem_drive_indices::AbstractVector{Int} = 1:length(ωs),\n    kwargs...\n) -> CompositeQuantumSystem Returns a  CompositeQuantumSystem  object for a multi-transmon system. source"},{"id":228,"pagetitle":"Library","title":"QuantumCollocation.QuantumSystemTemplates.RydbergChainSystem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.QuantumSystemTemplates.RydbergChainSystem-Tuple{}","content":" QuantumCollocation.QuantumSystemTemplates.RydbergChainSystem  —  Method RydbergChainSystem(;\n    N::Int=3, # number of atoms\n    C::Float64=862690*2π,\n    distance::Float64=10.0, # μm\n    cutoff_order::Int=2, # 1 is nearest neighbor, 2 is next-nearest neighbor, etc.\n    local_detune::Bool=false, # If true, include one local detuning pattern.\n    all2all::Bool=true, # If true, include all-to-all interactions.\n    ignore_Y_drive::Bool=false, # If true, ignore the Y drive. (In the experiments, X&Y drives are implemented by Rabi amplitude and its phase.)\n) -> QuantumSystem Returns a  QuantumSystem  object for the Rydberg atom chain in the spin basis     |g⟩ = |0⟩ = [1, 0], |r⟩ = |1⟩ = [0, 1]. \\[H = \\sum_i 0.5*\\Omega_i(t)\\cos(\\phi_i(t)) \\sigma_i^x - 0.5*\\Omega_i(t)\\sin(\\phi_i(t)) \\sigma_i^y - \\sum_i \\Delta_i(t)n_i + \\sum_{i<j} \\frac{C}{|i-j|^6} n_i n_j\\] Keyword Arguments N : Number of atoms. C : The Rydberg interaction strength in MHz*μm^6. distance : The distance between atoms in μm. cutoff_order : Interaction range cutoff, 1 is nearest neighbor, 2 is next nearest neighbor. local_detune : If true, include one local detuning pattern. all2all : If true, include all-to-all interactions. ignore_Y_drive : If true, ignore the Y drive. (In the experiments, X&Y drives are implemented by Rabi amplitude and its phase.) source"},{"id":229,"pagetitle":"Library","title":"QuantumCollocation.QuantumSystemTemplates.TransmonDipoleCoupling","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.QuantumSystemTemplates.TransmonDipoleCoupling","content":" QuantumCollocation.QuantumSystemTemplates.TransmonDipoleCoupling  —  Function TransmonDipoleCoupling(\n    g_ij::Float64,\n    pair::Tuple{Int, Int},\n    subsystem_levels::Vector{Int};\n    lab_frame::Bool=false,\n) -> QuantumSystemCoupling\n\nTransmonDipoleCoupling(\n    g_ij::Float64,\n    pair::Tuple{Int, Int},\n    sub_systems::Vector{QuantumSystem};\n    kwargs...\n) -> QuantumSystemCoupling Returns a  QuantumSystemCoupling  object for a transmon qubit. In the lab frame, the Hamiltonian coupling term is \\[H = g_{ij} (a_i + a_i^\\dagger) (a_j + a_j^\\dagger)\\] In the rotating frame, the Hamiltonian coupling term is \\[H = g_{ij} (a_i a_j^\\dagger + a_i^\\dagger a_j)\\] where  a_i  is the annihilation operator for the  i th transmon. source"},{"id":230,"pagetitle":"Library","title":"QuantumCollocation.QuantumSystemTemplates.TransmonSystem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.QuantumSystemTemplates.TransmonSystem-Tuple{}","content":" QuantumCollocation.QuantumSystemTemplates.TransmonSystem  —  Method TransmonSystem(;\n    ω::Float64=4.4153,  # GHz\n    δ::Float64=0.17215, # GHz\n    levels::Int=3,\n    lab_frame::Bool=false,\n    frame_ω::Float64=ω,\n) -> QuantumSystem Returns a  QuantumSystem  object for a transmon qubit, with the Hamiltonian \\[H = \\omega a^\\dagger a - \\frac{\\delta}{2} a^\\dagger a^\\dagger a a\\] where  a  is the annihilation operator. Keyword Arguments ω : The frequency of the transmon, in GHz. δ : The anharmonicity of the transmon, in GHz. levels : The number of levels in the transmon. lab_frame : Whether to use the lab frame Hamiltonian, or an ω-rotating frame. frame_ω : The frequency of the rotating frame, in GHz. mutiply_by_2π : Whether to multiply the Hamiltonian by 2π, set to true by default because the frequency is in GHz. lab_frame_type : The type of lab frame Hamiltonian to use, one of (:duffing, :quartic, :cosine). drives : Whether to include drives in the Hamiltonian. source"},{"id":231,"pagetitle":"Library","title":"QuantumCollocation.QuantumSystemTemplates.lift","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.QuantumSystemTemplates.lift-Tuple{Char, Int64, Int64}","content":" QuantumCollocation.QuantumSystemTemplates.lift  —  Method Embed a character into a string at a specific position. source"},{"id":234,"pagetitle":"Home","title":"DirectTrajOpt.jl","ref":"/DirectTrajOpt/dev/#DirectTrajOpt.jl","content":" DirectTrajOpt.jl Documentation Build Status License DirectTrajOpt.jl  provides abstractions and utilities for setting up and solving direct trajectory optimization problems of the form: $ \\begin{align } \\underset{x {1:N}, u {1:N-1}}{\\text{minimize}} \\quad & J(x {1:N}, u {1:N-1}) \\\n\\text{subject to} \\quad & f(x {k+1}, x k, u k, \\Delta t, t k) = 0\\\n& c k(x k, u k) \\geq 0 \\\n& x 1 = x_{\\text{init}} \\\n\\end{align } $ where  $J(x_{1:N}, u_{1:N-1})$  is a user-defined cost function,  $f(x_{k+1}, x_k, u_k, \\Delta t, t_k)$  is an  integrator  funtion encoding the dynamics of the system, and  $c_k(x_k, u_k)$  are user-defined constraints. The underlying nonlinear solver is  Ipopt.jl , which is a Julia interface to the  Ipopt  solver. "},{"id":237,"pagetitle":"Explanation","title":"Quickstart Guide","ref":"/DirectTrajOpt/dev/generated/explanation/#Quickstart-Guide","content":" Quickstart Guide"},{"id":238,"pagetitle":"Explanation","title":"Installation","ref":"/DirectTrajOpt/dev/generated/explanation/#Installation","content":" Installation using DirectTrajOpt"},{"id":239,"pagetitle":"Explanation","title":"This package also provides various objects and bindings used in Quantum Optimal Control problems.","ref":"/DirectTrajOpt/dev/generated/explanation/#This-package-also-provides-various-objects-and-bindings-used-in-Quantum-Optimal-Control-problems.","content":" This package also provides various objects and bindings used in Quantum Optimal Control problems. This means various common constraints, integrators, objectives, and losses. This package also provides interfaces for the commonly needed dynamics, and evaluator objects to provide to the solver - which for now is Ipopt. This page was generated using  Literate.jl ."},{"id":242,"pagetitle":"Lib","title":"Library","ref":"/DirectTrajOpt/dev/lib/#Library","content":" Library"},{"id":243,"pagetitle":"Lib","title":"Constraints","ref":"/DirectTrajOpt/dev/lib/#Constraints","content":" Constraints"},{"id":244,"pagetitle":"Lib","title":"DirectTrajOpt.Constraints.EqualityConstraint","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Constraints.EqualityConstraint","content":" DirectTrajOpt.Constraints.EqualityConstraint  —  Type struct EqualityConstraint Represents a linear equality constraint. Fields ts::AbstractArray{Int} : the time steps at which the constraint is applied js::AbstractArray{Int} : the components of the trajectory at which the constraint is applied vals::Vector{R} : the values of the constraint vardim::Int : the dimension of a single time step of the trajectory label::String : a label for the constraint source"},{"id":245,"pagetitle":"Lib","title":"DirectTrajOpt.Constraints.EqualityConstraint","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Constraints.EqualityConstraint-Tuple{Symbol, AbstractVector{Int64}, Vector{Float64}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" DirectTrajOpt.Constraints.EqualityConstraint  —  Method EqualityConstraint(\n    name::Symbol,\n    ts::Vector{Int},\n    val::Vector{Float64},\n    traj::NamedTrajectory;\n    label=\"equality constraint on trajectory variable [name]\"\n) Constructs equality constraint for trajectory variable in NamedTrajectory source"},{"id":246,"pagetitle":"Lib","title":"DirectTrajOpt.Constraints.GlobalEqualityConstraint","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Constraints.GlobalEqualityConstraint-Tuple{Symbol, Vector{Float64}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" DirectTrajOpt.Constraints.GlobalEqualityConstraint  —  Method GlobalEqualityConstraint(\n    name::Symbol,\n    val::Vector{Float64},\n    traj::NamedTrajectory;\n    label=\"equality constraint on global variable [name]\"\n)::EqualityConstraint Constructs equality constraint for global variable in NamedTrajectory source"},{"id":247,"pagetitle":"Lib","title":"Integrators","ref":"/DirectTrajOpt/dev/lib/#Integrators","content":" Integrators"},{"id":248,"pagetitle":"Lib","title":"DirectTrajOpt.Integrators.dense","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Integrators.dense-Tuple{Any, Any, Any}","content":" DirectTrajOpt.Integrators.dense  —  Method dense(vals, structure, shape) Convert sparse data to dense matrix. Arguments vals : vector of values structure : vector of tuples of indices shape : tuple of matrix dimensions source"},{"id":249,"pagetitle":"Lib","title":"DirectTrajOpt.Integrators.show_diffs","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Integrators.show_diffs-Tuple{AbstractMatrix, AbstractMatrix}","content":" DirectTrajOpt.Integrators.show_diffs  —  Method show_diffs(A::Matrix, B::Matrix) Show differences between matrices. source"},{"id":250,"pagetitle":"Lib","title":"Objectives","ref":"/DirectTrajOpt/dev/lib/#Objectives","content":" Objectives"},{"id":251,"pagetitle":"Lib","title":"DirectTrajOpt.Objectives.Objective","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Objectives.Objective","content":" DirectTrajOpt.Objectives.Objective  —  Type Objective A structure for defining objective functions. Fields:      L : the objective function      ∇L : the gradient of the objective function      ∂²L : the Hessian of the objective function      ∂²L_structure : the structure of the Hessian of the objective function source"},{"id":252,"pagetitle":"Lib","title":"DirectTrajOpt.Objectives.MinimumTimeObjective","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Objectives.MinimumTimeObjective-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" DirectTrajOpt.Objectives.MinimumTimeObjective  —  Method MinimumTimeObjective A type of objective that counts the time taken to complete a task.   D  is a scaling factor. source"},{"id":253,"pagetitle":"Lib","title":"DirectTrajOpt.Objectives.QuadraticRegularizer","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Objectives.QuadraticRegularizer-Tuple{Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, AbstractVector{<:Real}}","content":" DirectTrajOpt.Objectives.QuadraticRegularizer  —  Method QuadraticRegularizer A quadratic regularizer for a trajectory component. Fields:      name : the name of the trajectory component to regularize      traj : the trajectory      R : the regularization matrix diagonal      baseline : the baseline values for the trajectory component      times : the times at which to evaluate the regularizer source"},{"id":254,"pagetitle":"Lib","title":"Dynamics","ref":"/DirectTrajOpt/dev/lib/#Dynamics","content":" Dynamics"},{"id":255,"pagetitle":"Lib","title":"DirectTrajOpt.Dynamics.TrajectoryDynamics","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Dynamics.TrajectoryDynamics","content":" DirectTrajOpt.Dynamics.TrajectoryDynamics  —  Type TrajectoryDynamics A struct for trajectory optimization dynamics, represented by integrators that compute single time step dynamics, and functions for jacobians and hessians. Fields integrators::Union{Nothing, Vector{<:AbstractIntegrator}} : Vector of integrators. F!::Function : Function to compute trajectory dynamics. ∂F!::Function : Function to compute the Jacobian of the dynamics. ∂fs::Vector{SparseMatrixCSC{Float64, Int}} : Vector of Jacobian matrices. μ∂²F!::Union{Function, Nothing} : Function to compute the Hessian of the Lagrangian. μ∂²fs::Vector{SparseMatrixCSC{Float64, Int}} : Vector of Hessian matrices. dim::Int : Total dimension of the dynamics. source"},{"id":256,"pagetitle":"Lib","title":"Problems","ref":"/DirectTrajOpt/dev/lib/#Problems","content":" Problems"},{"id":257,"pagetitle":"Lib","title":"DirectTrajOpt.Problems.DirectTrajOptProblem","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Problems.DirectTrajOptProblem","content":" DirectTrajOpt.Problems.DirectTrajOptProblem  —  Type mutable struct DirectTrajOptProblem <: AbstractProblem Stores all the information needed to set up and solve a DirectTrajOptProblem as well as the solution after the solver terminates. Fields optimizer::Ipopt.Optimizer : Ipopt optimizer object source"},{"id":258,"pagetitle":"Lib","title":"DirectTrajOpt.Problems.get_trajectory_constraints","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Problems.get_trajectory_constraints-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" DirectTrajOpt.Problems.get_trajectory_constraints  —  Method trajectory_constraints(traj::NamedTrajectory) Implements the initial and final value constraints and bounds constraints on the controls and states as specified by traj. source"},{"id":259,"pagetitle":"Lib","title":"Problem Solvers","ref":"/DirectTrajOpt/dev/lib/#Problem-Solvers","content":" Problem Solvers"},{"id":260,"pagetitle":"Lib","title":"Problem Solvers","ref":"/DirectTrajOpt/dev/lib/#Problem-Solvers-2","content":" Problem Solvers"},{"id":261,"pagetitle":"Lib","title":"DirectTrajOpt.IpoptSolverExt.IpoptOptions","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.IpoptSolverExt.IpoptOptions","content":" DirectTrajOpt.IpoptSolverExt.IpoptOptions  —  Type Solver options for Ipopt\n\nhttps://coin-or.github.io/Ipopt/OPTIONS.html#OPT_print_options_documentation source"},{"id":262,"pagetitle":"Lib","title":"DirectTrajOpt.Solvers.solve!","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Solvers.solve!-Tuple{DirectTrajOptProblem}","content":" DirectTrajOpt.Solvers.solve!  —  Method solve!(prob::DirectTrajOptProblem;         init traj=nothing,         save path=nothing,         max iter=prob.ipopt options.max iter,         linear solver=prob.ipopt options.linear solver,         print level=prob.ipopt options.print level,         remove slack variables=false,         callback=nothing         # state type=:unitary,         # print_fidelity=false,     ) Call optimization solver to solve the quantum control problem with parameters and callbacks. Arguments prob::DirectTrajOptProblem : The quantum control problem to solve. init_traj::NamedTrajectory : Initial guess for the control trajectory. If not provided, a random guess will be generated. save_path::String : Path to save the problem after optimization. max_iter::Int : Maximum number of iterations for the optimization solver. linear_solver::String : Linear solver to use for the optimization solver (e.g., \"mumps\", \"paradiso\", etc). print_level::Int : Verbosity level for the solver. callback::Function : Callback function to call during optimization steps. source"},{"id":265,"pagetitle":"Home","title":"NamedTrajectories.jl","ref":"/NamedTrajectories/dev/#NamedTrajectories.jl","content":" NamedTrajectories.jl NamedTrajectories.jl  is a package for working with trajectories of named variables. It is designed to be used with the  Piccolo.jl  ecosystem."},{"id":266,"pagetitle":"Home","title":"Installation","ref":"/NamedTrajectories/dev/#Installation","content":" Installation NamedTrajectories.jl is registered! Install in the REPL by entering pkg mode with  ]  and then running  pkg> add NamedTrajectories or to install the latest master branch run pkg> add NamedTrajectories#main"},{"id":267,"pagetitle":"Home","title":"Features","ref":"/NamedTrajectories/dev/#Features","content":" Features Abstract away messy indexing and vectorization details required for interfacing with numerical solvers. Easily handle multiple trajectories with different names, e.g. various states and controls. Simple plotting of trajectories. Provide a variety of helpful methods for common tasks."},{"id":268,"pagetitle":"Home","title":"Basic Usage","ref":"/NamedTrajectories/dev/#Basic-Usage","content":" Basic Usage Users can define  NamedTrajectory  types which have lots of useful functionality. For example, you can access the data by name or index.  In the case of an index, a  KnotPoint  is returned which contains the data for that timestep. using NamedTrajectories\n\n# define number of timesteps and timestep\nT = 10\ndt = 0.1\n\n# build named tuple of components and data matrices\ncomponents = (\n    x = rand(3, T),\n    u = rand(2, T),\n)\n\n# build trajectory\ntraj = NamedTrajectory(components; timestep=dt, controls=:u)\n\n# access data by name\ntraj.x # returns 3x10 matrix of x data\ntraj.u # returns 2x10 matrix of u data\n\nz1 = traj[1] # returns KnotPoint with x and u data\n\nz1.x # returns 3 element vector of x data at timestep 1\nz1.u # returns 2 element vector of u data at timestep 1\n\ntraj.data # returns data as 5x10 matrix\ntraj.names # returns names as tuple (:x, :u)"},{"id":269,"pagetitle":"Home","title":"Motivation","ref":"/NamedTrajectories/dev/#Motivation","content":" Motivation NamedTrajectories.jl  is designed to aid in the messy indexing involved in solving trajectory optimization problems of the form \\[\\begin{aligned}\n    \\arg \\min_{\\mathbf{Z}}\\quad & J(\\mathbf{Z}) \\\\\n    \\nonumber \\text{s.t.}\\qquad & \\mathbf{f}(\\mathbf{Z}) = 0 \\\\\n    \\nonumber & \\mathbf{g}(\\mathbf{Z}) \\le 0  \n\\end{aligned}\\] where  $\\mathbf{Z}$  is a trajectory. In more detail, this problem might look something like \\[\\begin{align*}\n\\underset{u^1_{1:T}, \\dots, u^{n_c}_{1:T}}{\\underset{x^1_{1:T}, \\cdots, x^{n_s}_{1:T}}{\\operatorname{minimize}}} &\\quad J\\qty(x^{1:n_s}_{1:T},u^{1:n_c}_{1:T}) \\\\\n\\text{subject to} & \\quad f\\qty(x^{1:n_s}_{1:T},u^{1:n_c}_{1:T}) = 0 \\\\\n& \\quad x^i_1 = x^i_{\\text{initial}} \\\\\n& \\quad x^i_T = x^i_{\\text{final}} \\\\\n& \\quad u^i_1 = u^i_{\\text{initial}} \\\\\n& \\quad u^i_T = u^i_{\\text{final}} \\\\\n& \\quad x^i_{\\min} < x^i_t < x^i_{\\max} \\\\\n& \\quad u^i_{\\min} < u^i_t < u^i_{\\max} \\\\\n\\end{align*}\\] where  $x^i_t$  is the  $i$ th state variable and  $u^i_t$  is the  $i$ th control variable at timestep  $t$ ; state and control variables can be of arbitrary dimension. The function  $f$  is a nonlinear constraint function and  $J$  is the objective function. These problems can have an arbitrary number of state ( $n_s$ ) and control ( $n_c$ ) variables, and the number of timesteps  $T$  can vary as well.   It is common practice in trajectory optimization to bundle all of the state and control variables together into a single  knot point \\[z_t = \\mqty(\n    x^1_t \\\\\n    \\vdots \\\\\n    x^{n_s}_t \\\\\n    u^1_t \\\\\n    \\vdots \\\\\n    u^{n_c}_t\n).\\] The trajectory optimization problem can then be succinctly written as \\[\\begin{align*}\n\\underset{z_{1:T}}{\\operatorname{minimize}} &\\quad J\\qty(z_{1:T}) \\\\\n\\text{subject to} & \\quad f\\qty(z_{1:T}) = 0 \\\\\n& \\quad z_1 = z_{\\text{initial}} \\\\\n& \\quad z_T = z_{\\text{final}} \\\\\n& \\quad z_{\\min} < z_t < z_{\\max} \\\\\n\\end{align*}\\] The  NamedTrajectories  package provides a  NamedTrajectory  type which abstracts away the messy indexing and vectorization details required for interfacing with numerical solvers.  It also provides a variety of helpful methods for common tasks.  For example, you can access the data by name or index.  In the case of an index, a  KnotPoint  is returned which contains the data for that timestep."},{"id":272,"pagetitle":"Constructors","title":"Constructors","ref":"/NamedTrajectories/dev/generated/man/constructors/#Constructors","content":" Constructors To construct a  NamedTrajectory  using NamedTrajectories.jl, we simply need to utilize the  NamedTrajectory  constructor. using NamedTrajectories\n\n# define number of timesteps and timestep\nT = 10\ndt = 0.1 0.1 build named tuple of components and data matrices. components = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = fill(dt, 1, T),\n) (x = [0.5462196894473466 0.4293194366335207 … 0.5828377658032261 0.12415819653396187; 0.8890817416112103 0.33515380300480413 … 0.6615336419519826 0.5286571836709045; 0.04803459526667364 0.27063043276194176 … 0.2695992261641529 0.8062269284195327], u = [0.46795237414328517 0.40408827345393605 … 0.2321164520065272 0.6955218656335493; 0.2733885558607647 0.5705420279350012 … 0.9695582014767942 0.14309606554922827], Δt = [0.1 0.1 … 0.1 0.1]) we must specify a timestep and control variable for the trajectory. timestep = 0.1\ncontrol = :u :u we can now create a  NamedTrajectory  object. traj = NamedTrajectory(components; timestep=timestep, controls=control) NamedTrajectory{Float64}([0.5462196894473466 0.4293194366335207 … 0.5828377658032261 0.12415819653396187; 0.8890817416112103 0.33515380300480413 … 0.6615336419519826 0.5286571836709045; … ; 0.2733885558607647 0.5705420279350012 … 0.9695582014767942 0.14309606554922827; 0.1 0.1 … 0.1 0.1], [0.5462196894473466, 0.8890817416112103, 0.04803459526667364, 0.46795237414328517, 0.2733885558607647, 0.1, 0.4293194366335207, 0.33515380300480413, 0.27063043276194176, 0.40408827345393605  …  0.2695992261641529, 0.2321164520065272, 0.9695582014767942, 0.1, 0.12415819653396187, 0.5286571836709045, 0.8062269284195327, 0.6955218656335493, 0.14309606554922827, 0.1], 10, 0.1, 6, (x = 3, u = 2, Δt = 1, states = 4, controls = 2), NamedTuple(), NamedTuple(), NamedTuple(), NamedTuple(), (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3, 6], controls = [4, 5]), NamedTuple(), 0, NamedTuple(), NamedTuple(), (:x, :u, :Δt), (:x, :Δt), (:u,)) Construct  NamedTrajectory  from previous constructed one. traj = NamedTrajectory(components, traj) NamedTrajectory{Float64}([0.5462196894473466 0.4293194366335207 … 0.5828377658032261 0.12415819653396187; 0.8890817416112103 0.33515380300480413 … 0.6615336419519826 0.5286571836709045; … ; 0.2733885558607647 0.5705420279350012 … 0.9695582014767942 0.14309606554922827; 0.1 0.1 … 0.1 0.1], [0.5462196894473466, 0.8890817416112103, 0.04803459526667364, 0.46795237414328517, 0.2733885558607647, 0.1, 0.4293194366335207, 0.33515380300480413, 0.27063043276194176, 0.40408827345393605  …  0.2695992261641529, 0.2321164520065272, 0.9695582014767942, 0.1, 0.12415819653396187, 0.5286571836709045, 0.8062269284195327, 0.6955218656335493, 0.14309606554922827, 0.1], 10, 0.1, 6, (x = 3, u = 2, Δt = 1, states = 4, controls = 2), NamedTuple(), NamedTuple(), NamedTuple(), NamedTuple(), (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3, 6], controls = [4, 5]), NamedTuple(), 0, NamedTuple(), NamedTuple(), (:x, :u, :Δt), (:x, :Δt), (:u,)) This page was generated using  Literate.jl ."},{"id":275,"pagetitle":"Copying and equality","title":"Copying and equality","ref":"/NamedTrajectories/dev/generated/man/copy_equality/#Copying-and-equality","content":" Copying and equality This page was generated using  Literate.jl ."},{"id":278,"pagetitle":"Modifying trajectories","title":"Modifying trajectories","ref":"/NamedTrajectories/dev/generated/man/modifying/#Modifying-trajectories","content":" Modifying trajectories Modifying existing trajectories can be useful for a variety of reasons. Sometimes, you may want to change the values of the states, controls, or other components of the trajectory. Other times, you may want to add or remove components from the trajectory. using NamedTrajectories Create a random trajectory with 5 time steps, a state variable  x  of dimension 3, and a control variable  u  of dimension 2 traj = rand(NamedTrajectory, 5)\ntraj.names (:x, :u) Add a new state variable  y  to the trajectory. Notice this is in-place. y_data = rand(4, 5)\nadd_component!(traj, :y, y_data)\ntraj.names (:x, :u, :y) Remove the state variable  y  from the trajectory. This is not in place. restored_traj = remove_component(traj, :y)\nrestored_traj.names (:x, :u)"},{"id":279,"pagetitle":"Modifying trajectories","title":"Adding suffixes","ref":"/NamedTrajectories/dev/generated/man/modifying/#Adding-suffixes","content":" Adding suffixes Another common operation is to add or remove a suffix from the components of a trajectory. This can be useful when you want to create a modified version of a trajectory that is related to the original trajectory in some way, or when you want to create a new trajectory that is a combination of two or more existing trajectories. For now, these tools are used to create a new trajectory. Add a suffix \"_new\" to the state variable  x modified_traj = add_suffix(traj, \"_modified\")\nmodified_traj.names (:x_modified, :y_modified, :u_modified) The modified trajectory contains the same data modified_traj.x_modified == traj.x true"},{"id":280,"pagetitle":"Modifying trajectories","title":"Merging trajectories","ref":"/NamedTrajectories/dev/generated/man/modifying/#Merging-trajectories","content":" Merging trajectories You can also merge two or more trajectories into a single trajectory. This can be useful when you want to combine data. Mergining trajectories is like taking a direct sum of the underlying data. Merge the original trajectory with the modified trajectory merged_traj = merge(traj, modified_traj)\nmerged_traj.names |> println (:x, :y, :x_modified, :y_modified, :u, :u_modified) You can also extract a specific suffix from the components of a trajectory extracted_traj = get_suffix(merged_traj, \"_modified\")\nextracted_traj.names (:x_modified, :y_modified, :u_modified) If you want the original names, you can remove the suffix original_traj = get_suffix(merged_traj, \"_modified\", remove=true)\noriginal_traj.names (:x, :y, :u)"},{"id":281,"pagetitle":"Modifying trajectories","title":"Merging with conflicts","ref":"/NamedTrajectories/dev/generated/man/modifying/#Merging-with-conflicts","content":" Merging with conflicts If there are any conflicting symbols, you can specify how to resolve the conflict. conflicting_traj = rand(NamedTrajectory, 5)\ntraj.names, conflicting_traj.names ((:x, :u, :y), (:x, :u)) In this case, keep the  u  data from the first trajectory and the  x  data from the second trajectory merged_traj = merge(traj, conflicting_traj; merge_names=(u=1, x=2,))\nprintln(merged_traj.u == traj.u, \", \", merged_traj.u == conflicting_traj.u)\nprintln(merged_traj.x == traj.x, \", \", merged_traj.x == conflicting_traj.x) true, false\nfalse, true Merged names merged_traj.names (:y, :x, :u) This page was generated using  Literate.jl ."},{"id":284,"pagetitle":"Parameters","title":"Parameters","ref":"/NamedTrajectories/dev/generated/man/params_in_struct/#Parameters","content":" Parameters NamedTrajectory.jl support passing parameters as a Tuple when construct a  NamedTrajectory . using NamedTrajectories First we need to define number of timesteps and timestep T = 10\ndt = 0.1 0.1 then build named tuple of components and data matrices. components = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = fill(dt, 1, T),\n) (x = [0.9652913874095956 0.0035916419957325862 … 0.12376367587700454 0.03136136566663039; 0.1474343170345066 0.2971764965707071 … 0.423740634414848 0.5411570158796596; 0.6361910643057109 0.7821104096872857 … 0.09193525091987298 0.8595056463202243], u = [0.9037020603777506 0.41125793587075776 … 0.15117883247265196 0.8656703475186233; 0.8738294455051968 0.14042703194907025 … 0.9970351018377838 0.658718317644453], Δt = [0.1 0.1 … 0.1 0.1]) we must specify a timestep and control variable for the trajectory. timestep = 0.1\ncontrol = :u :u some global params as a NamedTuple params = (\n    α = rand(1),\n    β = rand(1)\n) (α = [0.13353909294239386], β = [0.5751730682588971]) we can now create a  NamedTrajectory  object with parameters specification. traj = NamedTrajectory(components; timestep=timestep, controls=control, global_data=params) NamedTrajectory{Float64}([0.9652913874095956 0.0035916419957325862 … 0.12376367587700454 0.03136136566663039; 0.1474343170345066 0.2971764965707071 … 0.423740634414848 0.5411570158796596; … ; 0.8738294455051968 0.14042703194907025 … 0.9970351018377838 0.658718317644453; 0.1 0.1 … 0.1 0.1], [0.9652913874095956, 0.1474343170345066, 0.6361910643057109, 0.9037020603777506, 0.8738294455051968, 0.1, 0.0035916419957325862, 0.2971764965707071, 0.7821104096872857, 0.41125793587075776  …  0.09193525091987298, 0.15117883247265196, 0.9970351018377838, 0.1, 0.03136136566663039, 0.5411570158796596, 0.8595056463202243, 0.8656703475186233, 0.658718317644453, 0.1], 10, 0.1, 6, (x = 3, u = 2, Δt = 1, states = 4, controls = 2), NamedTuple(), NamedTuple(), NamedTuple(), NamedTuple(), (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3, 6], controls = [4, 5]), (α = [0.13353909294239386], β = [0.5751730682588971]), 2, (α = 1, β = 1), (α = 61:61, β = 62:62), (:x, :u, :Δt), (:x, :Δt), (:u,)) This page was generated using  Literate.jl ."},{"id":287,"pagetitle":"Manual","title":"Manual","ref":"/NamedTrajectories/dev/generated/manual/#Manual","content":" Manual"},{"id":288,"pagetitle":"Manual","title":"Constructors","ref":"/NamedTrajectories/dev/generated/manual/#Constructors","content":" Constructors"},{"id":289,"pagetitle":"Manual","title":"Retrieving data","ref":"/NamedTrajectories/dev/generated/manual/#Retrieving-data","content":" Retrieving data"},{"id":290,"pagetitle":"Manual","title":"Adding and removing variables","ref":"/NamedTrajectories/dev/generated/manual/#Adding-and-removing-variables","content":" Adding and removing variables"},{"id":291,"pagetitle":"Manual","title":"Updating data and bounds","ref":"/NamedTrajectories/dev/generated/manual/#Updating-data-and-bounds","content":" Updating data and bounds"},{"id":292,"pagetitle":"Manual","title":"Getting times and timesteps","ref":"/NamedTrajectories/dev/generated/manual/#Getting-times-and-timesteps","content":" Getting times and timesteps"},{"id":293,"pagetitle":"Manual","title":"Operations with other trajectories","ref":"/NamedTrajectories/dev/generated/manual/#Operations-with-other-trajectories","content":" Operations with other trajectories"},{"id":294,"pagetitle":"Manual","title":"Copying and equality","ref":"/NamedTrajectories/dev/generated/manual/#Copying-and-equality","content":" Copying and equality This page was generated using  Literate.jl ."},{"id":297,"pagetitle":"Plotting","title":"Plotting","ref":"/NamedTrajectories/dev/generated/plotting/#Plotting","content":" Plotting Visualizing trajectories is crucial for understanding the solutions of trajectory optmization problems and  NamedTrajectories  exports a  plot  function that contains a lot of functionality that is continually being added to. Makie.jl  is used as the plotting framework. An extension package is used to load plotting functionality whenever a version of Makie is installed in the current environment. For example, use  CairoMakie  to creates high quality vector graphics. The main recipe for named trajectory plotting is as follows:"},{"id":298,"pagetitle":"Plotting","title":"NamedTrajectories.Plotting.namedplot","ref":"/NamedTrajectories/dev/generated/plotting/#NamedTrajectories.Plotting.namedplot-generated-plotting","content":" NamedTrajectories.Plotting.namedplot  —  Function namedplot(traj::NamedTrajectory, name::Symbol; kwargs...) Plot a single component of a  NamedTrajectory  using Makie. The default plot type is  Series . Series attributes can be passed as keyword arguments. source The  plot  function is a wrapper around  namedplot  that allows for easy plotting of  NamedTrajectory  objects. The  plot  function has the following signature: plot(traj::NamedTrajectory, args...; kwargs...)"},{"id":299,"pagetitle":"Plotting","title":"Basic example","ref":"/NamedTrajectories/dev/generated/plotting/#Basic-example","content":" Basic example Use a Makie backend to automatically load the NamedTrajectories plotting extension using CairoMakie\nusing NamedTrajectories\n\n# define the number timestamps\nT = 100\nΔt = 0.1\nts = [0:T-1...] * Δt\n\n# define sinusoidal state trajectories\nX = zeros(3, T)\nX[1, :] = sin.(3 * 2π * ts / (2 * (T - 1) * Δt))\nX[2, :] = -sin.(5 * 2π * ts / (2 * (T - 1) * Δt))\nX[3, :] = sin.(9 * 2π * ts / (2 * (T - 1) * Δt))\n\n# define gaussian shaped controls\nU = stack(\n    [\n        exp.(-((ts .- ts[length(ts)÷3]) / 2.0).^2) .* sin.(5.0 * ts),\n        exp.(-((ts .- ts[2(length(ts)÷3)]) / 1.5).^2) .* sin.(4.0 * ts)\n    ];\n    dims=1\n)\nV = exp.(-((ts .- ts[length(ts)÷2]) ./ 1.5).^2) .* sin.(6.0 * ts)\n\n# create the trajectory\ntraj = NamedTrajectory(\n    (\n        x=X,\n        u=U,\n        v=V\n    );\n    timestep=Δt,\n    controls=(:u, :v)\n)\n\n# plot the trajectory\nplot(traj)"},{"id":300,"pagetitle":"Plotting","title":"Selectively plotting components","ref":"/NamedTrajectories/dev/generated/plotting/#Selectively-plotting-components","content":" Selectively plotting components We can selectively plot components of the trajectory by passing a  Vector  of  Symbol s to the  components  keyword argument. For example, if we only wanted to plot the state and the first control we could do the following: plot(traj, [:x, :u])"},{"id":301,"pagetitle":"Plotting","title":"Playing with transformations","ref":"/NamedTrajectories/dev/generated/plotting/#Playing-with-transformations","content":" Playing with transformations We can also apply transformations to the components of the trajectory. Transformations are performed on columns of the data. For example, if we wanted to plot absolute values of the states we could do the following: transformations = [(:x => x -> abs.(x))]\n\nplot(traj, [:x]; transformations=transformations) We can also pass multiple transformations to the same component, with selective labels and titles: # define the transformations\ntransformations = [\n    (:x => x -> [x[1] + x[2], x[3] - x[2]]),\n    (:x => x -> [x[1] - x[2], x[3] + x[2]])\n]\n\n# plot the trajectory, with only the transformation and the `u` control\nplot(traj, [:u]; transformations=transformations,) This page was generated using  Literate.jl ."},{"id":304,"pagetitle":"Quickstart Guide","title":"Quickstart Guide","ref":"/NamedTrajectories/dev/generated/quickstart/#Quickstart-Guide","content":" Quickstart Guide"},{"id":305,"pagetitle":"Quickstart Guide","title":"Getting set up","ref":"/NamedTrajectories/dev/generated/quickstart/#Getting-set-up","content":" Getting set up To install  NamedTrajectories  simply enter the package manager in the Julia REPL with  ]  and run pkg> add NamedTrajectories Then just use the package as usual with using NamedTrajectories For the following examples let's work with a simple trajectory \\[\\qty{z_t = \\mqty(x_t \\\\ u_t)}_{t=1:T}\\] where  $x_t$  is the state and  $u_t$  is the control at a time indexed by  $t$ . Together  $z_t$  is referred to as a  knot point  and a  NamedTrajectory  essentially just stores a collection of knot points and makes it easy to access the state and control variables."},{"id":306,"pagetitle":"Quickstart Guide","title":"Creating a fixed-timestep NamedTrajectory","ref":"/NamedTrajectories/dev/generated/quickstart/#Creating-a-fixed-timestep-NamedTrajectory","content":" Creating a fixed-timestep  NamedTrajectory Here we will createa a  NamedTrajectory  with a fixed timestep. This is done by passing a scalar as the  timestep  kwarg. # define the number of timesteps\nT = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n)\n\n# we must specify a timestep and control variable for the trajectory\ntimestep = 0.1\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(data; timestep=timestep, controls=control)\n\n# we can return the names of the stored variables\ntraj.names (:x, :u) Let's plot this trajectory Use a Makie backend to automatically load the NamedTrajectories plotting extension using CairoMakie\n\nplot(traj)"},{"id":307,"pagetitle":"Quickstart Guide","title":"Creating a variable-timestep NamedTrajectory","ref":"/NamedTrajectories/dev/generated/quickstart/#Creating-a-variable-timestep-NamedTrajectory","content":" Creating a variable-timestep  NamedTrajectory Here we will create a  NamedTrajectory  with a variable timestep. This is done by passing a  Symbol , corresponding to component of the data, as the  timestep  kwarg. # define the number of timesteps\nT = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = rand(T),\n)\n\n# we must specify a timestep and control variable for the NamedTrajectory\ntimestep = :Δt\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(data; timestep=timestep, controls=control)\n\n# we can return the names of the stored variables\ntraj.names (:x, :u, :Δt)"},{"id":308,"pagetitle":"Quickstart Guide","title":"Adding more problem data","ref":"/NamedTrajectories/dev/generated/quickstart/#Adding-more-problem-data","content":" Adding more problem data In many settings we will want to add problem data to our  NamedTrajectory  – e.g. bounds, initial values, final values, and goal values. This is realized by passing NamedTuples containing this data. # define the number of timesteps\nT = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = rand(T),\n)\n\n# define initial values\ninitial = (\n    x = [1.0, 0.0, 0.0],\n    u = [0.0, 0.0],\n)\n\n# define final value, here just on the control\nfinal = (\n    u = [0.0, 0.0],\n)\n\n# define bounds\nbounds = (\n    x = 1.0,\n    u = 1.0\n)\n\n# set a goal for the state\ngoal = (\n    x = [0.0, 0.0, 1.0],\n)\n\n# we must specify a timestep and control variable for the NamedTrajectory\ntimestep = :Δt\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(\n    data;\n    timestep=timestep,\n    controls=control,\n    initial=initial,\n    final=final,\n    bounds=bounds,\n    goal=goal\n)\n\n# we can then show the bounds\ntraj.goal (x = [0.0, 0.0, 1.0],)"},{"id":309,"pagetitle":"Quickstart Guide","title":"Retrieving data","ref":"/NamedTrajectories/dev/generated/quickstart/#Retrieving-data","content":" Retrieving data There are a number of ways to access data, for example traj.x 3×10 Matrix{Float64}:\n 0.998502  0.0297709  0.0701595  …  0.851058   0.477934   0.663519\n 0.439189  0.816925   0.204529      0.0209745  0.553365   0.247327\n 0.474356  0.379712   0.121581      0.730131   0.0940124  0.0902769 returns the data matrix associated with the state variable  x . traj.data 6×10 reshape(view(::Vector{Float64}, :), 6, 10) with eltype Float64:\n 0.998502  0.0297709  0.0701595  …  0.851058   0.477934   0.663519\n 0.439189  0.816925   0.204529      0.0209745  0.553365   0.247327\n 0.474356  0.379712   0.121581      0.730131   0.0940124  0.0902769\n 0.967287  0.8908     0.382976      0.396278   0.3455     0.236385\n 0.19991   0.432543   0.37186       0.256111   0.311514   0.383987\n 0.54402   0.422182   0.450664   …  0.484956   0.985106   0.992298 returns the all of the data as a matrix where each column is a knot point. traj.datavec 60-element Vector{Float64}:\n 0.9985023806579882\n 0.4391893400354603\n 0.47435630045016586\n 0.9672868578433109\n 0.19990952239193782\n 0.5440202746453572\n 0.02977094557712301\n 0.8169250257763605\n 0.379711832082813\n 0.8908003414436059\n ⋮\n 0.34550044690212567\n 0.31151394766133644\n 0.9851057252019653\n 0.6635190471373704\n 0.24732707648874608\n 0.09027687731134837\n 0.23638474542308485\n 0.3839870454401004\n 0.9922977722811551 returns the all of the data as a view of the data matrix as a vector – useful for passing data to solvers. traj[1] KnotPoint(1, [0.9985023806579882, 0.4391893400354603, 0.47435630045016586, 0.9672868578433109, 0.19990952239193782, 0.5440202746453572], 0.5440202746453572, (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3], controls = [4, 5, 6]), (:x, :u, :Δt), (:u, :Δt)) returns a  KnotPoint . traj[1].x 3-element Vector{Float64}:\n 0.9985023806579882\n 0.4391893400354603\n 0.47435630045016586 returns the state at the first knot point. get_times(traj) 10-element Vector{Float64}:\n 0.0\n 0.5440202746453572\n 0.9662019926780427\n 1.4168658351728893\n 2.040507802707062\n 2.4582014978244096\n 3.014136166436616\n 3.204145120531961\n 3.689101546039817\n 4.674207271241782 returns the times of the knot points. get_timesteps(traj) 10-element Vector{Float64}:\n 0.5440202746453572\n 0.42218171803268556\n 0.4506638424948466\n 0.6236419675341726\n 0.41769369511734744\n 0.5559346686122066\n 0.1900089540953449\n 0.4849564255078559\n 0.9851057252019653\n 0.9922977722811551 returns the timesteps of the knot points, as vector."},{"id":310,"pagetitle":"Quickstart Guide","title":"Retrieving metadata","ref":"/NamedTrajectories/dev/generated/quickstart/#Retrieving-metadata","content":" Retrieving metadata We can also retrieve metadata about the trajectory, for example traj.names (:x, :u, :Δt) returns the names of the variables stored in the trajectory. traj.dims (x = 3, u = 2, Δt = 1, states = 3, controls = 3) returns the dimensions of the variables stored in the trajectory. traj.T 10 returns the number of knot points in the trajectory. traj.components (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3], controls = [4, 5, 6]) returns the components of the trajectory. This page was generated using  Literate.jl ."},{"id":313,"pagetitle":"Library","title":"API","ref":"/NamedTrajectories/dev/lib/#API","content":" API"},{"id":314,"pagetitle":"Library","title":"NamedTrajectory methods","ref":"/NamedTrajectories/dev/lib/#NamedTrajectory-methods","content":" NamedTrajectory methods"},{"id":315,"pagetitle":"Library","title":"Base.:==","ref":"/NamedTrajectories/dev/lib/#Base.:==-Tuple{NamedTrajectory, NamedTrajectory}","content":" Base.:==  —  Method :(==)(traj1::NamedTrajectory, traj2::NamedTrajectory) Check if trajectories are equal w.r.t. using  Base.:(==) source"},{"id":316,"pagetitle":"Library","title":"Base.copy","ref":"/NamedTrajectories/dev/lib/#Base.copy-Tuple{NamedTrajectory}","content":" Base.copy  —  Method copy(::NamedTrajectory) Returns a copy of the trajectory. source"},{"id":317,"pagetitle":"Library","title":"Base.getindex","ref":"/NamedTrajectories/dev/lib/#Base.getindex-Tuple{NamedTrajectory, AbstractVector{Int64}}","content":" Base.getindex  —  Method getindex(traj, ts::AbstractVector{Int})::Vector{KnotPoint} Returns the knot points at times  ts . source"},{"id":318,"pagetitle":"Library","title":"Base.getindex","ref":"/NamedTrajectories/dev/lib/#Base.getindex-Tuple{NamedTrajectory, Int64}","content":" Base.getindex  —  Method getindex(traj, t::Int)::KnotPoint Returns the knot point at time  t . source"},{"id":319,"pagetitle":"Library","title":"Base.getindex","ref":"/NamedTrajectories/dev/lib/#Base.getindex-Tuple{NamedTrajectory, Symbol}","content":" Base.getindex  —  Method getindex(traj, symb::Symbol) Dispatches indexing of trajectories as either accessing a component or a property via  getproperty . source"},{"id":320,"pagetitle":"Library","title":"Base.getproperty","ref":"/NamedTrajectories/dev/lib/#Base.getproperty-Tuple{NamedTrajectory, Symbol}","content":" Base.getproperty  —  Method getproperty(traj, symb::Symbol) Returns the component of the trajectory with name  symb  or the property of the trajectory with name  symb . source"},{"id":321,"pagetitle":"Library","title":"Base.isequal","ref":"/NamedTrajectories/dev/lib/#Base.isequal-Tuple{NamedTrajectory, NamedTrajectory}","content":" Base.isequal  —  Method isequal(traj1::NamedTrajectory, traj2::NamedTrajectory) Check if trajectories are equal w.r.t. data using  Base.isequal source"},{"id":322,"pagetitle":"Library","title":"Base.lastindex","ref":"/NamedTrajectories/dev/lib/#Base.lastindex-Tuple{NamedTrajectory}","content":" Base.lastindex  —  Method lastindex(traj::NamedTrajectory) Returns the final time index of the trajectory. source"},{"id":323,"pagetitle":"Library","title":"Base.length","ref":"/NamedTrajectories/dev/lib/#Base.length-Tuple{NamedTrajectory}","content":" Base.length  —  Method length(::NamedTrajectory) Returns the length of all variables of the trajectory, including global data. TODO: Should global data be in length? source"},{"id":324,"pagetitle":"Library","title":"Base.merge","ref":"/NamedTrajectories/dev/lib/#Base.merge-Tuple{NamedTrajectory, NamedTrajectory}","content":" Base.merge  —  Method merge(traj1::NamedTrajectory, traj2::NamedTrajectory)\nmerge(trajs::AbstractVector{<:NamedTrajectory}) Returns a new NamedTrajectory object by merging  NamedTrajectory  objects.  Merge names are used to specify which components to merge by index. If no merge names are provided, all components are merged and name collisions are not allowed. If merge names are provided, the names are merged using the data from the index provided in the merge names. Joined  NamedTrajectory  objects must have the same timestep. If a free time trajectory is desired, setting the keyword argument  free_time=true  will construct the a component for the timestep. In this case, the timestep symbol must be provided.  Arguments traj1::NamedTrajectory : The first  NamedTrajectory  object. traj2::NamedTrajectory : The second  NamedTrajectory  object. free_time::Bool=false : Whether to construct a free time problem. timestep_name::Symbol=:Δt : The timestep symbol to use for free time problems. merge_names::Union{Nothing, NamedTuple{<:Any, <:Tuple{Vararg{Int}}}}=nothing : The names to merge by index. source"},{"id":325,"pagetitle":"Library","title":"Base.setproperty!","ref":"/NamedTrajectories/dev/lib/#Base.setproperty!-Tuple{NamedTrajectory, Symbol, Any}","content":" Base.setproperty!  —  Method setproperty!(traj, name::Symbol, val::Any) Dispatches setting properties of trajectories as either setting a component or a property via  setfield!  or  update! . source"},{"id":326,"pagetitle":"Library","title":"Base.size","ref":"/NamedTrajectories/dev/lib/#Base.size-Tuple{NamedTrajectory}","content":" Base.size  —  Method size(traj::NamedTrajectory) = (dim = traj.dim, T = traj.T) Returns the size of the trajectory (dim, T), excluding global data. TODO: Should global data be in size? source"},{"id":327,"pagetitle":"Library","title":"Base.vec","ref":"/NamedTrajectories/dev/lib/#Base.vec-Tuple{NamedTrajectory}","content":" Base.vec  —  Method vec(::NamedTrajectory) Returns all variables of the trajectory as a vector, Z⃗. source"},{"id":328,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_component!","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.add_component!-Tuple{NamedTrajectory, Symbol, AbstractVecOrMat{Float64}}","content":" NamedTrajectories.MethodsNamedTrajectory.add_component!  —  Method add_component!(traj, name::Symbol, data::AbstractVecOrMat; type={:state, :control, :slack}) Add a component to the trajectory. This function resizes the trajectory, so global components and components must be adjusted. source"},{"id":329,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_suffix","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.add_suffix","content":" NamedTrajectories.MethodsNamedTrajectory.add_suffix  —  Function add_suffix(obj::T, suffix::String) Add the suffix to the symbols of the object. source"},{"id":330,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_component_names","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.get_component_names-Tuple{NamedTrajectory, AbstractVector{<:Int64}}","content":" NamedTrajectories.MethodsNamedTrajectory.get_component_names  —  Method get_component_names(traj::NamedTrajectory, comps::AbstractVector{<:Int}) Returns the name of the component with the given indices. If only one component is found, the name is returned as a single symbol. Else, the names are returned as a vector of symbols. The filter requires that the components are a complete subset of the given indices, so that a partial match is excluded from the returned names. source"},{"id":331,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_components","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.get_components-Tuple{Union{Tuple, AbstractVector}, NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_components  —  Method get_components(::NamedTrajectory) Returns a NamedTuple containing the names and corresponding data matrices of the trajectory. source"},{"id":332,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_duration","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.get_duration-Tuple{NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_duration  —  Method get_duration(::NamedTrajectory) Returns the duration of a trajectory. source"},{"id":333,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_suffix","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.get_suffix","content":" NamedTrajectories.MethodsNamedTrajectory.get_suffix  —  Function get_suffix(obj::T, suffix::String; remove::Bool=false) Get the data with the suffix from the object. Remove the suffix if  remove=true . source"},{"id":334,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_times","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.get_times-Tuple{NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_times  —  Method get_times(traj)::Vector{Float64} Returns the times of a trajectory as a vector. source"},{"id":335,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_timesteps","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.get_timesteps-Tuple{NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_timesteps  —  Method get_timesteps(::NamedTrajectory) Returns the timesteps of a trajectory as a vector. source"},{"id":336,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.merge_outer","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.merge_outer-Tuple{AbstractVector}","content":" NamedTrajectories.MethodsNamedTrajectory.merge_outer  —  Method merge_outer(objs::AbstractVector{<:Any}) Merge objects. An error is reported if a key collision is detected. source"},{"id":337,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_component","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.remove_component-Tuple{NamedTrajectory, Symbol}","content":" NamedTrajectories.MethodsNamedTrajectory.remove_component  —  Method remove_component(traj, name::Symbol) Remove a component from the trajectory. source"},{"id":338,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_components","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.remove_components-Tuple{NamedTrajectory, AbstractVector{<:Symbol}}","content":" NamedTrajectories.MethodsNamedTrajectory.remove_components  —  Method remove_components(traj, names::Vector{Symbol}) Remove a set of components from the trajectory. source"},{"id":339,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_suffix","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.remove_suffix","content":" NamedTrajectories.MethodsNamedTrajectory.remove_suffix  —  Function remove_suffix(obj::T, suffix::String) Remove the suffix from the symbols of the object. source"},{"id":340,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update!","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.update!-Tuple{NamedTrajectory, AbstractVector{Float64}}","content":" NamedTrajectories.MethodsNamedTrajectory.update!  —  Method update!(traj, datavec::AbstractVector{Float64}) Update the trajectory with a new datavec. source"},{"id":341,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update!","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.update!-Tuple{NamedTrajectory, Symbol, AbstractMatrix{Float64}}","content":" NamedTrajectories.MethodsNamedTrajectory.update!  —  Method update!(traj, name::Symbol, data::AbstractMatrix{Float64}) Update a component of the trajectory. source"},{"id":342,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update_bound!","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.update_bound!","content":" NamedTrajectories.MethodsNamedTrajectory.update_bound!  —  Function update_bound!(traj, name::Symbol, data::Real)\nupdate_bound!(traj, name::Symbol, data::AbstractVector{<:Real})\nupdate_bound!(traj, name::Symbol, data::Tuple{R, R} where R <: Real) Update the bound of a component of the trajectory. source"},{"id":343,"pagetitle":"Library","title":"Random trajectory methods","ref":"/NamedTrajectories/dev/lib/#Random-trajectory-methods","content":" Random trajectory methods"},{"id":344,"pagetitle":"Library","title":"Base.rand","ref":"/NamedTrajectories/dev/lib/#Base.rand-Tuple{Type{NamedTrajectory}, Int64}","content":" Base.rand  —  Method rand(\n    ::Type{NamedTrajectory},\n    T::Int;\n    timestep_value::Float64=1.0,\n    timestep_name::Symbol=:Δt,\n    free_time::Bool=false,\n    timestep::Union{Float64,Symbol}=free_time ? timestep_name : timestep_value,\n    state_dim::Int=3,\n    control_dim::Int=2\n) Create a random  NamedTrajectory  with  T  time steps, a state variable  x  of dimension   state_dim , and a control variable  u  of dimension  control_dim . If  free_time  is   true , the time step is a symbol  timestep_name  and the time step value is   timestep_value . Otherwise, the time step is a number  timestep_value . source"},{"id":345,"pagetitle":"Library","title":"Struct Methods","ref":"/NamedTrajectories/dev/lib/#Struct-Methods","content":" Struct Methods"},{"id":346,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Type NamedTrajectory constructor source"},{"id":347,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Tuple{NamedTuple}","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Method NamedTrajectory(component_data; kwargs...)\n\n# Arguments\n- `component_data::NamedTuple{names, <:Tuple{Vararg{vals}}} where {names, vals <: AbstractMatrix{R}}`: Components data.\n- `kwargs...`: The other key word arguments. source"},{"id":348,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{NamedTuple{names, <:Tuple{Vararg{vals}}} where {names, vals<:AbstractMatrix{R}}}, Tuple{R}} where R<:Real","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Method NamedTrajectory(component_data; controls=(), timestep=nothing, bounds, initial, final, goal)\n\n# Arguments\n- `component_data::NamedTuple{names, <:Tuple{Vararg{vals}}} where {names, vals <: AbstractMatrix{R}}`: Components data.\n- `controls`: The control variable in component_data, should be type of `Symbol` among `component_data`.\n- `timestep`: Discretizing time step in `component_data`, should be type of `Symbol` among `component_data`.\n- `bounds`: Bounds of the trajectory.\n- `initial`: Initial values.\n- `final`: Final values.\n- `goal`: Goal for the states. source"},{"id":349,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{R}, Tuple{AbstractMatrix{R}, NamedTrajectory}} where R<:Real","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Method NamedTrajectory(data, traj)\n\n# Arguments\n- `data`: Trajectory data.\n- `traj`: Constructed `NamedTrajectory`. source"},{"id":350,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{R}, Tuple{AbstractMatrix{R}, NamedTuple{names, <:Tuple{Vararg{AbstractVector{Int64}}}} where names}} where R<:Real","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Method NamedTrajectory(data, componets; kwargs...)\n\n# Arguments\n- `data::AbstractMatrix{R}`: Trajectory data.\n- `components::NamedTuple{names, <:Tuple{Vararg{AbstractVector{Int}}}} where names`: components data.\n- `kwargs...` : The other key word arguments. source"},{"id":351,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{R}, Tuple{AbstractVector{R}, Int64, NamedTuple{names, <:Tuple{Vararg{AbstractVector{Int64}}}} where names}} where R<:Real","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Method NamedTrajectory(datavec, T, components) source"},{"id":352,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{R}, Tuple{AbstractVector{R}, NamedTrajectory}} where R<:Real","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Method NamedTrajectory(component_data; controls=(), timestep=nothing, bounds, initial, final, goal)\n\n# Arguments\n- `datavec::AbstractVector{R} where R <: Real`: Trajectory data.\n- `traj`: Constructed `NamedTrajectory`. source"},{"id":353,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{R}, Tuple{NamedTuple{names, <:Tuple{Vararg{AbstractMatrix{R}}}} where names, NamedTrajectory}} where R<:Real","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Method NamedTrajectory(component_data; controls=(), timestep=nothing, bounds, initial, final, goal)\n\n# Arguments\n- `comps::NamedTuple{names, <:Tuple{Vararg{AbstractMatrix{R}}}} where {names}`: components data.\n- `traj`: Constructed NamedTrajectory.\n- `goal`: Goal for the states. source"},{"id":354,"pagetitle":"Library","title":"Trajectory Utilities","ref":"/NamedTrajectories/dev/lib/#Trajectory-Utilities","content":" Trajectory Utilities"},{"id":355,"pagetitle":"Library","title":"NamedTrajectories.Utils.derivative","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.Utils.derivative-Tuple{AbstractMatrix, AbstractVecOrMat}","content":" NamedTrajectories.Utils.derivative  —  Method derivative(X::AbstractMatrix, Δt::AbstractVecOrMat)\nderivative(X::AbstractMatrix, Δt::Float64) Compute the derivative of the data matrix  X . source"},{"id":356,"pagetitle":"Library","title":"NamedTrajectories.Utils.integral","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.Utils.integral-Tuple{AbstractMatrix, AbstractVector}","content":" NamedTrajectories.Utils.integral  —  Method integral(X::AbstractMatrix, Δt::AbstractVector)\nintegral(X::AbstractMatrix, Δt::Float64) Compute the integral of the data matrix  X . source"},{"id":359,"pagetitle":"Home","title":"TrajectoryIndexingUtils","ref":"/TrajectoryIndexingUtils/dev/#TrajectoryIndexingUtils","content":" TrajectoryIndexingUtils Documentation for  TrajectoryIndexingUtils ."},{"id":362,"pagetitle":"Home","title":"PiccoloPlots.jl","ref":"/PiccoloPlots/dev/#PiccoloPlots.jl","content":" PiccoloPlots.jl PiccoloPlots.jl  is designed to hold plotting recipes for the Piccolo.jl package. It utilzes the  plot  method of the  NamedTrajectories.jl ."},{"id":363,"pagetitle":"Home","title":"Installation","ref":"/PiccoloPlots/dev/#Installation","content":" Installation PiccoloPlots.jl can be installed using the Julia package manager. From the Julia REPL, type  ]  to enter the Pkg REPL mode and run: julia> ] add PiccoloPlots"},{"id":364,"pagetitle":"Home","title":"Usage","ref":"/PiccoloPlots/dev/#Usage","content":" Usage As a simple example, we provide the  plot_unitary_populations  function which plots the populations of select columns of the unitary matrix. This can be employed as follows: using NamedTrajectories\nusing PiccoloQuantumObjects\nusing PiccoloPlots\n\n# Define the Hamiltonian H = X + a_1(t)Z + a_2(t)Y\nH_drift = PAULIS[:X]\nH_drives = [PAULIS[:Z], PAULIS[:Y]]\n\n# Generate control trajectory \nN = 100\n\nΔt = 0.1\nts = collect(0:Δt:Δt*(N-1))\n\na = 0.1 * randn(length(H_drives), length(ts))\n\n# Generate the unitaries\nUs = exp.(-im * [(H_drift + sum(a[:, k] .* H_drives)) * ts[k] for k = 1:N])\n\n# Create a NamedTrajectory\ntraj = NamedTrajectory(\n    (\n        Ũ⃗ = hcat(operator_to_iso_vec.(Us)...),\n        a = a\n    );\n    controls = :a,\n    timestep = Δt\n)\n\n# Plot the populations of the first and second qubits\nplot_unitary_populations(traj)"},{"id":367,"pagetitle":"Quickstart Guide","title":"Quickstart Guide","ref":"/PiccoloPlots/dev/generated/quickstart/#Quickstart-Guide","content":" Quickstart Guide Here is a simple example where we set up a  NamedTrajectory  with some dummy data and plot populations of the columns of the unitary matrix. First we will load some of the necessary packages: using CairoMakie\nusing NamedTrajectories\nusing PiccoloQuantumObjects\nusing PiccoloPlots Next we will define some Hamiltonians H_drives = [PAULIS[:Z], PAULIS[:Y]]\nH_drift = PAULIS[:X] 2×2 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im Now we will generate some dummy control data N = 100\nΔt = 0.1\nts = 0:Δt:Δt*(N-1)\nA = 0.1 * randn(length(H_drives), length(ts)) 2×100 Matrix{Float64}:\n -0.0729471   0.0520853  0.166453   …  -0.0579562  0.109739   0.0683121\n -0.0425412  -0.196199   0.0229356      0.191908   0.0954277  0.136839 Now we will generate the unitaries Us = exp.(-im * [(H_drift + sum(A[:, k] .* H_drives)) * ts[k] for k = 1:N])\nUs[1] 2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0-0.0im  1.0+0.0im And create the trajectory traj = NamedTrajectory(\n    (\n        Ũ⃗ = hcat(operator_to_iso_vec.(Us)...), # here we store the isomorphisms\n        a = A\n    );\n    controls = :a,\n    timestep = Δt\n) NamedTrajectories.StructNamedTrajectory.NamedTrajectory{Float64}([1.0 0.9947984808048728 … -0.8877740837539883 -0.830751606885207; 0.0 -0.019585875947993835 … -0.04346616106797223 -0.07529470822964295; … ; -0.07294705659365236 0.05208534176610095 … 0.10973862374217712 0.06831206198410673; -0.042541154520594544 -0.19619905530640608 … 0.0954276555124835 0.13683850765977792], [1.0, 0.0, 0.0, -0.0, 0.0, 1.0, 0.0, 0.0, -0.07294705659365236, -0.042541154520594544  …  -0.830751606885207, -0.07529470822964295, 0.03758837233483275, 0.5502450261796805, 0.0752947082296429, -0.830751606885207, 0.5502450261796806, -0.03758837233483279, 0.06831206198410673, 0.13683850765977792], 100, 0.1, 10, (Ũ⃗ = 8, a = 2, states = 8, controls = 2), NamedTuple(), NamedTuple(), NamedTuple(), NamedTuple(), (Ũ⃗ = 1:8, a = 9:10, states = [1, 2, 3, 4, 5, 6, 7, 8], controls = [9, 10]), NamedTuple(), 0, NamedTuple(), NamedTuple(), (:Ũ⃗, :a), (:Ũ⃗,), (:a,)) Finally we will plot the populations plot_unitary_populations(traj) We can also only plot the first column (or any other subset of columns) plot_unitary_populations(traj; unitary_columns=[1]) This page was generated using  Literate.jl ."},{"id":370,"pagetitle":"Library","title":"Library","ref":"/PiccoloPlots/dev/lib/#Library","content":" Library"},{"id":371,"pagetitle":"Library","title":"PiccoloPlots.QuantumObjectPlots.plot_unitary_populations","ref":"/PiccoloPlots/dev/lib/#PiccoloPlots.QuantumObjectPlots.plot_unitary_populations-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" PiccoloPlots.QuantumObjectPlots.plot_unitary_populations  —  Method plot_unitary_populations(\n    traj::NamedTrajectory;\n    unitary_columns::AbstractVector{Int}=1:2,\n    unitary_name::Symbol=:Ũ⃗,\n    control_name::Symbol=:a,\n    kwargs...\n) Plot the populations of the unitary columns of the unitary matrix in the trajectory.  kwargs  are passed to  NamedTrajectories.plot . Keyword Arguments unitary_columns::AbstractVector{Int} : The columns of the unitary matrix to plot the populations of. Default is  1:2 . unitary_name::Symbol : The name of the unitary matrix in the trajectory. Default is  :Ũ⃗ . control_name::Symbol : The name of the control in the trajectory. Default is  :a . kwargs... : Additional keyword arguments passed to  NamedTrajectories.plot . source"}]