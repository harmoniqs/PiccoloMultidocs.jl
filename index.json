[{"id":3,"pagetitle":"Home","title":"PiccoloQuantumObjects","ref":"/PiccoloQuantumObjects/stable/#PiccoloQuantumObjects","content":" PiccoloQuantumObjects Documentation for  PiccoloQuantumObjects ."},{"id":6,"pagetitle":"Isomorphisms","title":"Isomorphisms","ref":"/PiccoloQuantumObjects/stable/generated/isomorphisms/#Isomorphisms","content":" Isomorphisms using PiccoloQuantumObjects\nusing SparseArrays # for visualization Linear algebra operations on quantum objects are often performed on real vectors and matrices. We provide isomorphisms to convert between complex and real representations of quantum objects. These isomorphisms are used internally by the  QuantumSystem  type to perform quantum dynamics."},{"id":7,"pagetitle":"Isomorphisms","title":"Quantum state isomorphisms","ref":"/PiccoloQuantumObjects/stable/generated/isomorphisms/#Quantum-state-isomorphisms","content":" Quantum state isomorphisms ket_to_iso  is the real isomorphism of a quantum state  ψ ∈ ℂⁿ iso_to_ket  is the inverse isomorphism of a real vector  ψ̃ ∈ ℝ²ⁿ ψ = [1; 2] + im * [3; 4]\nψ̃ = ket_to_iso(ψ) 4-element Vector{Int64}:\n 1\n 2\n 3\n 4 iso_to_ket(ψ̃) 2-element Vector{Complex{Int64}}:\n 1 + 3im\n 2 + 4im"},{"id":8,"pagetitle":"Isomorphisms","title":"Quantum operator isomorphisms","ref":"/PiccoloQuantumObjects/stable/generated/isomorphisms/#Quantum-operator-isomorphisms","content":" Quantum operator isomorphisms We often need to convert a complex matrix  U  to a real vector  Ũ⃗ . We provoide the following isomorphisms to convert between the two representations. iso_vec_to_operator (Ũ⃗::AbstractVector{ℝ}) operator_to_iso_vec (U::AbstractVector{ℂ}) iso_vec_to_iso_operator (Ũ⃗::AbstractVector{ℝ}) iso_operator_to_iso_vec (Ũ::AbstractMatrix{ℝ}) iso_operator_to_operator (Ũ::AbstractMatrix{ℝ}) operator_to_iso_operator (U::AbstractMatrix{ℂ}) In additon, we provide  mat (x::AbstractVector)  to convert a vector  x  into a square matrix, as the inverse to Base's  vec . Julia uses column-major order. U = [1 5; 2 6] + im * [3 7; 4 8]\nŨ⃗ = operator_to_iso_vec(U) 8-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8 iso_vec_to_operator(Ũ⃗) 2×2 Matrix{Complex{Int64}}:\n 1+3im  5+7im\n 2+4im  6+8im"},{"id":9,"pagetitle":"Isomorphisms","title":"Density matrix isomorphisms","ref":"/PiccoloQuantumObjects/stable/generated/isomorphisms/#Density-matrix-isomorphisms","content":" Density matrix isomorphisms The isomorphisms for density matrices are: density_to_iso_vec (ρ::AbstractMatrix{ℂ}) iso_vec_to_density (ρ̃::AbstractVector{ℝ}) Warning The isomorphism  density_to_iso_vec  is not the same as  operator_to_iso_vec . ρ = [1 2; 3 4] + im * [5 6; 7 8]\nρ̃⃗ = density_to_iso_vec(ρ) 8-element Vector{Int64}:\n 1\n 3\n 2\n 4\n 5\n 7\n 6\n 8"},{"id":10,"pagetitle":"Isomorphisms","title":"Quantum dynamics isomorphisms","ref":"/PiccoloQuantumObjects/stable/generated/isomorphisms/#Quantum-dynamics-isomorphisms","content":" Quantum dynamics isomorphisms The quantum dynamics isomorphisms, which correspond to these state transformations, are handled internally by the  QuantumSystem  type. The  Isomorphisms.iso  isomorphism of a Hamiltonian  $H$  is: \\[\\text{iso}(H) := \\widetilde{H} = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] where  $\\Im(H)$  and  $\\Re(H)$  are the imaginary and real parts of  $H$  and the tilde indicates the standard isomorphism of a complex valued matrix: \\[\\widetilde{H} := \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] Hence, the generator  Isomorphisms.G  associated to a Hamiltonian  $H$  is: \\[G(H) := \\text{iso}(- i \\widetilde{H}) = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Im(H) - \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Re(H)\\] This page was generated using  Literate.jl ."},{"id":13,"pagetitle":"Quantum Objects","title":"Quantum Objects","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#Quantum-Objects","content":" Quantum Objects using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n⊗ = kron; Quantum states and operators are represented as complex vectors and matrices. We provide a number of convenient ways to construct these objects. We also provide some tools for working with these objects, such as embedding operators in larger Hilbert spaces and selecting subspace indices."},{"id":14,"pagetitle":"Quantum Objects","title":"Quantum states","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#Quantum-states","content":" Quantum states We can construct quantum states from bitstrings or string representations. The string representations use atomic notation (ground state  g , excited state  e , etc.). Ground state in a 2-level system. ket_from_string(\"g\", [2]) 2-element Vector{ComplexF64}:\n 1.0 + 0.0im\n 0.0 + 0.0im Superposition state coupled to a ground state in two 2-level systems. ket_from_string(\"(g+e)g\", [2,2]) 4-element Vector{ComplexF64}:\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im |01⟩  in a 2-qubit system. ket_from_bitstring(\"01\") 4-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im"},{"id":15,"pagetitle":"Quantum Objects","title":"Quantum operators","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#Quantum-operators","content":" Quantum operators Frequently used operators are provided in  PAULIS  and  GATES ."},{"id":16,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.Gates.GATES","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.Gates.GATES-generated-quantum_objects","content":" PiccoloQuantumObjects.Gates.GATES  —  Constant A constant dictionary  GATES  containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix. GATES[:I]  - Identity: Leaves the state unchanged. GATES[:X]  - Pauli-X (NOT): Flips the qubit state. GATES[:Y]  - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere. GATES[:Z]  - Pauli-Z: Flips the phase of the qubit state. GATES[:H]  - Hadamard: Creates superposition by transforming basis states. GATES[:CX]  - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1⟩. GATES[:CZ]  - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1⟩. GATES[:XI]  - Complex: A gate for complex operations. GATES[:sqrtiSWAP]  - Square root of iSWAP: Partially swaps two qubits with a phase. source Quantum operators can also be constructed from strings. operator_from_string(\"X\") 2×2 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im operator_from_string(\"XZ\") 4×4 Matrix{ComplexF64}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im Annihilation and creation operators are provided for oscillator systems. a = annihilate(3) 3×3 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im      0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.41421+0.0im\n 0.0+0.0im  0.0+0.0im      0.0+0.0im a⁺ = create(3) 3×3 Matrix{ComplexF64}:\n 0.0-0.0im      0.0-0.0im  0.0-0.0im\n 1.0-0.0im      0.0-0.0im  0.0-0.0im\n 0.0-0.0im  1.41421-0.0im  0.0-0.0im a'a 3×3 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  2.0+0.0im"},{"id":17,"pagetitle":"Quantum Objects","title":"Random operators","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#Random-operators","content":" Random operators The  haar_random  function draws random unitary operators according to the Haar measure. haar_random(3) 3×3 Matrix{ComplexF64}:\n   0.322532+0.417251im  0.0934113+0.432683im   -0.0488445+0.723567im\n -0.0170277+0.186577im    0.73275-0.500004im    -0.414894+0.0763901im\n  -0.790534+0.248657im   0.110747-0.0697756im    0.473358+0.268375im If we want to generate random operations that are close to the identity, we can use the  haar_identity  function. haar_identity(2, 0.1) 2×2 Matrix{ComplexF64}:\n 0.991421-0.00439175im  -0.130514-0.00552259im\n 0.130615-0.00203104im    0.99095+0.030898im A smaller radius means the random operator is closer to the identity. haar_identity(2, 0.01) 2×2 Matrix{ComplexF64}:\n     0.999998+0.00202651im  0.000189584+9.40408e-6im\n -0.000189617+8.70744e-6im     0.999999+0.00164773im"},{"id":18,"pagetitle":"Quantum Objects","title":"Embedded operators","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#Embedded-operators","content":" Embedded operators Sometimes we want to embed a quantum operator into a larger Hilbert space,  $\\mathcal{H}$ , which we decompose into subspace and leakage components: \\[    \\mathcal{H} = \\mathcal{H}_{\\text{subspace}} \\oplus \\mathcal{H}_{\\text{leakage}},\\] In quantum computing, the computation is encoded in a  subspace , while the remaining  leakage  states should be avoided."},{"id":19,"pagetitle":"Quantum Objects","title":"The embed and unembed functions","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#The-embed-and-unembed-functions","content":" The  embed  and  unembed  functions The  embed  function allows to embed a quantum operator in a larger Hilbert space."},{"id":20,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.embed-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.embed  —  Function embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int) Embed an  operator  in the  subspace  of a larger matrix of size  levels x levels . source embed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator) Embed the  subspace_operator  in the subspace of a larger  embedded_operator . source The  unembed  function allows to unembed a quantum operator from a larger Hilbert space."},{"id":21,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.unembed-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Function unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}) Unembed a subspace operator from the  matrix . This is equivalent to calling   matrix[subspace, subspace] . source unembed(embedded_op::EmbeddedOperator)::Matrix{ComplexF64} Unembed an embedded operator, returning the original operator. source unembed(op::AbstractMatrix, embedded_op::EmbeddedOperator) Unembed a sub-matrix from the  op  at the subspace defined by  embedded_op . source Embed a two-level X gate into a multilevel system. levels = 3\nX = GATES[:X]\nsubspace_indices = 1:2\nX_embedded = embed(X, subspace_indices, levels) 3×3 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im  0.0+0.0im\n 1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im Unembed to retrieve the original operator. X_original = unembed(X_embedded, subspace_indices) 2×2 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im"},{"id":22,"pagetitle":"Quantum Objects","title":"The EmbeddedOperator type","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#The-EmbeddedOperator-type","content":" The  EmbeddedOperator  type The  EmbeddedOperator  type stores information about an operator embedded in the subspace of a larger quantum system."},{"id":23,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Type EmbeddedOperator Embedded operator type to represent an operator embedded in a subspace of a larger  quantum system. Fields operator::Matrix{ComplexF64} : Embedded operator of size     prod(subsystem_levels) x prod(subsystem_levels) . subspace::Vector{Int} : Indices of the subspace the operator is embedded in. subsystem_levels::Vector{Int} : Levels of the subsystems in the composite system. source We construct an embedded operator in the same manner as the  embed  function."},{"id":24,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{Matrix{<:Number}, AbstractVector{Int64}, AbstractVector{Int64}}-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int}) Create an embedded operator. The  operator  is embedded at the  subspace  of the system spanned by the  subsystem_levels . source Embed an X gate in the first qubit's subspace within two 3-level systems. gate = GATES[:X] ⊗ GATES[:I]\nsubsystem_levels = [3, 3]\nsubspace_indices = get_subspace_indices([1:2, 1:2], subsystem_levels)\nembedded_operator = EmbeddedOperator(gate, subspace_indices, subsystem_levels) EmbeddedOperator(ComplexF64[0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im; … ; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im], [1, 2, 4, 5], [3, 3]) Show the full operator. embedded_operator.operator .|> real |> sparse 9×9 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅  Get the original operator back. unembed(embedded_operator) .|> real |> sparse 4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅    ⋅   1.0   ⋅ \n  ⋅    ⋅    ⋅   1.0\n 1.0   ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅  Embedded operators for composite systems are also supported."},{"id":25,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n) Embed the  subspace_operator  into the provided  subspaces  of a composite system, where  the  subsystem_indices  list the subspaces at which the operator is defined, and the  subsystem_levels  list the levels of the subsystems in which the operator is embedded.  source This is a two step process. The provided subspace operator is  lift -ed  from the  subsystem_indices  where  it is defined into the space spanned by the composite system's  subspaces . The lifted operator is embedded into the full Hilbert space spanned by the   subsystem_levels . Embed a CZ gate with control qubit 1 and target qubit 3 into a composite system made up of three 3-level systems. An identity is performed on qubit 2. subsystem_levels = [3, 3, 3]\nsubspaces = [1:2, 1:2, 1:2]\nembedded_operator = EmbeddedOperator(GATES[:CZ], [1, 3], subspaces, subsystem_levels)\nunembed(embedded_operator) .|> real |> sparse 8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n 1.0   ⋅    ⋅    ⋅    ⋅     ⋅    ⋅     ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅     ⋅    ⋅     ⋅ \n  ⋅    ⋅   1.0   ⋅    ⋅     ⋅    ⋅     ⋅ \n  ⋅    ⋅    ⋅   1.0   ⋅     ⋅    ⋅     ⋅ \n  ⋅    ⋅    ⋅    ⋅   1.0    ⋅    ⋅     ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅   -1.0   ⋅     ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅     ⋅   1.0    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅     ⋅    ⋅   -1.0"},{"id":26,"pagetitle":"Quantum Objects","title":"Subspace and leakage indices","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#Subspace-and-leakage-indices","content":" Subspace and leakage indices"},{"id":27,"pagetitle":"Quantum Objects","title":"The get_subspace_indices function","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#The-get_subspace_indices-function","content":" The  get_subspace_indices  function The  get_subspace_indices  function is a convenient way to get the indices of a subspace in a larger quantum system."},{"id":28,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices  —  Function get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)    \nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator) Get the indices for the provided subspace of the quantum system. source Its dual function is  get_leakage_indices . get_subspace_indices(1:2, 5) |> collect, get_leakage_indices(1:2, 5) |> collect ([1, 2], [3, 4, 5]) Composite systems are supported. Get the indices of the two-qubit subspace within two 3-level systems. get_subspace_indices([1:2, 1:2], [3, 3]) 4-element Vector{Int64}:\n 1\n 2\n 4\n 5 Qubits are assumed if the indices are not provided. get_subspace_indices([3, 3]) 4-element Vector{Int64}:\n 1\n 2\n 4\n 5 get_leakage_indices([3, 3]) 5-element Vector{Int64}:\n 3\n 6\n 7\n 8\n 9"},{"id":29,"pagetitle":"Quantum Objects","title":"Excitation number restrictions","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#Excitation-number-restrictions","content":" Excitation number restrictions Sometimes we want to cap the number of excitations we allow across a composite system. For example, if we want to restrict ourselves to the ground and single excitation states of two 3-level systems: get_enr_subspace_indices(1, [3, 3]) 3-element Vector{Int64}:\n 1\n 2\n 4"},{"id":30,"pagetitle":"Quantum Objects","title":"The get_iso_vec_subspace_indices function","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#The-get_iso_vec_subspace_indices-function","content":" The  get_iso_vec_subspace_indices  function For isomorphic operators, the  get_iso_vec_subspace_indices  function can be used to find the appropriate vector indices of the equivalent operator subspace. See also,  Isomorphisms#Quantum-operator-isomorphisms ."},{"id":31,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices  —  Function get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator) Get the indices for the subspace in the isomorphic vector space for operators. source Its dual function is  get_iso_vec_leakage_indices , which by default only returns the leakage indices of the blocks: \\[\\mathcal{H}_{\\text{subspace}} \\otimes \\mathcal{H}_{\\text{subspace}},\\quad\n\\mathcal{H}_{\\text{subspace}} \\otimes \\mathcal{H}_{\\text{leakage}},\\quad\n\\mathcal{H}_{\\text{leakage}} \\otimes \\mathcal{H}_{\\text{subspace}}\\] allowing for leakage-suppressing code to disregard the uncoupled pure-leakage space. get_iso_vec_subspace_indices(1:2, 3) 8-element Vector{Int64}:\n  1\n  2\n  4\n  5\n  7\n  8\n 10\n 11 without_pure_leakage = get_iso_vec_leakage_indices(1:2, 3) 8-element Vector{Int64}:\n  3\n  6\n  9\n 12\n 13\n 14\n 16\n 17 Show the pure-leakage indices. with_pure_leakage = get_iso_vec_leakage_indices(1:2, 3, ignore_pure_leakage=false)\nsetdiff(with_pure_leakage, without_pure_leakage) 2-element Vector{Int64}:\n 15\n 18 The pure-leakage indices can grow quickly! without_pure_leakage = get_iso_vec_leakage_indices([1:2, 1:2], [4, 4])\nwith_pure_leakage = get_iso_vec_leakage_indices([1:2, 1:2], [4, 4], ignore_pure_leakage=false)\nsetdiff(with_pure_leakage, without_pure_leakage) |> length 288 This page was generated using  Literate.jl ."},{"id":34,"pagetitle":"Quantum Systems","title":"Abstract Quantum Systems","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#Abstract-Quantum-Systems","content":" Abstract Quantum Systems using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n⊗ = kron;"},{"id":35,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem  —  Type AbstractQuantumSystem Abstract type for defining systems. source"},{"id":36,"pagetitle":"Quantum Systems","title":"Quantum Systems","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#Quantum-Systems","content":" Quantum Systems The  QuantumSystem  type is used to represent a quantum system with a drift Hamiltonian and a set of drive Hamiltonians, \\[H = H_{\\text{drift}} + \\sum_i a_i H_{\\text{drives}}^{(i)}\\]"},{"id":37,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystems.QuantumSystem  —  Type QuantumSystem(H_drift::Matrix{<:Number}, H_drives::Vector{Matrix{<:Number}}; kwargs...)\nQuantumSystem(H_drift::Matrix{<:Number}; kwargs...)\nQuantumSystem(H_drives::Vector{Matrix{<:Number}}; kwargs...)\nQuantumSystem(H::Function, n_drives::Int; kwargs...) Constructs a  QuantumSystem  object from the drift and drive Hamiltonian terms. source QuantumSystem 's are containers for quantum dynamics. Internally, they compute the necessary isomorphisms to perform the dynamics in a real vector space. H_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsystem = QuantumSystem(H_drift, H_drives)\n\na_drives = [1, 0]\nsystem.H(a_drives) 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n 1.0+0.0im   1.0+0.0im\n 1.0+0.0im  -1.0+0.0im To extract the drift and drive Hamiltonians from a  QuantumSystem , use the  get_drift  and  get_drives  functions. get_drift(system) |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n 1.0+0.0im       ⋅    \n     ⋅      -1.0+0.0im Get the X drive. drives = get_drives(system)\ndrives[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      1.0+0.0im\n 1.0+0.0im      ⋅     And the Y drive. drives[2] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      0.0-1.0im\n 0.0+1.0im      ⋅     Note We can also construct a  QuantumSystem  directly from a Hamiltonian function. Internally,  ForwardDiff.jl  is used to compute the drives. H(a) = PAULIS[:Z] + a[1] * PAULIS[:X] + a[2] * PAULIS[:Y]\nsystem = QuantumSystem(H, 2)\nget_drives(system)[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      1.0+0.0im\n 1.0+0.0im      ⋅     Create a noise model with a confusion matrix. function H(a; C::Matrix{Float64}=[1.0 0.0; 0.0 1.0])\n    b = C * a\n    return b[1] * PAULIS.X + b[2] * PAULIS.Y\nend\n\nsystem = QuantumSystem(a -> H(a, C=[0.99 0.01; -0.01 1.01]), 2)\nconfused_drives = get_drives(system)\nconfused_drives[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n      ⋅       0.99+0.01im\n 0.99-0.01im       ⋅     confused_drives[2] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n      ⋅       0.01-1.01im\n 0.01+1.01im       ⋅    "},{"id":38,"pagetitle":"Quantum Systems","title":"Open quantum systems","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#Open-quantum-systems","content":" Open quantum systems We can also construct an  OpenQuantumSystem  with Lindblad dynamics, enabling a user to pass a list of dissipation operators."},{"id":39,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem  —  Type OpenQuantumSystem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::AbstractVector{<:AbstractMatrix{<:Number}}\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}};\n    kwargs...\n)\nOpenQuantumSystem(\n    H_drift::Matrix{<:Number}, H_drives::AbstractVector{Matrix{<:Number}}; \n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[], \n    kwargs...\n)\nOpenQuantumSystem(H_drift::Matrix{<:Number}; kwargs...)\nOpenQuantumSystem(H_drives::Vector{Matrix{<:Number}}; kwargs...)\nOpenQuantumSystem(H::Function, n_drives::Int; kwargs...) Constructs an  OpenQuantumSystem  object from the drift and drive Hamiltonian terms and dissipation operators. source Add a dephasing and annihilation error channel. H_drives = [PAULIS[:X]]\na = annihilate(2)\ndissipation_operators = [a'a, a]\nsystem = OpenQuantumSystem(H_drives, dissipation_operators=dissipation_operators)\nsystem.dissipation_operators[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 1 stored entry:\n     ⋅          ⋅    \n     ⋅      1.0+0.0im system.dissipation_operators[2] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 1 stored entry:\n     ⋅      1.0+0.0im\n     ⋅          ⋅     Warning The Hamiltonian part  system.H  excludes the Lindblad operators. This is also true for functions that report properties of  system.H , such as  get_drift ,  get_drives , and  is_reachable . get_drift(system) |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 0 stored entries:\n     ⋅          ⋅    \n     ⋅          ⋅    "},{"id":40,"pagetitle":"Quantum Systems","title":"Composite quantum systems","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#Composite-quantum-systems","content":" Composite quantum systems A  CompositeQuantumSystem  is constructed from a list of subsystems and their interactions. The interaction, in the form of drift or drive Hamiltonian, acts on the full Hilbert space. The subsystems, with their own drift and drive Hamiltonians, are internally lifted to the full Hilbert space. system_1 = QuantumSystem([PAULIS[:X]])\nsystem_2 = QuantumSystem([PAULIS[:Y]])\nH_drift = PAULIS[:Z] ⊗ PAULIS[:Z]\nsystem = CompositeQuantumSystem(H_drift, [system_1, system_2]); The drift Hamiltonian is the ZZ coupling. get_drift(system) |> sparse 4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n 1.0+0.0im       ⋅           ⋅          ⋅    \n     ⋅      -1.0+0.0im       ⋅          ⋅    \n     ⋅           ⋅      -1.0+0.0im      ⋅    \n     ⋅           ⋅           ⋅      1.0+0.0im The drives are the X and Y operators on the first and second subsystems. drives = get_drives(system)\ndrives[1] |> sparse 4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n     ⋅          ⋅      1.0+0.0im      ⋅    \n     ⋅          ⋅          ⋅      1.0+0.0im\n 1.0+0.0im      ⋅          ⋅          ⋅    \n     ⋅      1.0+0.0im      ⋅          ⋅     drives[2] |> sparse 4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n     ⋅      0.0-1.0im      ⋅          ⋅    \n 0.0+1.0im      ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅      0.0-1.0im\n     ⋅          ⋅      0.0+1.0im      ⋅    "},{"id":41,"pagetitle":"Quantum Systems","title":"The lift function","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#The-lift-function","content":" The  lift  function To lift operators acting on a subsystem into the full Hilbert space, use  lift ."},{"id":42,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.CompositeQuantumSystems.lift","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#PiccoloQuantumObjects.CompositeQuantumSystems.lift-generated-quantum_systems","content":" PiccoloQuantumObjects.CompositeQuantumSystems.lift  —  Function lift(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...) Lift an  operator  acting on the  i -th subsystem within  subsystem_levels  to an operator acting on the entire system spanning  subsystem_levels . source Create an  a + a'  operator acting on the 1st subsystem of a qutrit and qubit system. subspace_levels = [3, 2]\nlift(create(3) + annihilate(3), 1, subspace_levels) .|> real |> sparse 6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n  ⋅    ⋅   1.0       ⋅        ⋅        ⋅ \n  ⋅    ⋅    ⋅       1.0       ⋅        ⋅ \n 1.0   ⋅    ⋅        ⋅       1.41421   ⋅ \n  ⋅   1.0   ⋅        ⋅        ⋅       1.41421\n  ⋅    ⋅   1.41421   ⋅        ⋅        ⋅ \n  ⋅    ⋅    ⋅       1.41421   ⋅        ⋅  Create IXI operator on the 2nd qubit in a 3-qubit system. lift(PAULIS[:X], 2, 3) .|> real |> sparse 8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n  ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ \n 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅  Create an XX operator acting on qubits 3 and 4 in a 4-qubit system. lift([PAULIS[:X], PAULIS[:X]], [3, 4], 4) .|> real |> sparse 16×16 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:\n⎡⡠⠊⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⡠⠊⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⡠⠊⠀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⡠⠊⎦ We can also lift an operator that entangles different subspaces by passing the indices of the entangled subsystems. #_Here's another way to create an XX operator acting on qubits 3 and 4 in a 4-qubit system._\nlift(kron(PAULIS[:X], PAULIS[:X]), [3, 4], 4) .|> real |> sparse 16×16 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:\n⎡⡠⠊⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⡠⠊⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⡠⠊⠀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⡠⠊⎦ Lift a CX gate acting on the 1st and 3rd qubits in a 3-qubit system. The result is independent of the state of the second qubit. lift(GATES[:CX], [1, 3], 3) .|> real |> sparse 8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅ "},{"id":43,"pagetitle":"Quantum Systems","title":"Reachability tests","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#Reachability-tests","content":" Reachability tests Whether a quantum system can be used to reach a target state or operator can be tested by computing the dynamical Lie algebra. Access to this calculation is provided by the  is_reachable  function."},{"id":44,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystemUtils.is_reachable  —  Function is_reachable(gate, hamiltonians; kwargs...) Check if the  gate  is reachable using the given  hamiltonians . Arguments gate::AbstractMatrix : target gate hamiltonians::AbstractVector{<:AbstractMatrix} : generators of the Lie algebra Keyword Arguments subspace::AbstractVector{<:Int}=1:size(gate, 1) : subspace indices compute_basis::Bool=true : compute the basis or use the Hamiltonians directly remove_trace::Bool=true : remove trace from generators verbose::Bool=true : print information about the operator algebra atol::Float32=eps(Float32) : absolute tolerance See also  QuantumSystemUtils.operator_algebra . source is_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...) Check if the  gate  is reachable using the given  system . Keyword Arguments use_drift::Bool=true : include drift Hamiltonian in the generators kwargs... : keyword arguments for  is_reachable source Y can be reached by commuting Z and X. system = QuantumSystem(PAULIS[:Z], [PAULIS[:X]])\nis_reachable(PAULIS[:Y], system) true Y cannot be reached by X alone. system = QuantumSystem([PAULIS[:X]])\nis_reachable(PAULIS[:Y], system) false This page was generated using  Literate.jl ."},{"id":47,"pagetitle":"Library","title":"Quantum Systems","ref":"/PiccoloQuantumObjects/stable/lib/#Quantum-Systems","content":" Quantum Systems"},{"id":48,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem  —  Type AbstractQuantumSystem Abstract type for defining systems. source"},{"id":49,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem  —  Type OpenQuantumSystem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::AbstractVector{<:AbstractMatrix{<:Number}}\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}};\n    kwargs...\n)\nOpenQuantumSystem(\n    H_drift::Matrix{<:Number}, H_drives::AbstractVector{Matrix{<:Number}}; \n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[], \n    kwargs...\n)\nOpenQuantumSystem(H_drift::Matrix{<:Number}; kwargs...)\nOpenQuantumSystem(H_drives::Vector{Matrix{<:Number}}; kwargs...)\nOpenQuantumSystem(H::Function, n_drives::Int; kwargs...) Constructs an  OpenQuantumSystem  object from the drift and drive Hamiltonian terms and dissipation operators. source"},{"id":50,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.QuantumSystem  —  Type QuantumSystem(H_drift::Matrix{<:Number}, H_drives::Vector{Matrix{<:Number}}; kwargs...)\nQuantumSystem(H_drift::Matrix{<:Number}; kwargs...)\nQuantumSystem(H_drives::Vector{Matrix{<:Number}}; kwargs...)\nQuantumSystem(H::Function, n_drives::Int; kwargs...) Constructs a  QuantumSystem  object from the drift and drive Hamiltonian terms. source"},{"id":51,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.get_drift","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystems.get_drift-Tuple{AbstractQuantumSystem}","content":" PiccoloQuantumObjects.QuantumSystems.get_drift  —  Method get_drift(sys::AbstractQuantumSystem) Returns the drift Hamiltonian of the system. source"},{"id":52,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.get_drives","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystems.get_drives-Tuple{AbstractQuantumSystem}","content":" PiccoloQuantumObjects.QuantumSystems.get_drives  —  Method get_drives(sys::AbstractQuantumSystem) Returns the drive Hamiltonians of the system. source"},{"id":53,"pagetitle":"Library","title":"Composite Quantum Systems","ref":"/PiccoloQuantumObjects/stable/lib/#Composite-Quantum-Systems","content":" Composite Quantum Systems"},{"id":54,"pagetitle":"Library","title":"PiccoloQuantumObjects.CompositeQuantumSystems.CompositeQuantumSystem","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.CompositeQuantumSystems.CompositeQuantumSystem","content":" PiccoloQuantumObjects.CompositeQuantumSystems.CompositeQuantumSystem  —  Type CompositeQuantumSystem <: AbstractQuantumSystem A composite quantum system consisting of  subsystems . Couplings between subsystems can be additionally defined. Subsystem drives are always appended to any new coupling drives. source"},{"id":55,"pagetitle":"Library","title":"PiccoloQuantumObjects.CompositeQuantumSystems.lift","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.CompositeQuantumSystems.lift","content":" PiccoloQuantumObjects.CompositeQuantumSystems.lift  —  Function lift(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...) Lift an  operator  acting on the  i -th subsystem within  subsystem_levels  to an operator acting on the entire system spanning  subsystem_levels . source"},{"id":56,"pagetitle":"Library","title":"Gates","ref":"/PiccoloQuantumObjects/stable/lib/#Gates","content":" Gates"},{"id":57,"pagetitle":"Library","title":"PiccoloQuantumObjects.Gates.GATES","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Gates.GATES","content":" PiccoloQuantumObjects.Gates.GATES  —  Constant A constant dictionary  GATES  containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix. GATES[:I]  - Identity: Leaves the state unchanged. GATES[:X]  - Pauli-X (NOT): Flips the qubit state. GATES[:Y]  - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere. GATES[:Z]  - Pauli-Z: Flips the phase of the qubit state. GATES[:H]  - Hadamard: Creates superposition by transforming basis states. GATES[:CX]  - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1⟩. GATES[:CZ]  - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1⟩. GATES[:XI]  - Complex: A gate for complex operations. GATES[:sqrtiSWAP]  - Square root of iSWAP: Partially swaps two qubits with a phase. source"},{"id":58,"pagetitle":"Library","title":"PiccoloQuantumObjects.Gates.PAULIS","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Gates.PAULIS","content":" PiccoloQuantumObjects.Gates.PAULIS  —  Constant The 2×2 Pauli matrics and identity. source"},{"id":59,"pagetitle":"Library","title":"Embedded Operators","ref":"/PiccoloQuantumObjects/stable/lib/#Embedded-Operators","content":" Embedded Operators"},{"id":60,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator","content":" PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator  —  Type AbstractPiccoloOperator Union type for operators. source"},{"id":61,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Type EmbeddedOperator Embedded operator type to represent an operator embedded in a subspace of a larger  quantum system. Fields operator::Matrix{ComplexF64} : Embedded operator of size     prod(subsystem_levels) x prod(subsystem_levels) . subspace::Vector{Int} : Indices of the subspace the operator is embedded in. subsystem_levels::Vector{Int} : Levels of the subsystems in the composite system. source"},{"id":62,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n) Embed the  subspace_operator  into the provided  subspaces  of a composite system, where  the  subsystem_indices  list the subspaces at which the operator is defined, and the  subsystem_levels  list the levels of the subsystems in which the operator is embedded.  source"},{"id":63,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, CompositeQuantumSystem}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    composite_system::CompositeQuantumSystem\n) Embed the  subspace_operator  into the provided  subspaces  of a composite system. source"},{"id":64,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int}) Create an embedded operator. The  operator  is embedded at the  subspace  of the system spanned by the  subsystem_levels . source"},{"id":65,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, QuantumSystem}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(subspace_operator::AbstractMatrix{<:Number}, system::QuantumSystem; kwargs...) Embed the  subspace_operator  into a quantum  system . source"},{"id":66,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.embed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","content":" PiccoloQuantumObjects.EmbeddedOperators.embed  —  Method embed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator) Embed the  subspace_operator  in the subspace of a larger  embedded_operator . source"},{"id":67,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.embed-Union{Tuple{R}, Tuple{AbstractMatrix{R}, AbstractVector{Int64}, Int64}} where R<:Number","content":" PiccoloQuantumObjects.EmbeddedOperators.embed  —  Method embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int) Embed an  operator  in the  subspace  of a larger matrix of size  levels x levels . source"},{"id":68,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices-Tuple{Int64, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices  —  Method get_enr_subspace_indices(excitation_restriction::Int, subsystem_levels::AbstractVector{Int}) Get the indices for the subspace of the quantum system with an excitation restriction. source"},{"id":69,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices  —  Function get_iso_vec_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_iso_vec_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_iso_vec_leakage_indices(op::EmbeddedOperator) Get the indices for the leakage in the isomorphic vector space for operators. source"},{"id":70,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices  —  Function get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator) Get the indices for the subspace in the isomorphic vector space for operators. source"},{"id":71,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices  —  Function get_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_leakage_indices(op::EmbeddedOperator) Get the indices for the states that are outside of the provided subspace of the quantum system. source"},{"id":72,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices  —  Function get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)    \nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator) Get the indices for the provided subspace of the quantum system. source"},{"id":73,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Method unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}) Unembed a subspace operator from the  matrix . This is equivalent to calling   matrix[subspace, subspace] . source"},{"id":74,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Method unembed(op::AbstractMatrix, embedded_op::EmbeddedOperator) Unembed a sub-matrix from the  op  at the subspace defined by  embedded_op . source"},{"id":75,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{EmbeddedOperator}","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Method unembed(embedded_op::EmbeddedOperator)::Matrix{ComplexF64} Unembed an embedded operator, returning the original operator. source"},{"id":76,"pagetitle":"Library","title":"Isomorphisims","ref":"/PiccoloQuantumObjects/stable/lib/#Isomorphisims","content":" Isomorphisims"},{"id":77,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.G","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.G-Tuple{AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.G  —  Method G(H::AbstractMatrix)::Matrix{Float64} Returns the isomorphism of  $-iH$ , i.e.  $G(H) = \\text{iso}(-iH)$ . See also  Isomorphisms.iso ,  Isomorphisms.H . source"},{"id":78,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.H","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.H-Tuple{AbstractMatrix{<:Real}}","content":" PiccoloQuantumObjects.Isomorphisms.H  —  Method H(G::AbstractMatrix{<:Real}) Returns the inverse of  $G(H) = iso(-iH)$ , i.e. returns H. See also  Isomorphisms.iso ,  Isomorphisms.G . source"},{"id":79,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ad_vec","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.ad_vec-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","content":" PiccoloQuantumObjects.Isomorphisms.ad_vec  —  Method ad_vec(H::AbstractMatrix{ℂ}; anti::Bool=false) where ℂ <: Number Returns the vectorized adjoint action of a matrix  H : \\[\\text{ad_vec}(H) = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes H - (-1)^{\\text{anti}} \\mqty(0 & 1 \\\\ 1 & 0) \\otimes H^*\\] source"},{"id":80,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec-Tuple{AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec  —  Method density_to_iso_vec(ρ::AbstractMatrix{<:Number}) Returns the isomorphism  ρ⃗̃ = ket_to_iso(vec(ρ))  of a density matrix  ρ source"},{"id":81,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso-Tuple{AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.iso  —  Method iso(H::AbstractMatrix{<:Number}) Returns the isomorphism of  $H$ : \\[iso(H) = \\widetilde{H} = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] where  $\\Im(H)$  and  $\\Re(H)$  are the imaginary and real parts of  $H$  and the tilde  indicates the standard isomorphism of a complex valued matrix: \\[\\widetilde{H} = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] See also  Isomorphisms.G ,  Isomorphisms.H . source"},{"id":82,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_D","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso_D-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","content":" PiccoloQuantumObjects.Isomorphisms.iso_D  —  Method iso_D(L::AbstractMatrix{ℂ}) where ℂ <: Number Returns the isomorphic representation of the Lindblad dissipator  L . source"},{"id":83,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec-Union{Tuple{AbstractMatrix{ℝ}}, Tuple{ℝ}} where ℝ<:Real","content":" PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec  —  Method iso_operator_to_iso_vec(Ũ::AbstractMatrix{ℝ}) where ℝ <: Real Convert a real matrix  Ũ  representing an isomorphism operator into a real vector. source"},{"id":84,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator-Tuple{Any}","content":" PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator  —  Method iso_operator_to_operator(Ũ) source"},{"id":85,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_to_ket","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso_to_ket-Tuple{AbstractVector{<:Real}}","content":" PiccoloQuantumObjects.Isomorphisms.iso_to_ket  —  Method iso_to_ket(ψ̃::AbstractVector{<:Real}) Convert a real isomorphism vector  ψ̃  into a ket vector. source"},{"id":86,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density-Tuple{AbstractVector{<:Real}}","content":" PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density  —  Method iso_vec_to_density(ρ⃗̃::AbstractVector{<:Real}) Returns the density matrix  ρ  from its isomorphism  ρ⃗̃ source"},{"id":87,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator-Union{Tuple{AbstractVector{ℝ}}, Tuple{ℝ}} where ℝ<:Real","content":" PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator  —  Method iso_vec_to_iso_operator(Ũ⃗::AbstractVector{ℝ}) where ℝ <: Real Convert a real vector  Ũ⃗  into a real matrix representing an isomorphism operator. source"},{"id":88,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator-Union{Tuple{AbstractVector{ℝ}}, Tuple{ℝ}} where ℝ<:Real","content":" PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator  —  Method iso_vec_to_operator(Ũ⃗::AbstractVector{ℝ}) where ℝ <: Real Convert a real vector  Ũ⃗  into a complex matrix representing an operator. source"},{"id":89,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ket_to_iso","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.ket_to_iso-Tuple{AbstractVector{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.ket_to_iso  —  Method ket_to_iso(ψ::AbstractVector{<:Number}) Convert a ket vector  ψ  into a complex vector with real and imaginary parts. source"},{"id":90,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.mat","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.mat-Tuple{AbstractVector}","content":" PiccoloQuantumObjects.Isomorphisms.mat  —  Method mat(x::AbstractVector) Convert a vector  x  into a square matrix. The length of  x  must be a perfect square. source"},{"id":91,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator-Tuple{Any}","content":" PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator  —  Method operator_to_iso_operator(U) source"},{"id":92,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","content":" PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec  —  Method operator_to_iso_vec(U::AbstractMatrix{ℂ}) where ℂ <: Number Convert a complex matrix  U  representing an operator into a real vector. source"},{"id":93,"pagetitle":"Library","title":"Quantum Object Utilities","ref":"/PiccoloQuantumObjects/stable/lib/#Quantum-Object-Utilities","content":" Quantum Object Utilities"},{"id":94,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.annihilate","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumObjectUtils.annihilate-Tuple{Int64}","content":" PiccoloQuantumObjects.QuantumObjectUtils.annihilate  —  Method annihilate(levels::Int) Get the annihilation operator for a system with  levels . source"},{"id":95,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.create","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumObjectUtils.create-Tuple{Int64}","content":" PiccoloQuantumObjects.QuantumObjectUtils.create  —  Method create(levels::Int) Get the creation operator for a system with  levels . source"},{"id":96,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.haar_identity","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumObjectUtils.haar_identity-Tuple{Int64, Number}","content":" PiccoloQuantumObjects.QuantumObjectUtils.haar_identity  —  Method haar_identity(n::Int, radius::Number) Generate a random unitary matrix close to the identity matrix using the Haar measure for  an  n -dimensional system with a given  radius . The smaller the radius, the closer the matrix will be to the identity. source"},{"id":97,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.haar_random","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumObjectUtils.haar_random-Tuple{Int64}","content":" PiccoloQuantumObjects.QuantumObjectUtils.haar_random  —  Method haar_random(n::Int) Generate a random unitary matrix using the Haar measure for an  n -dimensional system. source"},{"id":98,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring-Tuple{String}","content":" PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring  —  Method ket_from_bitstring(ket::String) Get the state vector for a qubit system given a ket string  ket  of 0s and 1s. source"},{"id":99,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string-Tuple{String, Vector{Int64}}","content":" PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string  —  Method ket_from_string(\n    ket::String,\n    levels::Vector{Int};\n    level_dict=Dict(:g => 0, :e => 1, :f => 2, :h => 2),\n    return_states=false\n) Construct a quantum state from a string ket representation. source"},{"id":100,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string-Tuple{String}","content":" PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string  —  Method operator_from_string(operator::String; lookup=PAULIS) Reduce the string (each character is one key) via operators from a dictionary. source"},{"id":101,"pagetitle":"Library","title":"Quantum System Utilities","ref":"/PiccoloQuantumObjects/stable/lib/#Quantum-System-Utilities","content":" Quantum System Utilities"},{"id":102,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractQuantumSystem}","content":" PiccoloQuantumObjects.QuantumSystemUtils.is_reachable  —  Method is_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...) Check if the  gate  is reachable using the given  system . Keyword Arguments use_drift::Bool=true : include drift Hamiltonian in the generators kwargs... : keyword arguments for  is_reachable source"},{"id":103,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}}","content":" PiccoloQuantumObjects.QuantumSystemUtils.is_reachable  —  Method is_reachable(gate, hamiltonians; kwargs...) Check if the  gate  is reachable using the given  hamiltonians . Arguments gate::AbstractMatrix : target gate hamiltonians::AbstractVector{<:AbstractMatrix} : generators of the Lie algebra Keyword Arguments subspace::AbstractVector{<:Int}=1:size(gate, 1) : subspace indices compute_basis::Bool=true : compute the basis or use the Hamiltonians directly remove_trace::Bool=true : remove trace from generators verbose::Bool=true : print information about the operator algebra atol::Float32=eps(Float32) : absolute tolerance See also  QuantumSystemUtils.operator_algebra . source"},{"id":104,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra-Union{Tuple{Vector{<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","content":" PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra  —  Method operator_algebra(generators; kwargs...) Compute the Lie algebra basis for the given  generators . Arguments generators::Vector{<:AbstractMatrix} : generators of the Lie algebra Keyword Arguments return_layers::Bool=false : return the Lie tree layers normalize::Bool=false : normalize the basis verbose::Bool=false : print information remove_trace::Bool=true : remove trace from generators source"},{"id":107,"pagetitle":"Home","title":"QuantumCollocation.jl","ref":"/QuantumCollocation/stable/#QuantumCollocation.jl","content":" QuantumCollocation.jl QuantumCollocation.jl  sets up and solves  quantum control problems  as nonlinear programs (NLPs). In this context, a generic quantum control problem looks like \\[\\begin{aligned}\n    \\arg \\min_{\\mathbf{Z}}\\quad & J(\\mathbf{Z}) \\\\\n    \\nonumber \\text{s.t.}\\qquad & \\mathbf{f}(\\mathbf{Z}) = 0 \\\\\n    \\nonumber & \\mathbf{g}(\\mathbf{Z}) \\le 0  \n\\end{aligned}\\] where  $\\mathbf{Z}$  is a trajectory  containing states and controls, from  NamedTrajectories.jl . We provide a number of  problem templates  for making it simple and easy to set up and solve  certain types of quantum optimal control problems. These templates all construct a   DirectTrajOptProblem  object from  DirectTrajOpt.jl , which stores all the parts of the optimal control problem."},{"id":108,"pagetitle":"Home","title":"Get started","ref":"/QuantumCollocation/stable/#Get-started","content":" Get started The problem templates are broken down by the state variable of the problem being solved. Ket Problem Templates: Quantum State Smooth Pulse Problem Quantum State Minimum Time Problem Quantum State Sampling Problem Unitary Problem Templates: Unitary Smooth Pulse Problem Unitary Minimum Time Problem Unitary Sampling Problem"},{"id":109,"pagetitle":"Home","title":"Background","ref":"/QuantumCollocation/stable/#Background","content":" Background Problem Templates  are reusable design patterns for setting up and solving common quantum control problems.  For example, a  UnitarySmoothPulseProblem  is tasked with generating a  pulse  sequence  $a_{1:T-1}$  in orderd to minimize infidelity, subject to constraints from the Schroedinger equation, \\[    \\begin{aligned}\n        \\arg \\min_{\\mathbf{Z}}\\quad & |1 - \\mathcal{F}(U_T, U_\\text{goal})|  \\\\\n        \\nonumber \\text{s.t.}\n        \\qquad & U_{t+1} = \\exp\\{- i H(a_t) \\Delta t_t \\} U_t, \\quad \\forall\\, t \\\\\n    \\end{aligned}\\] while a  UnitaryMinimumTimeProblem  minimizes time and constrains fidelity, \\[    \\begin{aligned}\n        \\arg \\min_{\\mathbf{Z}}\\quad & \\sum_{t=1}^T \\Delta t_t \\\\\n        \\qquad & U_{t+1} = \\exp\\{- i H(a_t) \\Delta t_t \\} U_t, \\quad \\forall\\, t \\\\\n        \\nonumber & \\mathcal{F}(U_T, U_\\text{goal}) \\ge 0.9999\n    \\end{aligned}\\] In each case, the dynamics between  knot points $(U_t, a_t)$  and  $(U_{t+1}, a_{t+1})$  are enforced as constraints on the states, which are free variables in the solver; this optimization framework is called  direct trajectory optimization .  Problem templates give the user the ability to add other constraints and objective functions to this problem and solve it efficiently using  Ipopt.jl  and  MathOptInterface.jl  under the hood."},{"id":112,"pagetitle":"Ket Problem Templates","title":"Quantum State Smooth Pulse Problem","ref":"/QuantumCollocation/stable/generated/man/ket_problem_templates/#Quantum-State-Smooth-Pulse-Problem","content":" Quantum State Smooth Pulse Problem"},{"id":113,"pagetitle":"Ket Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","ref":"/QuantumCollocation/stable/generated/man/ket_problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem-generated-man-ket_problem_templates","content":" QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem  —  Function QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...) Create a quantum state smooth pulse problem. The goal is to find a control pulse  a(t)   that drives all of the initial states  ψ_inits  to the corresponding target states   ψ_goals  using  T  timesteps of size  Δt . This problem also controls the  first and  second derivatives of the control pulse,  da(t)  and  dda(t) , to ensure smoothness. Arguments system::AbstractQuantumSystem : The quantum system. or H_drift::AbstractMatrix{<:Number} : The drift Hamiltonian. H_drives::Vector{<:AbstractMatrix{<:Number}} : The control Hamiltonians. with ψ_inits::Vector{<:AbstractVector{<:ComplexF64}} : The initial states. ψ_goals::Vector{<:AbstractVector{<:ComplexF64}} : The target states. or ψ_init::AbstractVector{<:ComplexF64} : The initial state. ψ_goal::AbstractVector{<:ComplexF64} : The target state. with T::Int : The number of timesteps. Δt::Float64 : The timestep size. Keyword Arguments state_name::Symbol=:ψ̃ : The name of the state variable. control_name::Symbol=:a : The name of the control variable. timestep_name::Symbol=:Δt : The name of the timestep variable. init_trajectory::Union{NamedTrajectory, Nothing}=nothing : The initial trajectory. a_bound::Float64=1.0 : The bound on the control pulse. a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)) : The bounds on the control pulse. a_guess::Union{Matrix{Float64}, Nothing}=nothing : The initial guess for the control pulse. da_bound::Float64=Inf : The bound on the first derivative of the control pulse. da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)) : The bounds on the first derivative of the control pulse. dda_bound::Float64=1.0 : The bound on the second derivative of the control pulse. dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)) : The bounds on the second derivative of the control pulse. Δt_min::Float64=0.5 * Δt : The minimum timestep size. Δt_max::Float64=1.5 * Δt : The maximum timestep size. drive_derivative_σ::Float64=0.01 : The standard deviation of the drive derivative random initialization. Q::Float64=100.0 : The weight on the state objective. R=1e-2 : The weight on the control pulse and its derivatives. R_a::Union{Float64, Vector{Float64}}=R : The weight on the control pulse. R_da::Union{Float64, Vector{Float64}}=R : The weight on the first derivative of the control pulse. R_dda::Union{Float64, Vector{Float64}}=R : The weight on the second derivative of the control pulse. constraints::Vector{<:AbstractConstraint}=AbstractConstraint[] : The constraints. piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. source Each problem starts with a  QuantumSystem  object, which is used to define the system's Hamiltonian and control operators. The goal is to find a control pulse that drives the intial state,  ψ_init , to a target state,  ψ_goal . define the quantum system system = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y])\nψ_init = Vector{ComplexF64}([1.0, 0.0])\nψ_goal = Vector{ComplexF64}([0.0, 1.0])\nT = 51\nΔt = 0.2 0.2 create the smooth pulse problem state_prob = QuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt);     constructing QuantumStateSmoothPulseProblem...\n\tusing integrator: typeof(KetIntegrator)\n\tusing 1 initial state(s)\n\tapplying timesteps_all_equal constraint: Δt check the fidelity before solving println(\"Before: \", rollout_fidelity(state_prob.trajectory, system)) Before: 0.7490901970252036 solve the problem solve!(state_prob, max_iter=100, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of ψ̃\n        applying constraint: initial value of a\n        applying constraint: initial value of da\n        applying constraint: final value of a\n        applying constraint: final value of da\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt\n\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n****************************************************************************** check the fidelity after solving println(\"After: \", rollout_fidelity(state_prob.trajectory, system)) After: 0.9998330589147368 extract the control pulses state_prob.trajectory.a |> size (2, 51)"},{"id":114,"pagetitle":"Ket Problem Templates","title":"Quantum State Minimum Time Problem","ref":"/QuantumCollocation/stable/generated/man/ket_problem_templates/#Quantum-State-Minimum-Time-Problem","content":" Quantum State Minimum Time Problem"},{"id":115,"pagetitle":"Ket Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","ref":"/QuantumCollocation/stable/generated/man/ket_problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem-generated-man-ket_problem_templates","content":" QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem  —  Function QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)\nQuantumStateMinimumTimeProblem(prob; kwargs...) Construct a  DirectTrajOptProblem  for the minimum time problem of reaching a target state. Keyword Arguments state_name::Symbol=:ψ̃ : The symbol for the state variables. final_fidelity::Union{Real, Nothing}=nothing : The final fidelity. D=1.0 : The cost weight on the time. piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. source create the minimum time problem min_state_prob = QuantumStateMinimumTimeProblem(state_prob, ψ_goal);     constructing QuantumStateMinimumTimeProblem...\n\tfinal fidelity: 1.0 check the previous duration println(\"Duration before: \", get_duration(state_prob.trajectory)) Duration before: 10.073668926847914 solve the minimum time problem solve!(min_state_prob, max_iter=100, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of ψ̃\n        applying constraint: initial value of a\n        applying constraint: initial value of da\n        applying constraint: final value of a\n        applying constraint: final value of da\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt check the new duration println(\"Duration after: \", get_duration(min_state_prob.trajectory)) Duration after: 3.646083459509302 the fidelity is preserved by a constraint println(\"Fidelity after: \", rollout_fidelity(min_state_prob.trajectory, system)) Fidelity after: 0.9999512780484473"},{"id":116,"pagetitle":"Ket Problem Templates","title":"Quantum State Sampling Problem","ref":"/QuantumCollocation/stable/generated/man/ket_problem_templates/#Quantum-State-Sampling-Problem","content":" Quantum State Sampling Problem"},{"id":117,"pagetitle":"Ket Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","ref":"/QuantumCollocation/stable/generated/man/ket_problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem-generated-man-ket_problem_templates","content":" QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem  —  Function source create a sampling problem driftless_system = QuantumSystem([PAULIS.X, PAULIS.Y])\nsampling_state_prob = QuantumStateSamplingProblem([system, driftless_system], ψ_init, ψ_goal, T, Δt);     constructing QuantumStateSamplingProblem...\n\tusing integrator: typeof(KetIntegrator)\n\tusing 2 initial state(s)\n\tapplying timesteps_all_equal constraint: Δt new keys are added to the trajectory for the new states println(sampling_state_prob.trajectory.state_names) (:ψ̃1_system_1, :a, :da, :ψ̃1_system_2) solve the sampling problem for a few iterations solve!(sampling_state_prob, max_iter=25, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of ψ̃1_system_1\n        applying constraint: initial value of a\n        applying constraint: initial value of da\n        applying constraint: initial value of ψ̃1_system_2\n        applying constraint: final value of a\n        applying constraint: final value of da\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt check the fidelity of the sampling problem (use the updated key to get the initial and goal) println(\"After (original system): \", rollout_fidelity(sampling_state_prob.trajectory, system, state_name=:ψ̃1_system_1))\nprintln(\"After (new system): \", rollout_fidelity(sampling_state_prob.trajectory, driftless_system, state_name=:ψ̃1_system_1)) After (original system): 0.9870064823995764\nAfter (new system): 0.9881008761597339 compare this to using the original problem on the new system println(\"After (new system, original `prob`): \", rollout_fidelity(state_prob.trajectory, driftless_system)) After (new system, original `prob`): 0.7986343691645029 This page was generated using  Literate.jl ."},{"id":120,"pagetitle":"Unitary Problem Templates","title":"Unitary Smooth Pulse Problem","ref":"/QuantumCollocation/stable/generated/man/unitary_problem_templates/#Unitary-Smooth-Pulse-Problem","content":" Unitary Smooth Pulse Problem"},{"id":121,"pagetitle":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","ref":"/QuantumCollocation/stable/generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-generated-man-unitary_problem_templates","content":" QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem  —  Function UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator, T, Δt; kwargs...)\nUnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...) Construct a  DirectTrajOptProblem  for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e., \\[\\begin{aligned}\n\\underset{\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}, \\Delta t}{\\text{minimize}} & \\quad\nQ \\cdot \\ell\\qty(\\vec{\\tilde{U}}_T, \\vec{\\tilde{U}}_{\\text{goal}}) + \\frac{1}{2} \\sum_t \\qty(R_a a_t^2 + R_{\\dot{a}} \\dot{a}_t^2 + R_{\\ddot{a}} \\ddot{a}_t^2) \\\\\n\\text{ subject to } & \\quad \\vb{P}^{(n)}\\qty(\\vec{\\tilde{U}}_{t+1}, \\vec{\\tilde{U}}_t, a_t, \\Delta t_t) = 0 \\\\\n& \\quad a_{t+1} - a_t - \\dot{a}_t \\Delta t_t = 0 \\\\\n& \\quad \\dot{a}_{t+1} - \\dot{a}_t - \\ddot{a}_t \\Delta t_t = 0 \\\\\n& \\quad |a_t| \\leq a_{\\text{bound}} \\\\\n& \\quad |\\ddot{a}_t| \\leq \\ddot{a}_{\\text{bound}} \\\\\n& \\quad \\Delta t_{\\text{min}} \\leq \\Delta t_t \\leq \\Delta t_{\\text{max}} \\\\\n\\end{aligned}\\] where, for  $U \\in SU(N)$ , \\[\\ell\\qty(\\vec{\\tilde{U}}_T, \\vec{\\tilde{U}}_{\\text{goal}}) =\n\\abs{1 - \\frac{1}{N} \\abs{ \\tr \\qty(U_{\\text{goal}}, U_T)} }\\] is the  infidelity  objective function,  $Q$  is a weight,  $R_a$ ,  $R_{\\dot{a}}$ , and  $R_{\\ddot{a}}$  are weights on the regularization terms, and  $\\vb{P}^{(n)}$  is the  $n$ th-order Pade integrator. Arguments system::AbstractQuantumSystem : the system to be controlled or H_drift::AbstractMatrix{<:Number} : the drift hamiltonian H_drives::Vector{<:AbstractMatrix{<:Number}} : the control hamiltonians with goal::AbstractPiccoloOperator : the target unitary, either in the form of an  EmbeddedOperator  or a `Matrix{ComplexF64} T::Int : the number of timesteps Δt::Float64 : the (initial) time step size Keyword Arguments piccolo_options::PiccoloOptions=PiccoloOptions() : the options for the Piccolo solver state_name::Symbol = :Ũ⃗ : the name of the state control_name::Symbol = :a : the name of the control timestep_name::Symbol = :Δt : the name of the timestep init_trajectory::Union{NamedTrajectory, Nothing}=nothing : an initial trajectory to use a_guess::Union{Matrix{Float64}, Nothing}=nothing : an initial guess for the control pulses a_bound::Float64=1.0 : the bound on the control pulse a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)) : the bounds on the control pulses, one for each drive da_bound::Float64=Inf : the bound on the control pulse derivative da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)) : the bounds on the control pulse derivatives, one for each drive dda_bound::Float64=1.0 : the bound on the control pulse second derivative dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)) : the bounds on the control pulse second derivatives, one for each drive Δt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt) : the minimum time step size Δt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt) : the maximum time step size Q::Float64=100.0 : the weight on the infidelity objective R=1e-2 : the weight on the regularization terms R_a::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulses R_da::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulse derivatives R_dda::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulse second derivatives constraints::Vector{<:AbstractConstraint}=AbstractConstraint[] : the constraints to enforce source The  UnitarySmoothPulseProblem  is similar to the  QuantumStateSmoothPulseProblem , but instead of driving the system to a target state, the goal is to drive the system to a target unitary operator,  U_goal . system = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y])\nU_goal = GATES.H\nT = 51\nΔt = 0.2\n\nprob = UnitarySmoothPulseProblem(system, U_goal, T, Δt);     constructing UnitarySmoothPulseProblem...\n\tusing integrator: typeof(UnitaryIntegrator)\n\tcontrol derivative names: [:da, :dda]\n\tapplying timesteps_all_equal constraint: Δt check the fidelity before solving println(\"Before: \", unitary_rollout_fidelity(prob.trajectory, system)) Before: 0.31235102353565675 finding an optimal control is as simple as calling  solve! solve!(prob, max_iter=100, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: initial value of da\n        applying constraint: final value of a\n        applying constraint: final value of da\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt check the fidelity after solving println(\"After: \", unitary_rollout_fidelity(prob.trajectory, system)) After: 0.9999999549185107 The  NamedTrajectory  object stores the control pulse, state variables, and the time grid. extract the control pulses prob.trajectory.a |> size (2, 51)"},{"id":122,"pagetitle":"Unitary Problem Templates","title":"Unitary Minimum Time Problem","ref":"/QuantumCollocation/stable/generated/man/unitary_problem_templates/#Unitary-Minimum-Time-Problem","content":" Unitary Minimum Time Problem"},{"id":123,"pagetitle":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","ref":"/QuantumCollocation/stable/generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem-generated-man-unitary_problem_templates","content":" QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem  —  Function UnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    trajectory::NamedTrajectory,\n    objective::Objective,\n    dynamics::TrajectoryDynamics,\n    constraints::AbstractVector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    prob::DirectTrajOptProblem;\n    kwargs...\n) Create a minimum-time problem for unitary control. \\[\\begin{aligned}\n\\underset{\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}, \\Delta t}{\\text{minimize}} & \\quad\nJ(\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}) + D \\sum_t \\Delta t_t \\\\\n\\text{ subject to } & \\quad \\vb{P}^{(n)}\\qty(\\vec{\\tilde{U}}_{t+1}, \\vec{\\tilde{U}}_t, a_t, \\Delta t_t) = 0 \\\\\n& c(\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}) = 0 \\\\\n& \\quad \\Delta t_{\\text{min}} \\leq \\Delta t_t \\leq \\Delta t_{\\text{max}} \\\\\n\\end{aligned}\\] Keyword Arguments piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. unitary_name::Symbol=:Ũ⃗ : The name of the unitary for the goal. final_fidelity::Float64=1.0 : The final fidelity constraint. D::Float64=1.0 : The scaling factor for the minimum-time objective. source The goal of this problem is to find the shortest time it takes to drive the system to a target unitary operator,  U_goal . The problem is solved by minimizing the sum of all of the time steps. It is constructed from  prob  in the previous example. min_prob = UnitaryMinimumTimeProblem(prob, U_goal);     constructing UnitaryMinimumTimeProblem...\n\tfinal fidelity: 1.0 check the previous duration println(\"Duration before: \", get_duration(prob.trajectory)) Duration before: 10.182663565332694 solve the minimum time problem solve!(min_prob, max_iter=100, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: initial value of da\n        applying constraint: final value of a\n        applying constraint: final value of da\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt check the new duration println(\"Duration after: \", get_duration(min_prob.trajectory)) Duration after: 5.002521832976513 the fidelity is preserved by a constraint println(\"Fidelity after: \", unitary_rollout_fidelity(min_prob.trajectory, system)) Fidelity after: 0.9999999429989915"},{"id":124,"pagetitle":"Unitary Problem Templates","title":"Unitary Sampling Problem","ref":"/QuantumCollocation/stable/generated/man/unitary_problem_templates/#Unitary-Sampling-Problem","content":" Unitary Sampling Problem"},{"id":125,"pagetitle":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySamplingProblem","ref":"/QuantumCollocation/stable/generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-generated-man-unitary_problem_templates","content":" QuantumCollocation.ProblemTemplates.UnitarySamplingProblem  —  Function UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...) A  UnitarySamplingProblem  is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control  pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty. Arguments systems::AbstractVector{<:AbstractQuantumSystem} : A vector of quantum systems. operators::AbstractVector{<:AbstractPiccoloOperator} : A vector of target operators. T::Int : The number of time steps. Δt::Union{Float64, Vector{Float64}} : The time step value or vector of time steps. Keyword Arguments system_labels::Vector{String} = string.(1:length(systems)) : The labels for each system. system_weights::Vector{Float64} = fill(1.0, length(systems)) : The weights for each system. init_trajectory::Union{NamedTrajectory, Nothing} = nothing : The initial trajectory. state_name::Symbol = :Ũ⃗ : The name of the state variable. control_name::Symbol = :a : The name of the control variable. timestep_name::Symbol = :Δt : The name of the timestep variable. constraints::Vector{<:AbstractConstraint} = AbstractConstraint[] : The constraints. a_bound::Float64 = 1.0 : The bound for the control amplitudes. a_bounds::Vector{Float64} = fill(a_bound, length(systems[1].G_drives)) : The bounds for the control amplitudes. a_guess::Union{Matrix{Float64}, Nothing} = nothing : The initial guess for the control amplitudes. da_bound::Float64 = Inf : The bound for the control first derivatives. da_bounds::Vector{Float64} = fill(da_bound, length(systems[1].G_drives)) : The bounds for the control first derivatives. dda_bound::Float64 = 1.0 : The bound for the control second derivatives. dda_bounds::Vector{Float64} = fill(dda_bound, length(systems[1].G_drives)) : The bounds for the control second derivatives. Δt_min::Float64 = 0.5 * Δt : The minimum time step size. Δt_max::Float64 = 1.5 * Δt : The maximum time step size. Q::Float64 = 100.0 : The fidelity weight. R::Float64 = 1e-2 : The regularization weight. R_a::Union{Float64, Vector{Float64}} = R : The regularization weight for the control amplitudes. R_da::Union{Float64, Vector{Float64}} = R : The regularization weight for the control first derivatives. R_dda::Union{Float64, Vector{Float64}} = R : The regularization weight for the control second derivatives. piccolo_options::PiccoloOptions = PiccoloOptions() : The Piccolo options. source A sampling problem is used to solve over multiple quantum systems with the same control. This can be useful for exploring robustness, for example. create a sampling problem driftless_system = QuantumSystem([PAULIS.X, PAULIS.Y])\nsampling_prob = UnitarySamplingProblem([system, driftless_system], U_goal, T, Δt);     constructing UnitarySamplingProblem...\n\tusing integrator: typeof(UnitaryIntegrator)\n\tusing 2 systems\n\tapplying timesteps_all_equal constraint: Δt new keys are addded to the trajectory for the new states println(sampling_prob.trajectory.state_names) (:Ũ⃗_system_1, :a, :da, :Ũ⃗_system_2) the  solve!  proceeds as in the  Quantum State Sampling Problem ]"},{"id":126,"pagetitle":"Unitary Problem Templates","title":"Unitary Variational Problem","ref":"/QuantumCollocation/stable/generated/man/unitary_problem_templates/#Unitary-Variational-Problem","content":" Unitary Variational Problem"},{"id":127,"pagetitle":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem","ref":"/QuantumCollocation/stable/generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem-generated-man-unitary_problem_templates","content":" QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem  —  Function UnitaryVariationalProblem(\n    system::VariationalQuantumSystem,\n    goal::AbstractPiccoloOperator,\n    T::Int,\n    Δt::Union{Float64, <:AbstractVector{Float64}};\n    robust_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    sensitive_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    kwargs...\n) Constructs a unitary variational problem for optimizing quantum control trajectories. Arguments system::VariationalQuantumSystem : The quantum system to be controlled, containing variational parameters. goal::AbstractPiccoloOperator : The target operator or state to achieve at the end of the trajectory. T::Int : The total number of timesteps in the trajectory. Δt::Union{Float64, <:AbstractVector{Float64}} : The timestep duration or a vector of timestep durations. robust_times::AbstractVector : Times at which robustness to variations in the trajectory is enforced. sensitive_times::AbstractVector : Times at which sensitivity to variations in the trajectory is enhanced. unitary_integrator : The integrator used for unitary evolution (default:  VariationalUnitaryIntegrator ). state_name::Symbol : The name of the state variable in the trajectory (default:  :Ũ⃗ ). variational_state_name::Symbol : The name of the variational state variable (default:  :Ũ⃗ₐ ). variational_scales::AbstractVector : Scaling factors for the variational state variables (default:  1.0 ). control_name::Symbol : The name of the control variable (default:  :a ). timestep_name::Symbol : The name of the timestep variable (default:  :Δt ). init_trajectory::Union{NamedTrajectory, Nothing} : An optional initial trajectory to start optimization. a_bound::Float64 : The bound for the control variable  a  (default:  1.0 ). a_bounds::Vector : Bounds for each control variable (default: filled with  a_bound ). da_bound::Float64 : The bound for the derivative of the control variable (default:  Inf ). da_bounds::Vector : Bounds for each derivative of the control variable. dda_bound::Float64 : The bound for the second derivative of the control variable (default:  1.0 ). dda_bounds::Vector : Bounds for each second derivative of the control variable. Δt_min::Float64 : Minimum allowed timestep duration. Δt_max::Float64 : Maximum allowed timestep duration. Q::Float64 : Weight for the unitary infidelity objective (default:  100.0 ). Q_v::Float64 : Weight for sensitivity objectives (default:  1.0 ). R : Regularization weight for control variables (default:  1e-2 ). R_a ,  R_da ,  R_dda : Regularization weights for control, its derivative, and second derivative. constraints::Vector : Additional constraints for the optimization problem. piccolo_options::PiccoloOptions : Options for configuring the Piccolo optimization framework. Returns A  DirectTrajOptProblem  object representing the optimization problem, including the  trajectory, objective, integrators, and constraints. Notes This function constructs a trajectory optimization problem for quantum control using  variational principles. It supports robust and sensitive trajectory design, regularization,  and optional constraints. The problem is solved using the Piccolo optimization framework. source The  UnitaryVariationalProblem  uses a  VariationalQuantumSystem  to find a control that is sensitive or robust to terms in the Hamiltonian. See the documentation for the  VariationalQuantumSystem  in  PiccoloQuantumObjects.jl  for more details. create a variational system, with a variational Hamiltonian,  PAULIS.X H_var = PAULIS.X\nvarsys = VariationalQuantumSystem([PAULIS.X, PAULIS.Y], [H_var]); create a variational problem that is robust to  PAULIS.X  at the end robprob = UnitaryVariationalProblem(varsys, U_goal, T, Δt, robust_times=[[T]]);     constructing UnitaryVariationalProblem...\n\tusing integrator: typeof(VariationalUnitaryIntegrator)\n\ttotal variational parameters: 1\n\tcontrol derivative names: [:da, :dda]\n\tapplying timesteps_all_equal constraint: Δt This page was generated using  Literate.jl ."},{"id":130,"pagetitle":"Library","title":"Library","ref":"/QuantumCollocation/stable/lib/#Library","content":" Library"},{"id":131,"pagetitle":"Library","title":"Problem Templates","ref":"/QuantumCollocation/stable/lib/#Problem-Templates","content":" Problem Templates"},{"id":132,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","content":" QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem  —  Function QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)\nQuantumStateMinimumTimeProblem(prob; kwargs...) Construct a  DirectTrajOptProblem  for the minimum time problem of reaching a target state. Keyword Arguments state_name::Symbol=:ψ̃ : The symbol for the state variables. final_fidelity::Union{Real, Nothing}=nothing : The final fidelity. D=1.0 : The cost weight on the time. piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. source"},{"id":133,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","content":" QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem  —  Function source"},{"id":134,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","content":" QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem  —  Function QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...) Create a quantum state smooth pulse problem. The goal is to find a control pulse  a(t)   that drives all of the initial states  ψ_inits  to the corresponding target states   ψ_goals  using  T  timesteps of size  Δt . This problem also controls the  first and  second derivatives of the control pulse,  da(t)  and  dda(t) , to ensure smoothness. Arguments system::AbstractQuantumSystem : The quantum system. or H_drift::AbstractMatrix{<:Number} : The drift Hamiltonian. H_drives::Vector{<:AbstractMatrix{<:Number}} : The control Hamiltonians. with ψ_inits::Vector{<:AbstractVector{<:ComplexF64}} : The initial states. ψ_goals::Vector{<:AbstractVector{<:ComplexF64}} : The target states. or ψ_init::AbstractVector{<:ComplexF64} : The initial state. ψ_goal::AbstractVector{<:ComplexF64} : The target state. with T::Int : The number of timesteps. Δt::Float64 : The timestep size. Keyword Arguments state_name::Symbol=:ψ̃ : The name of the state variable. control_name::Symbol=:a : The name of the control variable. timestep_name::Symbol=:Δt : The name of the timestep variable. init_trajectory::Union{NamedTrajectory, Nothing}=nothing : The initial trajectory. a_bound::Float64=1.0 : The bound on the control pulse. a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)) : The bounds on the control pulse. a_guess::Union{Matrix{Float64}, Nothing}=nothing : The initial guess for the control pulse. da_bound::Float64=Inf : The bound on the first derivative of the control pulse. da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)) : The bounds on the first derivative of the control pulse. dda_bound::Float64=1.0 : The bound on the second derivative of the control pulse. dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)) : The bounds on the second derivative of the control pulse. Δt_min::Float64=0.5 * Δt : The minimum timestep size. Δt_max::Float64=1.5 * Δt : The maximum timestep size. drive_derivative_σ::Float64=0.01 : The standard deviation of the drive derivative random initialization. Q::Float64=100.0 : The weight on the state objective. R=1e-2 : The weight on the control pulse and its derivatives. R_a::Union{Float64, Vector{Float64}}=R : The weight on the control pulse. R_da::Union{Float64, Vector{Float64}}=R : The weight on the first derivative of the control pulse. R_dda::Union{Float64, Vector{Float64}}=R : The weight on the second derivative of the control pulse. constraints::Vector{<:AbstractConstraint}=AbstractConstraint[] : The constraints. piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. source"},{"id":135,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","content":" QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem  —  Function UnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    trajectory::NamedTrajectory,\n    objective::Objective,\n    dynamics::TrajectoryDynamics,\n    constraints::AbstractVector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    prob::DirectTrajOptProblem;\n    kwargs...\n) Create a minimum-time problem for unitary control. \\[\\begin{aligned}\n\\underset{\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}, \\Delta t}{\\text{minimize}} & \\quad\nJ(\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}) + D \\sum_t \\Delta t_t \\\\\n\\text{ subject to } & \\quad \\vb{P}^{(n)}\\qty(\\vec{\\tilde{U}}_{t+1}, \\vec{\\tilde{U}}_t, a_t, \\Delta t_t) = 0 \\\\\n& c(\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}) = 0 \\\\\n& \\quad \\Delta t_{\\text{min}} \\leq \\Delta t_t \\leq \\Delta t_{\\text{max}} \\\\\n\\end{aligned}\\] Keyword Arguments piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. unitary_name::Symbol=:Ũ⃗ : The name of the unitary for the goal. final_fidelity::Float64=1.0 : The final fidelity constraint. D::Float64=1.0 : The scaling factor for the minimum-time objective. source"},{"id":136,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySamplingProblem","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-Tuple{AbstractVector{<:PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem}, AbstractVector{<:PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator}, Int64, Union{Float64, Vector{Float64}}}","content":" QuantumCollocation.ProblemTemplates.UnitarySamplingProblem  —  Method UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...) A  UnitarySamplingProblem  is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control  pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty. Arguments systems::AbstractVector{<:AbstractQuantumSystem} : A vector of quantum systems. operators::AbstractVector{<:AbstractPiccoloOperator} : A vector of target operators. T::Int : The number of time steps. Δt::Union{Float64, Vector{Float64}} : The time step value or vector of time steps. Keyword Arguments system_labels::Vector{String} = string.(1:length(systems)) : The labels for each system. system_weights::Vector{Float64} = fill(1.0, length(systems)) : The weights for each system. init_trajectory::Union{NamedTrajectory, Nothing} = nothing : The initial trajectory. state_name::Symbol = :Ũ⃗ : The name of the state variable. control_name::Symbol = :a : The name of the control variable. timestep_name::Symbol = :Δt : The name of the timestep variable. constraints::Vector{<:AbstractConstraint} = AbstractConstraint[] : The constraints. a_bound::Float64 = 1.0 : The bound for the control amplitudes. a_bounds::Vector{Float64} = fill(a_bound, length(systems[1].G_drives)) : The bounds for the control amplitudes. a_guess::Union{Matrix{Float64}, Nothing} = nothing : The initial guess for the control amplitudes. da_bound::Float64 = Inf : The bound for the control first derivatives. da_bounds::Vector{Float64} = fill(da_bound, length(systems[1].G_drives)) : The bounds for the control first derivatives. dda_bound::Float64 = 1.0 : The bound for the control second derivatives. dda_bounds::Vector{Float64} = fill(dda_bound, length(systems[1].G_drives)) : The bounds for the control second derivatives. Δt_min::Float64 = 0.5 * Δt : The minimum time step size. Δt_max::Float64 = 1.5 * Δt : The maximum time step size. Q::Float64 = 100.0 : The fidelity weight. R::Float64 = 1e-2 : The regularization weight. R_a::Union{Float64, Vector{Float64}} = R : The regularization weight for the control amplitudes. R_da::Union{Float64, Vector{Float64}} = R : The regularization weight for the control first derivatives. R_dda::Union{Float64, Vector{Float64}} = R : The regularization weight for the control second derivatives. piccolo_options::PiccoloOptions = PiccoloOptions() : The Piccolo options. source"},{"id":137,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","content":" QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem  —  Function UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator, T, Δt; kwargs...)\nUnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...) Construct a  DirectTrajOptProblem  for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e., \\[\\begin{aligned}\n\\underset{\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}, \\Delta t}{\\text{minimize}} & \\quad\nQ \\cdot \\ell\\qty(\\vec{\\tilde{U}}_T, \\vec{\\tilde{U}}_{\\text{goal}}) + \\frac{1}{2} \\sum_t \\qty(R_a a_t^2 + R_{\\dot{a}} \\dot{a}_t^2 + R_{\\ddot{a}} \\ddot{a}_t^2) \\\\\n\\text{ subject to } & \\quad \\vb{P}^{(n)}\\qty(\\vec{\\tilde{U}}_{t+1}, \\vec{\\tilde{U}}_t, a_t, \\Delta t_t) = 0 \\\\\n& \\quad a_{t+1} - a_t - \\dot{a}_t \\Delta t_t = 0 \\\\\n& \\quad \\dot{a}_{t+1} - \\dot{a}_t - \\ddot{a}_t \\Delta t_t = 0 \\\\\n& \\quad |a_t| \\leq a_{\\text{bound}} \\\\\n& \\quad |\\ddot{a}_t| \\leq \\ddot{a}_{\\text{bound}} \\\\\n& \\quad \\Delta t_{\\text{min}} \\leq \\Delta t_t \\leq \\Delta t_{\\text{max}} \\\\\n\\end{aligned}\\] where, for  $U \\in SU(N)$ , \\[\\ell\\qty(\\vec{\\tilde{U}}_T, \\vec{\\tilde{U}}_{\\text{goal}}) =\n\\abs{1 - \\frac{1}{N} \\abs{ \\tr \\qty(U_{\\text{goal}}, U_T)} }\\] is the  infidelity  objective function,  $Q$  is a weight,  $R_a$ ,  $R_{\\dot{a}}$ , and  $R_{\\ddot{a}}$  are weights on the regularization terms, and  $\\vb{P}^{(n)}$  is the  $n$ th-order Pade integrator. Arguments system::AbstractQuantumSystem : the system to be controlled or H_drift::AbstractMatrix{<:Number} : the drift hamiltonian H_drives::Vector{<:AbstractMatrix{<:Number}} : the control hamiltonians with goal::AbstractPiccoloOperator : the target unitary, either in the form of an  EmbeddedOperator  or a `Matrix{ComplexF64} T::Int : the number of timesteps Δt::Float64 : the (initial) time step size Keyword Arguments piccolo_options::PiccoloOptions=PiccoloOptions() : the options for the Piccolo solver state_name::Symbol = :Ũ⃗ : the name of the state control_name::Symbol = :a : the name of the control timestep_name::Symbol = :Δt : the name of the timestep init_trajectory::Union{NamedTrajectory, Nothing}=nothing : an initial trajectory to use a_guess::Union{Matrix{Float64}, Nothing}=nothing : an initial guess for the control pulses a_bound::Float64=1.0 : the bound on the control pulse a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)) : the bounds on the control pulses, one for each drive da_bound::Float64=Inf : the bound on the control pulse derivative da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives)) : the bounds on the control pulse derivatives, one for each drive dda_bound::Float64=1.0 : the bound on the control pulse second derivative dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)) : the bounds on the control pulse second derivatives, one for each drive Δt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt) : the minimum time step size Δt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt) : the maximum time step size Q::Float64=100.0 : the weight on the infidelity objective R=1e-2 : the weight on the regularization terms R_a::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulses R_da::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulse derivatives R_dda::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulse second derivatives constraints::Vector{<:AbstractConstraint}=AbstractConstraint[] : the constraints to enforce source"},{"id":138,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem","content":" QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem  —  Function UnitaryVariationalProblem(\n    system::VariationalQuantumSystem,\n    goal::AbstractPiccoloOperator,\n    T::Int,\n    Δt::Union{Float64, <:AbstractVector{Float64}};\n    robust_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    sensitive_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    kwargs...\n) Constructs a unitary variational problem for optimizing quantum control trajectories. Arguments system::VariationalQuantumSystem : The quantum system to be controlled, containing variational parameters. goal::AbstractPiccoloOperator : The target operator or state to achieve at the end of the trajectory. T::Int : The total number of timesteps in the trajectory. Δt::Union{Float64, <:AbstractVector{Float64}} : The timestep duration or a vector of timestep durations. robust_times::AbstractVector : Times at which robustness to variations in the trajectory is enforced. sensitive_times::AbstractVector : Times at which sensitivity to variations in the trajectory is enhanced. unitary_integrator : The integrator used for unitary evolution (default:  VariationalUnitaryIntegrator ). state_name::Symbol : The name of the state variable in the trajectory (default:  :Ũ⃗ ). variational_state_name::Symbol : The name of the variational state variable (default:  :Ũ⃗ₐ ). variational_scales::AbstractVector : Scaling factors for the variational state variables (default:  1.0 ). control_name::Symbol : The name of the control variable (default:  :a ). timestep_name::Symbol : The name of the timestep variable (default:  :Δt ). init_trajectory::Union{NamedTrajectory, Nothing} : An optional initial trajectory to start optimization. a_bound::Float64 : The bound for the control variable  a  (default:  1.0 ). a_bounds::Vector : Bounds for each control variable (default: filled with  a_bound ). da_bound::Float64 : The bound for the derivative of the control variable (default:  Inf ). da_bounds::Vector : Bounds for each derivative of the control variable. dda_bound::Float64 : The bound for the second derivative of the control variable (default:  1.0 ). dda_bounds::Vector : Bounds for each second derivative of the control variable. Δt_min::Float64 : Minimum allowed timestep duration. Δt_max::Float64 : Maximum allowed timestep duration. Q::Float64 : Weight for the unitary infidelity objective (default:  100.0 ). Q_v::Float64 : Weight for sensitivity objectives (default:  1.0 ). R : Regularization weight for control variables (default:  1e-2 ). R_a ,  R_da ,  R_dda : Regularization weights for control, its derivative, and second derivative. constraints::Vector : Additional constraints for the optimization problem. piccolo_options::PiccoloOptions : Options for configuring the Piccolo optimization framework. Returns A  DirectTrajOptProblem  object representing the optimization problem, including the  trajectory, objective, integrators, and constraints. Notes This function constructs a trajectory optimization problem for quantum control using  variational principles. It supports robust and sensitive trajectory design, regularization,  and optional constraints. The problem is solved using the Piccolo optimization framework. source"},{"id":139,"pagetitle":"Library","title":"Options","ref":"/QuantumCollocation/stable/lib/#Options","content":" Options"},{"id":140,"pagetitle":"Library","title":"QuantumCollocation.Options.PiccoloOptions","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.Options.PiccoloOptions","content":" QuantumCollocation.Options.PiccoloOptions  —  Type PiccoloOptions Options for the Piccolo quantum optimal control library. Fields verbose::Bool = true : Print verbose output timesteps_all_equal::Bool = true : Use equal timesteps rollout_integrator::Function = expv : Integrator to use for rollout geodesic = true : Use the geodesic to initialize the optimization. zero_initial_and_final_derivative::Bool=false : Zero the initial and final control pulse derivatives. complex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing : Name of the complex control norm constraint. complex_control_norm_constraint_radius::Float64 = 1.0 : Radius of the complex control norm constraint. bound_state::Bool = false : Bound the state. leakage_suppression::Bool = false : Suppress leakage. R_leakage::Float64 = 1.0 : Leakage suppression parameter. source"},{"id":141,"pagetitle":"Library","title":"Trajectory Initialization","ref":"/QuantumCollocation/stable/lib/#Trajectory-Initialization","content":" Trajectory Initialization"},{"id":142,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractVector{<:AbstractVector{ComplexF64}}, AbstractVector{<:AbstractVector{ComplexF64}}, Int64, Union{Real, AbstractVector{<:Real}}, Vararg{Any}}","content":" QuantumCollocation.TrajectoryInitialization.initialize_trajectory  —  Method initialize_trajectory Trajectory initialization of quantum states. source"},{"id":143,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Any, Any, Int64, Union{Real, AbstractVecOrMat{<:Real}}, Vararg{Any}}","content":" QuantumCollocation.TrajectoryInitialization.initialize_trajectory  —  Method initialize_trajectory Trajectory initialization of density matrices. source"},{"id":144,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator, Int64, Union{Real, AbstractVecOrMat{<:Real}}, Vararg{Any}}","content":" QuantumCollocation.TrajectoryInitialization.initialize_trajectory  —  Method initialize_trajectory Trajectory initialization of unitaries. source"},{"id":145,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Vector{<:AbstractMatrix{Float64}}, Vector{<:AbstractVector{Float64}}, Vector{<:AbstractVector{Float64}}, AbstractVector{Symbol}, Int64, Union{Float64, AbstractVecOrMat{<:Float64}}, Int64, Tuple{Vararg{Union{Tuple{AbstractVector{R}, AbstractVector{R}}, AbstractVector{R}} where R<:Real}}}","content":" QuantumCollocation.TrajectoryInitialization.initialize_trajectory  —  Method initialize_trajectory Initialize a trajectory for a control problem. The trajectory is initialized with data that should be consistently the same type (in this case, Float64). source"},{"id":146,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_geodesic","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.TrajectoryInitialization.unitary_geodesic","content":" QuantumCollocation.TrajectoryInitialization.unitary_geodesic  —  Function unitary_geodesic(\n    operator::EmbeddedOperator,\n    samples::Int;\n    kwargs...\n)\n\nunitary_geodesic(\n    U_goal::AbstractMatrix{<:Number},\n    samples::Int;\n    kwargs...\n)\n\nunitary_geodesic(\n    U₀::AbstractMatrix{<:Number},\n    U₁::AbstractMatrix{<:Number},\n    samples::Number;\n    kwargs...\n)\n\nunitary_geodesic(\n    U₀::AbstractMatrix{<:Number},\n    U₁::AbstractMatrix{<:Number},\n    timesteps::AbstractVector{<:Number};\n    return_generator=false\n) Compute a geodesic connecting two unitary operators. source"},{"id":147,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_geodesic","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.TrajectoryInitialization.unitary_geodesic-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, AbstractVector{<:Number}}","content":" QuantumCollocation.TrajectoryInitialization.unitary_geodesic  —  Method unitary_geodesic(U_init, U_goal, times; kwargs...) Compute the geodesic connecting U init and U goal at the specified times. Allows for the possibility of unequal times and ranges outside [0,1]. Arguments U_init::AbstractMatrix{<:Number} : The initial unitary operator. U_goal::AbstractMatrix{<:Number} : The goal unitary operator. times::AbstractVector{<:Number} : The times at which to evaluate the geodesic. Keyword Arguments return_unitary_isos::Bool=true : If true returns a matrix where each column is a unitary isovec, i.e. vec(vcat(real(U), imag(U))). If false, returns a vector of unitary matrices. return_generator::Bool=false : If true, returns the effective Hamiltonian generating the geodesic. source"},{"id":148,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation","ref":"/QuantumCollocation/stable/lib/#QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Int64}","content":" QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation  —  Method unitary_linear_interpolation(\n    U_init::AbstractMatrix,\n    U_goal::AbstractMatrix,\n    samples::Int\n) Compute a linear interpolation of unitary operators with  samples  samples. source"},{"id":149,"pagetitle":"Library","title":"Trajectory Interpolations","ref":"/QuantumCollocation/stable/lib/#Trajectory-Interpolations","content":" Trajectory Interpolations"},{"id":152,"pagetitle":"Home","title":"NamedTrajectories.jl","ref":"/NamedTrajectories/stable/#NamedTrajectories.jl","content":" NamedTrajectories.jl An elegant way to handle messy trajectory data Notice This package is under active development and issues may arise – please be patient and report any issues you find!  "},{"id":153,"pagetitle":"Home","title":"Motivation","ref":"/NamedTrajectories/stable/#Motivation","content":" Motivation NamedTrajectories.jl  is designed to aid in the messy indexing involved in solving trajectory optimization problems of the form \\[\\begin{align*}\n\\underset{u^1_{1:T}, \\dots, u^{n_c}_{1:T}}{\\underset{x^1_{1:T}, \\cdots, x^{n_s}_{1:T}}{\\operatorname{minimize}}} &\\quad J\\qty(x^{1:n_s}_{1:T},u^{1:n_c}_{1:T}) \\\\\n\\text{subject to} & \\quad f\\qty(x^{1:n_s}_{1:T},u^{1:n_c}_{1:T}) = 0 \\\\\n& \\quad x^i_1 = x^i_{\\text{initial}} \\\\\n& \\quad x^i_T = x^i_{\\text{final}} \\\\\n& \\quad u^i_1 = u^i_{\\text{initial}} \\\\\n& \\quad u^i_T = u^i_{\\text{final}} \\\\\n& \\quad x^i_{\\min} < x^i_t < x^i_{\\max} \\\\\n& \\quad u^i_{\\min} < u^i_t < u^i_{\\max} \\\\\n\\end{align*}\\] Where  $x^i_t$  is the  $i$ th state variable and  $u^i_t$  is the  $i$ th control variable at timestep  $t$ ; state and control variables can be of arbitrary dimension. The function  $f$  is a nonlinear constraint function and  $J$  is the objective function. These problems can have an arbitrary number of state ( $n_s$ ) and control ( $n_c$ ) variables, and the number of timesteps  $T$  can vary as well.   In trajectory optimization problems it is common practice to bundle all of the state and control variables together into a single  knot point \\[z_t = \\mqty(\n    x^1_t \\\\\n    \\vdots \\\\\n    x^{n_s}_t \\\\\n    u^1_t \\\\\n    \\vdots \\\\\n    u^{n_c}_t\n).\\] The trajectory optimization problem can then be succinctly written as \\[\\begin{align*}\n\\underset{z_{1:T}}{\\operatorname{minimize}} &\\quad J\\qty(z_{1:T}) \\\\\n\\text{subject to} & \\quad f\\qty(z_{1:T}) = 0 \\\\\n& \\quad z_1 = z_{\\text{initial}} \\\\\n& \\quad z_T = z_{\\text{final}} \\\\\n& \\quad z_{\\min} < z_t < z_{\\max} \\\\\n\\end{align*}\\] The  NamedTrajectories  package provides a  NamedTrajectory  type which abstracts away the messy indexing and vectorization details required for interfacing with numerical solvers.  It also provides a variety of helpful methods for common tasks.  For example, you can access the data by name or index.  In the case of an index, a  KnotPoint  is returned which contains the data for that timestep."},{"id":154,"pagetitle":"Home","title":"Features","ref":"/NamedTrajectories/stable/#Features","content":" Features Abstract away messy indexing and vectorization details required for interfacing with numerical solvers. Easily handle multiple trajectories with different names, e.g. various states and controls. Simple plotting of trajectories. Provide a variety of helpful methods for common tasks."},{"id":155,"pagetitle":"Home","title":"Index","ref":"/NamedTrajectories/stable/#Index","content":" Index NamedTrajectories.MethodsNamedTrajectory.add_component! NamedTrajectories.MethodsNamedTrajectory.get_component_names NamedTrajectories.MethodsNamedTrajectory.get_components NamedTrajectories.MethodsNamedTrajectory.get_duration NamedTrajectories.MethodsNamedTrajectory.get_times NamedTrajectories.MethodsNamedTrajectory.get_timesteps NamedTrajectories.MethodsNamedTrajectory.merge_outer NamedTrajectories.MethodsNamedTrajectory.remove_component NamedTrajectories.MethodsNamedTrajectory.remove_components NamedTrajectories.MethodsNamedTrajectory.update! NamedTrajectories.MethodsNamedTrajectory.update! NamedTrajectories.MethodsNamedTrajectory.update_bound! Base.:== Base.copy Base.getindex Base.getindex Base.getindex Base.getproperty Base.isequal Base.lastindex Base.length Base.merge Base.rand Base.setproperty! Base.size Base.vec"},{"id":158,"pagetitle":"Adding and removing variables","title":"Adding and removing variables","ref":"/NamedTrajectories/stable/generated/man/add_remove/#Adding-and-removing-variables","content":" Adding and removing variables This page was generated using  Literate.jl ."},{"id":161,"pagetitle":"Constructors","title":"Constructors","ref":"/NamedTrajectories/stable/generated/man/constructors/#Constructors","content":" Constructors To construct a  NamedTrajectory  using NamedTrajectories.jl, we simply need to utilize the  NamedTrajectory  constructor. using NamedTrajectories\n\n# define number of timesteps and timestep\nT = 10\ndt = 0.1 0.1 build named tuple of components and data matrices. components = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = fill(dt, 1, T),\n) (x = [0.4961370332791444 0.23237820105313567 … 0.6844197715635315 0.6361929387686569; 0.008717346235256551 0.2636940050947565 … 0.2922208682028965 0.5956562698748092; 0.35652616846349006 0.0056948857589705915 … 0.19200473691928943 0.8329103228848768], u = [0.8294909770046149 0.08928178155816935 … 0.9911584036098497 0.0009350735740885074; 0.7421717979342167 0.08764582176322355 … 0.14236442296107765 0.020438567213176717], Δt = [0.1 0.1 … 0.1 0.1]) we must specify a timestep and control variable for the trajectory. timestep = 0.1\ncontrol = :u :u we can now create a  NamedTrajectory  object. traj = NamedTrajectory(components; timestep=timestep, controls=control) NamedTrajectory{Float64}([0.4961370332791444 0.23237820105313567 … 0.6844197715635315 0.6361929387686569; 0.008717346235256551 0.2636940050947565 … 0.2922208682028965 0.5956562698748092; … ; 0.7421717979342167 0.08764582176322355 … 0.14236442296107765 0.020438567213176717; 0.1 0.1 … 0.1 0.1], [0.4961370332791444, 0.008717346235256551, 0.35652616846349006, 0.8294909770046149, 0.7421717979342167, 0.1, 0.23237820105313567, 0.2636940050947565, 0.0056948857589705915, 0.08928178155816935  …  0.19200473691928943, 0.9911584036098497, 0.14236442296107765, 0.1, 0.6361929387686569, 0.5956562698748092, 0.8329103228848768, 0.0009350735740885074, 0.020438567213176717, 0.1], 10, 0.1, 6, (x = 3, u = 2, Δt = 1, states = 4, controls = 2), NamedTuple(), NamedTuple(), NamedTuple(), NamedTuple(), (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3, 6], controls = [4, 5]), NamedTuple(), 0, NamedTuple(), NamedTuple(), (:x, :u, :Δt), (:x, :Δt), (:u,)) Construct  NamedTrajectory  from previous constructed one. traj = NamedTrajectory(components, traj) NamedTrajectory{Float64}([0.4961370332791444 0.23237820105313567 … 0.6844197715635315 0.6361929387686569; 0.008717346235256551 0.2636940050947565 … 0.2922208682028965 0.5956562698748092; … ; 0.7421717979342167 0.08764582176322355 … 0.14236442296107765 0.020438567213176717; 0.1 0.1 … 0.1 0.1], [0.4961370332791444, 0.008717346235256551, 0.35652616846349006, 0.8294909770046149, 0.7421717979342167, 0.1, 0.23237820105313567, 0.2636940050947565, 0.0056948857589705915, 0.08928178155816935  …  0.19200473691928943, 0.9911584036098497, 0.14236442296107765, 0.1, 0.6361929387686569, 0.5956562698748092, 0.8329103228848768, 0.0009350735740885074, 0.020438567213176717, 0.1], 10, 0.1, 6, (x = 3, u = 2, Δt = 1, states = 4, controls = 2), NamedTuple(), NamedTuple(), NamedTuple(), NamedTuple(), (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3, 6], controls = [4, 5]), NamedTuple(), 0, NamedTuple(), NamedTuple(), (:x, :u, :Δt), (:x, :Δt), (:u,)) This page was generated using  Literate.jl ."},{"id":164,"pagetitle":"Copying and equality","title":"Copying and equality","ref":"/NamedTrajectories/stable/generated/man/copy_equality/#Copying-and-equality","content":" Copying and equality This page was generated using  Literate.jl ."},{"id":167,"pagetitle":"Operations with other trajectories","title":"Operations with other trajectories","ref":"/NamedTrajectories/stable/generated/man/operations/#Operations-with-other-trajectories","content":" Operations with other trajectories This page was generated using  Literate.jl ."},{"id":170,"pagetitle":"Add params in NamedTrajectory","title":"Add params in NamedTrajectory","ref":"/NamedTrajectories/stable/generated/man/params_in_struct/#Add-params-in-NamedTrajectory","content":" Add params in NamedTrajectory NamedTrajectory.jl support passing parameters as a Tuple when construct a  NamedTrajectory . using NamedTrajectories First we need to define number of timesteps and timestep T = 10\ndt = 0.1 0.1 then build named tuple of components and data matrices. components = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = fill(dt, 1, T),\n) (x = [0.3476620977699856 0.198619726446566 … 0.39803866393272225 0.6265174753283287; 0.8046466894423636 0.03134785864356637 … 0.8478921369175382 0.4884145755865088; 0.5666698416360124 0.13976133295517412 … 0.3868516834167772 0.46920304578004846], u = [0.1890540644490638 0.9565296024971514 … 0.9792809421326739 0.4172647591081198; 0.18425375127058363 0.9004171437218287 … 0.0957184688500965 0.9101760015037146], Δt = [0.1 0.1 … 0.1 0.1]) we must specify a timestep and control variable for the trajectory. timestep = 0.1\ncontrol = :u :u some global params as a NamedTuple params = (\n    α = rand(1),\n    β = rand(1)\n) (α = [0.8572905072360408], β = [0.6245809076559321]) we can now create a  NamedTrajectory  object with parameters specification. traj = NamedTrajectory(components; timestep=timestep, controls=control, global_data=params) NamedTrajectory{Float64}([0.3476620977699856 0.198619726446566 … 0.39803866393272225 0.6265174753283287; 0.8046466894423636 0.03134785864356637 … 0.8478921369175382 0.4884145755865088; … ; 0.18425375127058363 0.9004171437218287 … 0.0957184688500965 0.9101760015037146; 0.1 0.1 … 0.1 0.1], [0.3476620977699856, 0.8046466894423636, 0.5666698416360124, 0.1890540644490638, 0.18425375127058363, 0.1, 0.198619726446566, 0.03134785864356637, 0.13976133295517412, 0.9565296024971514  …  0.3868516834167772, 0.9792809421326739, 0.0957184688500965, 0.1, 0.6265174753283287, 0.4884145755865088, 0.46920304578004846, 0.4172647591081198, 0.9101760015037146, 0.1], 10, 0.1, 6, (x = 3, u = 2, Δt = 1, states = 4, controls = 2), NamedTuple(), NamedTuple(), NamedTuple(), NamedTuple(), (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3, 6], controls = [4, 5]), (α = [0.8572905072360408], β = [0.6245809076559321]), 2, (α = 1, β = 1), (α = 61:61, β = 62:62), (:x, :u, :Δt), (:x, :Δt), (:u,)) This page was generated using  Literate.jl ."},{"id":173,"pagetitle":"Retrieving data","title":"Retrieving data","ref":"/NamedTrajectories/stable/generated/man/retrieval/#Retrieving-data","content":" Retrieving data This page was generated using  Literate.jl ."},{"id":176,"pagetitle":"Times and timesteps","title":"Times and timesteps","ref":"/NamedTrajectories/stable/generated/man/times/#Times-and-timesteps","content":" Times and timesteps This page was generated using  Literate.jl ."},{"id":179,"pagetitle":"Updating data","title":"Updating data","ref":"/NamedTrajectories/stable/generated/man/updating/#Updating-data","content":" Updating data This page was generated using  Literate.jl ."},{"id":182,"pagetitle":"Manual","title":"Manual","ref":"/NamedTrajectories/stable/generated/manual/#Manual","content":" Manual"},{"id":183,"pagetitle":"Manual","title":"Constructors","ref":"/NamedTrajectories/stable/generated/manual/#Constructors","content":" Constructors"},{"id":184,"pagetitle":"Manual","title":"Retrieving data","ref":"/NamedTrajectories/stable/generated/manual/#Retrieving-data","content":" Retrieving data"},{"id":185,"pagetitle":"Manual","title":"Adding and removing variables","ref":"/NamedTrajectories/stable/generated/manual/#Adding-and-removing-variables","content":" Adding and removing variables"},{"id":186,"pagetitle":"Manual","title":"Updating data and bounds","ref":"/NamedTrajectories/stable/generated/manual/#Updating-data-and-bounds","content":" Updating data and bounds"},{"id":187,"pagetitle":"Manual","title":"Getting times and timesteps","ref":"/NamedTrajectories/stable/generated/manual/#Getting-times-and-timesteps","content":" Getting times and timesteps"},{"id":188,"pagetitle":"Manual","title":"Operations with other trajectories","ref":"/NamedTrajectories/stable/generated/manual/#Operations-with-other-trajectories","content":" Operations with other trajectories"},{"id":189,"pagetitle":"Manual","title":"Copying and equality","ref":"/NamedTrajectories/stable/generated/manual/#Copying-and-equality","content":" Copying and equality This page was generated using  Literate.jl ."},{"id":192,"pagetitle":"Plotting","title":"Plotting","ref":"/NamedTrajectories/stable/generated/plotting/#Plotting","content":" Plotting Visualizing trajectories is crucial for understanding the solutions of trajectory optmization problems and  NamedTrajectories  exports a  plot  function that contains a lot of functionality that is continually being added to.  Makie.jl  is used as the plotting framework, and at the moment the default backend is  CairoMakie , as it creates high quality vector graphics. The function is called as follows:"},{"id":193,"pagetitle":"Plotting","title":"MakieCore.plot","ref":"/NamedTrajectories/stable/generated/plotting/#MakieCore.plot","content":" MakieCore.plot  —  Function plot(traj::NamedTrajectory, comps=traj.names; kwargs...) Plot a  NamedTrajectory  using  CairoMakie . Arguments traj::NamedTrajectory : the trajectory to plot comps::Union{Symbol, Vector{Symbol}, Tuple{Vararg{Symbol}}} : the components of the trajectory to plot, e.g.,  :x ,  [:x, :u] , or  (:x, :u) . Keyword Arguments component specification ignored_labels::Union{Symbol, Vector{Symbol}, Tuple{Vararg{Symbol}}} : the components of the trajectory to ignore. The default is  () . ignore_timestep::Bool : whether or not to ignore the timestep component of the trajectory. The default is  true . transformations transformations::OrderedDict{Symbol, <:Union{Function, Vector}} : a dictionary of transformations to apply to the components of the trajectory. The keys of the dictionary are the components of the trajectory to transform, and the values are either a single function or a vector of functions to apply to each column of the component. If a single function is provided, it is applied to each column of the component. If a vector of functions is provided, a separate plot is created for each function. The default is an empty  OrderedDict . transformation_labels::Union{Nothing, OrderedDict{Symbol, <:Union{Nothing, <:AbstractString, Vector{<:Union{Nothing, <:AbstractString}}}}} : a dictionary of labels for the transformed components of the trajectory. The keys of the dictionary are the components of the trajectory to transform, and the values are either a single string or a vector of strings that correspond to a vector of transformations. If a single string is provided, it is applied to each transformation of the component. If a vector of strings is provided, a separate label is created for each function. The default is  nothing . include_transformation_labels::Union{Bool, Vector{<:Union{Bool, Vector{Bool}}}} : a boolean, vector of booleans, or vector of vectors of booleans, that determines whether or not to include the labels for the transformed components of the trajectory. The default is  false . transformation_titles::Union{Nothing, OrderedDict{Symbol, <:Union{<:AbstractString, Vector{String}}}} : a dictionary of titles for the transformed components of the trajectory. The keys of the dictionary are the components of the trajectory to transform, and the values are either a single string or a vector of strings that correspond to a vector of transformations. If a single string is provided, it is applied to each transformation of the component. If a vector of strings is provided, a separate title is created for each function. The default is  nothing . style fig_size::Tuple{Int, Int} : the size of the figure,  (width, height) . The default is  (1200, 800) . titlesize::Int : the size of the titles. The default is  25 . series_color::Symbol : the color of the series. The default is  :glasbey_bw_minc_20_n256 . See options  here markersize : the size of the markers. The default is  5 . other kwargs... : keyword arguments passed to  CairoMakie.series! . source"},{"id":194,"pagetitle":"Plotting","title":"Basic example","ref":"/NamedTrajectories/stable/generated/plotting/#Basic-example","content":" Basic example Let's first create a simple trajectory to plot using NamedTrajectories\n\n# define the number timestamps\nT = 100\nΔt = 0.1\nts = [0:T-1...] * Δt\n\n# define sinusoidal state trajectories\nX = zeros(3, T)\nX[1, :] = sin.(3 * 2π * ts / (2 * (T - 1) * Δt))\nX[2, :] = -sin.(5 * 2π * ts / (2 * (T - 1) * Δt))\nX[3, :] = sin.(9 * 2π * ts / (2 * (T - 1) * Δt))\n\n# define gaussian shaped controls\nU = stack(\n    [\n        exp.(-((ts .- ts[length(ts)÷3]) / 2.0).^2) .* sin.(5.0 * ts),\n        exp.(-((ts .- ts[2(length(ts)÷3)]) / 1.5).^2) .* sin.(4.0 * ts)\n    ];\n    dims=1\n)\nV = exp.(-((ts .- ts[length(ts)÷2]) ./ 1.5).^2) .* sin.(6.0 * ts)\n\n# create the trajectory\ntraj = NamedTrajectory(\n    (\n        x=X,\n        u=U,\n        v=V\n    );\n    timestep=Δt,\n    controls=(:u, :v)\n)\n\n# plot the trajectory\nplot(traj)"},{"id":195,"pagetitle":"Plotting","title":"Selectively plotting components","ref":"/NamedTrajectories/stable/generated/plotting/#Selectively-plotting-components","content":" Selectively plotting components We can selectively plot components of the trajectory by passing a  Vector  of  Symbol s to the  components  keyword argument. For example, if we only wanted to plot the state and the first control we could do the following: plot(traj, [:x, :u])"},{"id":196,"pagetitle":"Plotting","title":"Playing with transformations","ref":"/NamedTrajectories/stable/generated/plotting/#Playing-with-transformations","content":" Playing with transformations We can also apply transformations to the components of the trajectory. Transformations are performed on columns of the data. For example, if we wanted to plot absolute values of the states we could do the following: transformations = OrderedDict(\n    :x => x -> abs.(x),\n)\n\nplot(traj, [:x]; transformations=transformations) We can also pass multiple transformations to the same component, with selective labels and titles: # define the transformations\ntransformations = OrderedDict(\n    :x => [\n        x -> [x[1] + x[2], x[3] - x[2]],\n        x -> [x[1] - x[2], x[3] + x[2]]\n    ],\n)\n\n# define the labels\ntransformation_labels = OrderedDict(\n    :x => [\n        \"\\\\tilde{x}\",\n        \"\\\\hat{x}\"\n    ],\n)\n\n# define the titles\ntransformation_titles = OrderedDict(\n    :x => [\n        L\"x_1 + x_2, x_3 - x_2\",\n        L\"x_1 - x_2, x_3 + x_2\"\n    ],\n)\n\n# plot the trajectory, with only the transformation and the `u` control\nplot(traj, [:u];\n    transformations=transformations,\n    transformation_labels=transformation_labels,\n    include_transformation_labels=[[true, true]],\n    transformation_titles=transformation_titles,\n) This page was generated using  Literate.jl ."},{"id":199,"pagetitle":"Quickstart Guide","title":"Quickstart Guide","ref":"/NamedTrajectories/stable/generated/quickstart/#Quickstart-Guide","content":" Quickstart Guide"},{"id":200,"pagetitle":"Quickstart Guide","title":"Getting set up","ref":"/NamedTrajectories/stable/generated/quickstart/#Getting-set-up","content":" Getting set up To install  NamedTrajectories  simply enter the package manager in the Julia REPL with  ]  and run pkg> add NamedTrajectories Then just use the package as usual with using NamedTrajectories For the following examples let's work with a simple trajectory \\[\\qty{z_t = \\mqty(x_t \\\\ u_t)}_{t=1:T}\\] where  $x_t$  is the state and  $u_t$  is the control at a time indexed by  $t$ . Together  $z_t$  is referred to as a  knot point  and a  NamedTrajectory  essentially just stores a collection of knot points and makes it easy to access the state and control variables."},{"id":201,"pagetitle":"Quickstart Guide","title":"Creating a fixed-timestep NamedTrajectory","ref":"/NamedTrajectories/stable/generated/quickstart/#Creating-a-fixed-timestep-NamedTrajectory","content":" Creating a fixed-timestep  NamedTrajectory Here we will createa a  NamedTrajectory  with a fixed timestep. This is done by passing a scalar as the  timestep  kwarg. # define the number of timesteps\nT = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n)\n\n# we must specify a timestep and control variable for the trajectory\ntimestep = 0.1\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(data; timestep=timestep, controls=control)\n\n# we can return the names of the stored variables\ntraj.names (:x, :u) Let's plot this trajectory plot(traj)"},{"id":202,"pagetitle":"Quickstart Guide","title":"Creating a variable-timestep NamedTrajectory","ref":"/NamedTrajectories/stable/generated/quickstart/#Creating-a-variable-timestep-NamedTrajectory","content":" Creating a variable-timestep  NamedTrajectory Here we will create a  NamedTrajectory  with a variable timestep. This is done by passing a  Symbol , corresponding to component of the data, as the  timestep  kwarg. # define the number of timesteps\nT = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = rand(T),\n)\n\n# we must specify a timestep and control variable for the NamedTrajectory\ntimestep = :Δt\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(data; timestep=timestep, controls=control)\n\n# we can return the names of the stored variables\ntraj.names (:x, :u, :Δt)"},{"id":203,"pagetitle":"Quickstart Guide","title":"Adding more problem data","ref":"/NamedTrajectories/stable/generated/quickstart/#Adding-more-problem-data","content":" Adding more problem data In many settings we will want to add problem data to our  NamedTrajectory  – e.g. bounds, initial values, final values, and goal values. This is realized by passing NamedTuples containing this data. # define the number of timesteps\nT = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = rand(T),\n)\n\n# define initial values\ninitial = (\n    x = [1.0, 0.0, 0.0],\n    u = [0.0, 0.0],\n)\n\n# define final value, here just on the control\nfinal = (\n    u = [0.0, 0.0],\n)\n\n# define bounds\nbounds = (\n    x = 1.0,\n    u = 1.0\n)\n\n# set a goal for the state\ngoal = (\n    x = [0.0, 0.0, 1.0],\n)\n\n# we must specify a timestep and control variable for the NamedTrajectory\ntimestep = :Δt\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(\n    data;\n    timestep=timestep,\n    controls=control,\n    initial=initial,\n    final=final,\n    bounds=bounds,\n    goal=goal\n)\n\n# we can then show the bounds\ntraj.goal (x = [0.0, 0.0, 1.0],)"},{"id":204,"pagetitle":"Quickstart Guide","title":"Retrieving data","ref":"/NamedTrajectories/stable/generated/quickstart/#Retrieving-data","content":" Retrieving data There are a number of ways to access data, for example traj.x 3×10 Matrix{Float64}:\n 0.339772  0.458011  0.808673   0.810924  …  0.605286  0.433245  0.472111\n 0.475     0.176688  0.0391139  0.5282       0.499439  0.258999  0.987082\n 0.884408  0.392084  0.176183   0.812569     0.664802  0.294856  0.722683 returns the data matrix associated with the state variable  x . traj.data 6×10 reshape(view(::Vector{Float64}, :), 6, 10) with eltype Float64:\n 0.339772  0.458011  0.808673   0.810924   …  0.605286  0.433245  0.472111\n 0.475     0.176688  0.0391139  0.5282        0.499439  0.258999  0.987082\n 0.884408  0.392084  0.176183   0.812569      0.664802  0.294856  0.722683\n 0.989048  0.524702  0.0146634  0.0903063     0.697352  0.536413  0.515899\n 0.245487  0.198962  0.026631   0.0221841     0.499686  0.427416  0.800935\n 0.666301  0.588193  0.0227659  0.74916    …  0.905327  0.40828   0.872352 returns the all of the data as a matrix where each column is a knot point. traj.datavec 60-element Vector{Float64}:\n 0.3397717188399447\n 0.4749996197418046\n 0.8844080846299748\n 0.9890477882571549\n 0.24548746414774825\n 0.6663011881741285\n 0.45801052956750843\n 0.17668843849673366\n 0.39208387030612213\n 0.5247017708732374\n ⋮\n 0.53641270445415\n 0.42741570371746584\n 0.40827955001498695\n 0.4721106341536885\n 0.987081777648369\n 0.7226826899871555\n 0.5158991782222441\n 0.8009349815381217\n 0.872351801302637 returns the all of the data as a view of the data matrix as a vector – useful for passing data to solvers. traj[1] KnotPoint(1, [0.3397717188399447, 0.4749996197418046, 0.8844080846299748, 0.9890477882571549, 0.24548746414774825, 0.6663011881741285], 0.6663011881741285, (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3], controls = [4, 5, 6]), (:x, :u, :Δt), (:u, :Δt)) returns a  KnotPoint . traj[1].x 3-element Vector{Float64}:\n 0.3397717188399447\n 0.4749996197418046\n 0.8844080846299748 returns the state at the first knot point. get_times(traj) 10-element Vector{Float64}:\n 0.0\n 0.6663011881741285\n 1.254493945859989\n 1.2772598147950323\n 2.0264197775237873\n 2.1064604595330456\n 2.208729562579105\n 3.0683799885400234\n 3.973706772397252\n 4.381986322412239 returns the times of the knot points. get_timesteps(traj) 10-element Vector{Float64}:\n 0.6663011881741285\n 0.5881927576858605\n 0.022765868935043065\n 0.749159962728755\n 0.0800406820092584\n 0.10226910304605963\n 0.8596504259609181\n 0.9053267838572284\n 0.40827955001498695\n 0.872351801302637 returns the timesteps of the knot points, as vector."},{"id":205,"pagetitle":"Quickstart Guide","title":"Retrieving metadata","ref":"/NamedTrajectories/stable/generated/quickstart/#Retrieving-metadata","content":" Retrieving metadata We can also retrieve metadata about the trajectory, for example traj.names (:x, :u, :Δt) returns the names of the variables stored in the trajectory. traj.dims (x = 3, u = 2, Δt = 1, states = 3, controls = 3) returns the dimensions of the variables stored in the trajectory. traj.T 10 returns the number of knot points in the trajectory. traj.components (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3], controls = [4, 5, 6]) returns the components of the trajectory. This page was generated using  Literate.jl ."},{"id":208,"pagetitle":"Library","title":"API","ref":"/NamedTrajectories/stable/lib/#API","content":" API"},{"id":209,"pagetitle":"Library","title":"NamedTrajectory methods","ref":"/NamedTrajectories/stable/lib/#NamedTrajectory-methods","content":" NamedTrajectory methods"},{"id":210,"pagetitle":"Library","title":"Base.:==","ref":"/NamedTrajectories/stable/lib/#Base.:==-Tuple{NamedTrajectory, NamedTrajectory}","content":" Base.:==  —  Method :(==)(traj1::NamedTrajectory, traj2::NamedTrajectory) Check if trajectories are equal w.r.t. using  Base.:(==) source"},{"id":211,"pagetitle":"Library","title":"Base.copy","ref":"/NamedTrajectories/stable/lib/#Base.copy-Tuple{NamedTrajectory}","content":" Base.copy  —  Method copy(::NamedTrajectory) Returns a copy of the trajectory. source"},{"id":212,"pagetitle":"Library","title":"Base.getindex","ref":"/NamedTrajectories/stable/lib/#Base.getindex-Tuple{NamedTrajectory, AbstractVector{Int64}}","content":" Base.getindex  —  Method getindex(traj, ts::AbstractVector{Int})::Vector{KnotPoint} Returns the knot points at times  ts . source"},{"id":213,"pagetitle":"Library","title":"Base.getindex","ref":"/NamedTrajectories/stable/lib/#Base.getindex-Tuple{NamedTrajectory, Int64}","content":" Base.getindex  —  Method getindex(traj, t::Int)::KnotPoint Returns the knot point at time  t . source"},{"id":214,"pagetitle":"Library","title":"Base.getindex","ref":"/NamedTrajectories/stable/lib/#Base.getindex-Tuple{NamedTrajectory, Symbol}","content":" Base.getindex  —  Method getindex(traj, symb::Symbol) Dispatches indexing of trajectories as either accessing a component or a property via  getproperty . source"},{"id":215,"pagetitle":"Library","title":"Base.getproperty","ref":"/NamedTrajectories/stable/lib/#Base.getproperty-Tuple{NamedTrajectory, Symbol}","content":" Base.getproperty  —  Method getproperty(traj, symb::Symbol) Returns the component of the trajectory with name  symb  or the property of the trajectory with name  symb . source"},{"id":216,"pagetitle":"Library","title":"Base.isequal","ref":"/NamedTrajectories/stable/lib/#Base.isequal-Tuple{NamedTrajectory, NamedTrajectory}","content":" Base.isequal  —  Method isequal(traj1::NamedTrajectory, traj2::NamedTrajectory) Check if trajectories are equal w.r.t. data using  Base.isequal source"},{"id":217,"pagetitle":"Library","title":"Base.lastindex","ref":"/NamedTrajectories/stable/lib/#Base.lastindex-Tuple{NamedTrajectory}","content":" Base.lastindex  —  Method lastindex(traj::NamedTrajectory) Returns the final time index of the trajectory. source"},{"id":218,"pagetitle":"Library","title":"Base.length","ref":"/NamedTrajectories/stable/lib/#Base.length-Tuple{NamedTrajectory}","content":" Base.length  —  Method length(::NamedTrajectory) Returns the length of all variables of the trajectory, including global data. source"},{"id":219,"pagetitle":"Library","title":"Base.merge","ref":"/NamedTrajectories/stable/lib/#Base.merge-Tuple{NamedTrajectory, NamedTrajectory}","content":" Base.merge  —  Method merge(traj1::NamedTrajectory, traj2::NamedTrajectory)\nmerge(trajs::AbstractVector{<:NamedTrajectory}) Returns a new NamedTrajectory object by merging  NamedTrajectory  objects.  Merge names are used to specify which components to merge by index. If no merge names are provided, all components are merged and name collisions are not allowed. If merge names are provided, the names are merged using the data from the index provided in the merge names. Joined  NamedTrajectory  objects must have the same timestep. If a free time trajectory is desired, setting the keyword argument  free_time=true  will construct the a component for the timestep. In this case, the timestep symbol must be provided.  Arguments traj1::NamedTrajectory : The first  NamedTrajectory  object. traj2::NamedTrajectory : The second  NamedTrajectory  object. free_time::Bool=false : Whether to construct a free time problem. timestep_name::Symbol=:Δt : The timestep symbol to use for free time problems. merge_names::Union{Nothing, NamedTuple{<:Any, <:Tuple{Vararg{Int}}}}=nothing : The names to merge by index. source"},{"id":220,"pagetitle":"Library","title":"Base.setproperty!","ref":"/NamedTrajectories/stable/lib/#Base.setproperty!-Tuple{NamedTrajectory, Symbol, Any}","content":" Base.setproperty!  —  Method setproperty!(traj, name::Symbol, val::Any) Dispatches setting properties of trajectories as either setting a component or a property via  setfield!  or  update! . source"},{"id":221,"pagetitle":"Library","title":"Base.size","ref":"/NamedTrajectories/stable/lib/#Base.size-Tuple{NamedTrajectory}","content":" Base.size  —  Method size(traj::NamedTrajectory) = (dim = traj.dim, T = traj.T) Returns the size of the trajectory (dim, T), excluding global data. TODO: Should global data be in size? source"},{"id":222,"pagetitle":"Library","title":"Base.vec","ref":"/NamedTrajectories/stable/lib/#Base.vec-Tuple{NamedTrajectory}","content":" Base.vec  —  Method vec(::NamedTrajectory) Returns all variables of the trajectory as a vector, Z⃗. source"},{"id":223,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_component!","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.add_component!-Tuple{NamedTrajectory, Symbol, AbstractVecOrMat{Float64}}","content":" NamedTrajectories.MethodsNamedTrajectory.add_component!  —  Method add_component!(traj, name::Symbol, data::AbstractVecOrMat; type={:state, :control}) Add a component to the trajectory. This function resizes the trajectory, so global components and components must be adjusted. source"},{"id":224,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_component_names","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.get_component_names-Tuple{NamedTrajectory, AbstractVector{<:Int64}}","content":" NamedTrajectories.MethodsNamedTrajectory.get_component_names  —  Method get_component_names(traj::NamedTrajectory, comps::AbstractVector{<:Int}) Returns the name of the component with the given indices. If only one component is found, the name is returned as a single symbol. Else, the names are returned as a vector of symbols. The filter requires that the components are a complete subset of the given indices, so that a partial match is excluded from the returned names. source"},{"id":225,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_components","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.get_components-Tuple{Union{Tuple, AbstractVector}, NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_components  —  Method get_components(::NamedTrajectory) Returns a NamedTuple containing the names and corresponding data matrices of the trajectory. source"},{"id":226,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_duration","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.get_duration-Tuple{NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_duration  —  Method get_duration(::NamedTrajectory) Returns the duration of a trajectory. source"},{"id":227,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_times","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.get_times-Tuple{NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_times  —  Method get_times(traj)::Vector{Float64} Returns the times of a trajectory as a vector. source"},{"id":228,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_timesteps","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.get_timesteps-Tuple{NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_timesteps  —  Method get_timesteps(::NamedTrajectory) Returns the timesteps of a trajectory as a vector. source"},{"id":229,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.merge_outer","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.merge_outer-Tuple{AbstractVector}","content":" NamedTrajectories.MethodsNamedTrajectory.merge_outer  —  Method merge_outer(objs::AbstractVector{<:Any}) Merge objects. An error is reported if a key collision is detected. source"},{"id":230,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_component","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.remove_component-Tuple{NamedTrajectory, Symbol}","content":" NamedTrajectories.MethodsNamedTrajectory.remove_component  —  Method remove_component(traj, name::Symbol) Remove a component from the trajectory. source"},{"id":231,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_components","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.remove_components-Tuple{NamedTrajectory, AbstractVector{<:Symbol}}","content":" NamedTrajectories.MethodsNamedTrajectory.remove_components  —  Method remove_components(traj, names::Vector{Symbol}) Remove a set of components from the trajectory. source"},{"id":232,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update!","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.update!-Tuple{NamedTrajectory, AbstractVector{Float64}}","content":" NamedTrajectories.MethodsNamedTrajectory.update!  —  Method update!(traj, datavec::AbstractVector{Float64}) Update the trajectory with a new datavec. source"},{"id":233,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update!","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.update!-Tuple{NamedTrajectory, Symbol, AbstractMatrix{Float64}}","content":" NamedTrajectories.MethodsNamedTrajectory.update!  —  Method update!(traj, name::Symbol, data::AbstractMatrix{Float64}) Update a component of the trajectory. source"},{"id":234,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update_bound!","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.update_bound!","content":" NamedTrajectories.MethodsNamedTrajectory.update_bound!  —  Function update_bound!(traj, name::Symbol, data::Real)\nupdate_bound!(traj, name::Symbol, data::AbstractVector{<:Real})\nupdate_bound!(traj, name::Symbol, data::Tuple{R, R} where R <: Real) Update the bound of a component of the trajectory. source"},{"id":235,"pagetitle":"Library","title":"random trajectory methods","ref":"/NamedTrajectories/stable/lib/#random-trajectory-methods","content":" random trajectory methods"},{"id":236,"pagetitle":"Library","title":"Base.rand","ref":"/NamedTrajectories/stable/lib/#Base.rand-Tuple{Type{NamedTrajectory}, Int64}","content":" Base.rand  —  Method rand(\n    ::Type{NamedTrajectory},\n    T::Int;\n    timestep_value::Float64=1.0,\n    timestep_name::Symbol=:Δt,\n    free_time::Bool=false,\n    timestep::Union{Float64,Symbol}=free_time ? timestep_name : timestep_value,\n    state_dim::Int=3,\n    control_dim::Int=2\n) Create a random  NamedTrajectory  with  T  time steps, a state variable  x  of dimension  state_dim , and a control variable  u  of dimension  control_dim . If  free_time  is  true , the time step is a symbol  timestep_name  and the time step value is  timestep_value . Otherwise, the time step is a number  timestep_value . source"},{"id":239,"pagetitle":"Adding and removing variables","title":"Adding and removing variables","ref":"/NamedTrajectories/stable/man/add_remove/#Adding-and-removing-variables","content":" Adding and removing variables This page was generated using  Literate.jl ."},{"id":242,"pagetitle":"Constructors","title":"Constructors","ref":"/NamedTrajectories/stable/man/constructors/#Constructors","content":" Constructors This page was generated using  Literate.jl ."},{"id":245,"pagetitle":"Operations with other trajectories","title":"Operations with other trajectories","ref":"/NamedTrajectories/stable/man/operations/#Operations-with-other-trajectories","content":" Operations with other trajectories This page was generated using  Literate.jl ."},{"id":248,"pagetitle":"Retrieving data","title":"Retrieving data","ref":"/NamedTrajectories/stable/man/retrieval/#Retrieving-data","content":" Retrieving data This page was generated using  Literate.jl ."},{"id":251,"pagetitle":"Times and timesteps","title":"Times and timesteps","ref":"/NamedTrajectories/stable/man/times/#Times-and-timesteps","content":" Times and timesteps This page was generated using  Literate.jl ."},{"id":254,"pagetitle":"Updating data","title":"Updating data","ref":"/NamedTrajectories/stable/man/updating/#Updating-data","content":" Updating data This page was generated using  Literate.jl ."},{"id":257,"pagetitle":"Manual","title":"Manual","ref":"/NamedTrajectories/stable/manual/#Manual","content":" Manual"},{"id":258,"pagetitle":"Manual","title":"Constructors","ref":"/NamedTrajectories/stable/manual/#Constructors","content":" Constructors"},{"id":259,"pagetitle":"Manual","title":"Retrieving data","ref":"/NamedTrajectories/stable/manual/#Retrieving-data","content":" Retrieving data"},{"id":260,"pagetitle":"Manual","title":"Adding and removing variables","ref":"/NamedTrajectories/stable/manual/#Adding-and-removing-variables","content":" Adding and removing variables"},{"id":261,"pagetitle":"Manual","title":"Updating data and bounds","ref":"/NamedTrajectories/stable/manual/#Updating-data-and-bounds","content":" Updating data and bounds"},{"id":262,"pagetitle":"Manual","title":"Getting times and timesteps","ref":"/NamedTrajectories/stable/manual/#Getting-times-and-timesteps","content":" Getting times and timesteps"},{"id":263,"pagetitle":"Manual","title":"Operations with other trajectories","ref":"/NamedTrajectories/stable/manual/#Operations-with-other-trajectories","content":" Operations with other trajectories"},{"id":264,"pagetitle":"Manual","title":"Copying and equality","ref":"/NamedTrajectories/stable/manual/#Copying-and-equality","content":" Copying and equality This page was generated using  Literate.jl ."}]