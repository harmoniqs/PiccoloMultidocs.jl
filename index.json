[{"id":3,"pagetitle":"Home","title":"Description","ref":"/Piccolo/dev/#Description","content":" Description Piccolo.jl  is a meta-package for quantum optimal control using the Pade Integrator Collocation (Piccolo) method. This package reexports the following packages QuantumCollocation.jl NamedTrajectories.jl TrajectoryIndexingUtils.jl PiccoloQuantumObjects.jl PiccoloPlots.jl For documentation please see the individual packages."},{"id":4,"pagetitle":"Home","title":"Usage","ref":"/Piccolo/dev/#Usage","content":" Usage Just run using Piccolo"},{"id":5,"pagetitle":"Home","title":"Installation","ref":"/Piccolo/dev/#Installation","content":" Installation This package is registered! To install enter the Julia REPL, type  ]  to enter pkg mode, activate your environment  activate , and then run  pkg> add Piccolo"},{"id":6,"pagetitle":"Home","title":"Building Documentation","ref":"/Piccolo/dev/#Building-Documentation","content":" Building Documentation This package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility.  # first time only\n./docs/get_docs_utils.sh   # or ./get_docs_utils.sh if cwd is in ./docs/ To build the docs pages: julia --project=docs docs/make.jl or editing the docs live: julia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"], skip_files=[\"docs/src/index.md\"]) Note: servedocs  needs to watch a subset of the files in the  docs/  folder. If it watches files that are generated on a docs build/re-build,  servedocs  will continuously try to re-serve the pages. To prevent this, ensure all generated files are included in the skip dirs or skip files args for  servedocs . For example, if we forget index.md like so: julia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"]) it will not build and serve. \"Technologies are ways of commandeering nature: the sky belongs to those who know how to fly; the sea belongs to those who know how to swim and navigate.\" – Simone de Beauvoir"},{"id":9,"pagetitle":"Contribution Guide","title":"Contribution Guide","ref":"/Piccolo/dev/contribution_guide/#Contribution-Guide","content":" Contribution Guide"},{"id":10,"pagetitle":"Contribution Guide","title":"Introduction","ref":"/Piccolo/dev/contribution_guide/#Introduction","content":" Introduction We welcome contributiuons to Piccolo.jl! This document outlines the guidelines for contributing to the project. If you know what you want to see, but are unsure of the best way to achieve it, add an issue on the relevant repository  (like QuantumCollocation.jl)  and start a discussion with the community! "},{"id":11,"pagetitle":"Contribution Guide","title":"Tips for Visual Studio Code","ref":"/Piccolo/dev/contribution_guide/#Tips-for-Visual-Studio-Code","content":" Tips for Visual Studio Code Julia extension  You can run Julia notebooks and much more with  the Julia extension . Upon opening your project folder in VS code and attempting to run an  .ipynb , you will see that VS Code finds the interpreters managed by juliaup and defaults to using the environment based on the  Project.toml  in the project directory. Fonts  VS Code will not display all characters allowed by Julia. You can change the editor font family in the settings to  'JuliaMono'  to get full support. If you don't want to mix and mash, you can create a new VS Code settings profile for working in Julia at  File>Preferences>Profile . Tests  Tests should automatically populate in VS Code when working with a Piccolo package. For example, just by adding the  QuantumCollocation.jl  folder to your workspace, you should see tests appear if you click on the  Testing  sidebar icon. If you run one of these tests, a new Julia kernel is spawned for the test. You can find the kernel if you click on the  Julia  sidebar icon (after installing the Julia extensions). Sometimes, for the tests to recognize new changes, you may need to manually kill this kernel to see your changes reflected."},{"id":12,"pagetitle":"Contribution Guide","title":"Developing","ref":"/Piccolo/dev/contribution_guide/#Developing","content":" Developing Install Julia Juliaup  is an installer and version manager. This is one useful way to manage Julia versions and keep up with the latest changes. After installing, run  julia  to obtain the Julia  REPL . Julia environments (Documentation)  Your project's environment is stored in  Project.toml . You can interactively add packages to an environment by using the Julia command line  REPL  and  package manager .  Start Julia in the project folder. Type  ]  to enter the package manager. Type  activate .  to activate or create an environment specified by  Project.toml  located in the current folder. Separately, you generate a manifest (solving the versions to create a valid environment) by running  instantiate ; instantiate will check that the environment is correct after you add all the packages you want. Adding packages (Documentation)  The initial cell for a Piccolo notebook might look something like the following: # Standard packages\nusing LinearAlgebra\nusing CairoMakie\n\n# Piccolo\nusing Piccolo First off are the standard packages (these are like Numpy and Matplotlib). Open the package manager in the current environment (type  julia ,  ] , and  activate . ), type  add LinearAlgebra  to install and precompile  LinearAlgebra . Same with  CairoMakie . Second, let's install  Piccolo . We do  add Piccolo  to get the entire ecosystem as a bundle from the Julia repository. Sometimes you will want to develop individual Piccolo packages, so our header might look like # Standard packages\nusing LinearAlgebra\nusing CairoMakie\n\n# Piccolo packages\nusing QuantumCollocation\nusing NamedTrajectories These are two packages ( QuantumCollocation ,  NamedTrajetories ) inside  Piccolo .  As a developer, we want to use the git repositories directly from  the harmoniqs Quantum Github page . Clone, then add the local packages to the Project file with e.g.  dev ../relative/path/to/repo/QuantumCollocation . This command installs the development version of  QuantumCollocation  pointing to the local Github code instead of the package repository. You can repeat this for the others, also. Revise Revise.jl  will let you edit source code, update packages, and reload the changes in a notebook–-automatically! This is a great tool for development.  add Revise  from the REPL and then include it before any packages you intend to edit: using Revise\nusing QuantumCollocation"},{"id":13,"pagetitle":"Contribution Guide","title":"Documentation","ref":"/Piccolo/dev/contribution_guide/#Documentation","content":" Documentation Documentation is built using  Documenter.jl  and uses  Literate.jl  to generate markdown files from scripts stored in  docs/literate . To build the documentation locally, start Julia with the docs environment: julia --project=docs Then (for ease of development) load the following packages: using Revise, LiveServer, QuantumCollocation To  live-serve  the docs, run servedocs(literate_dir=\"docs/literate\", skip_dir=\"docs/src/generated\") The extra arguments prevent an infinite loop caused by the generated Literate files. If the  index.md  is also dynamically generated from the  README.md , run servedocs(literate_dir=\"docs/literate\", skip_dir=\"docs/src/generated\", skip_files=[\"docs/src/index.md\"]) Changes made to files in the docs directory should be automatically reflected in the live server. To reflect changes in the source code (e.g. doc strings), since we are using Revise, simply kill the live server running in the REPL (with, e.g., Ctrl-C) and restart it with the above command. "},{"id":14,"pagetitle":"Contribution Guide","title":"Writing tests","ref":"/Piccolo/dev/contribution_guide/#Writing-tests","content":" Writing tests Tests are implemented using the  TestItems.jl  package.  @testitem \"Hadamard gate\" begin\n    H_drift, H_drives = GATES[:Z], [GATES[:X], GATES[:Y]]\n    U_goal = GATES[:H]\n    T = 51\n    Δt = 0.2\n\n    prob = UnitarySmoothPulseProblem(\n        H_drift, H_drives, U_goal, T, Δt,\n        ipopt_options=IpoptOptions(print_level=1)\n    )\n\n    solve!(prob, max_iter=100)\n    @test unitary_rollout_fidelity(prob) > 0.99\nend Individual tests will populate in the Testing panel in VSCode. All tests are integrated into the base test system for CI, which occurs at each PR submission. Tests should be included in the same file as the code they test, so  problem templates/unitary smooth pulse problem.jl  contains the test items for  UnitarySmoothPulseProblem ."},{"id":15,"pagetitle":"Contribution Guide","title":"Reporting Issues","ref":"/Piccolo/dev/contribution_guide/#Reporting-Issues","content":" Reporting Issues Issue templates are available on GitHub. We are happy to take feature requests!"},{"id":18,"pagetitle":"Multilevel Transmon","title":"Multilevel Transmon","ref":"/Piccolo/dev/generated/multilevel_transmon/#Multilevel-Transmon","content":" Multilevel Transmon In this example we will look at a multilevel transmon qubit with a Hamiltonian given by \\[\\hat{H}(t) = -\\frac{\\delta}{2} \\hat{n}(\\hat{n} - 1) + u_1(t) (\\hat{a} + \\hat{a}^\\dagger) + u_2(t) i (\\hat{a} - \\hat{a}^\\dagger)\\] where  $\\hat{n} = \\hat{a}^\\dagger \\hat{a}$  is the number operator,  $\\hat{a}$  is the annihilation operator,  $\\delta$  is the anharmonicity, and  $u_1(t)$  and  $u_2(t)$  are control fields. We will use the following parameter values: \\[\\begin{aligned}\n\\delta &= 0.2 \\text{ GHz}\\\\\n\\abs{u_i(t)} &\\leq 0.2 \\text{ GHz}\\\\\nT_0 &= 10 \\text{ ns}\\\\\n\\end{aligned}\\] For convenience, we have defined the  TransmonSystem  function in the  QuantumSystemTemplates  module, which returns a  QuantumSystem  object for a transmon qubit. We will use this function to define the system."},{"id":19,"pagetitle":"Multilevel Transmon","title":"Setting up the problem","ref":"/Piccolo/dev/generated/multilevel_transmon/#Setting-up-the-problem","content":" Setting up the problem To begin, let's load the necessary packages, define the system parameters, and create a a  QuantumSystem  object using the  TransmonSystem  function. using Piccolo\nusing SparseArrays\nusing Random;\nRandom.seed!(123);\n\n# define the time parameters\n\nT₀ = 10     # total time in ns\nT = 50      # number of time steps\nΔt = T₀ / T # time step\n\n# define the system parameters\nlevels = 5\nδ = 0.2\n\n# add a bound to the controls\na_bound = 0.2\ndda_bound = 1.0\n\n# create the system\nsys = TransmonSystem(levels = levels, δ = δ)\n\n# let's look at the parameters of the system\nsys.params << @example-block not executed in draft mode >> Since this is a multilevel transmon and we want to implement an, let's say,  $X$  gate on the qubit subspace, i.e., the first two levels we can utilize the  EmbeddedOperator  type to define the target operator. # define the target operator\nop = EmbeddedOperator(:X, sys)\n\n# show the full operator\nop.operator |> sparse << @example-block not executed in draft mode >> We can then pass this embedded operator to the  UnitarySmoothPulseProblem  template to create # create the problem\nprob = UnitarySmoothPulseProblem(sys, op, T, Δt; a_bound = a_bound, dda_bound = dda_bound)\n\n# solve the problem\nsolve!(prob; max_iter = 50) << @example-block not executed in draft mode >> Let's look at the fidelity in the subspace println(\n    \"Fidelity: \",\n    unitary_rollout_fidelity(prob.trajectory, sys; subspace = op.subspace),\n) << @example-block not executed in draft mode >> and plot the result using the  plot_unitary_populations  function. plot_unitary_populations(prob.trajectory) << @example-block not executed in draft mode >>"},{"id":20,"pagetitle":"Multilevel Transmon","title":"Leakage suppresion","ref":"/Piccolo/dev/generated/multilevel_transmon/#Leakage-suppresion","content":" Leakage suppresion As can be seen from the above plot, there is a substantial amount of leakage into the higher levels during the evolution. To mitigate this, we have implemented the ability to add a cost to populating the leakage levels, in particular this is an  $L_1$  norm cost, which is implemented via slack variables and should ideally drive those leakage populations down to zero. To implement this, pass  leakage_suppresion=true  and  R_leakage={value}  to the  UnitarySmoothPulseProblem  template. # create the a leakage suppression problem, initializing with the previous solution\n\nprob_leakage = UnitarySmoothPulseProblem(\n    sys,\n    op,\n    T,\n    Δt;\n    a_bound = a_bound,\n    dda_bound = dda_bound,\n    leakage_suppression = true,\n    R_leakage = 1e-1,\n    a_guess = prob.trajectory.a,\n)\n\n# solve the problem\n\nsolve!(prob_leakage; max_iter = 50) << @example-block not executed in draft mode >> Let's look at the fidelity in the subspace println(\n    \"Fidelity: \",\n    unitary_rollout_fidelity(prob_leakage.trajectory, sys; subspace = op.subspace),\n) << @example-block not executed in draft mode >> and plot the result using the  plot_unitary_populations  function from PiccoloPlots.jl plot_unitary_populations(prob_leakage.trajectory) << @example-block not executed in draft mode >> Here we can see that the leakage populations have been driven substantially down. This page was generated using  Literate.jl ."},{"id":23,"pagetitle":"Quickstart","title":"Quickstart Guide","ref":"/Piccolo/dev/generated/quickstart/#Quickstart-Guide","content":" Quickstart Guide To set up and solve a quantum optimal control problems we provide high level problem templates to quickly get started. For unitary gate problems, where we want to realize a gate  $U_{\\text{goal}}$ , with a system Hamiltonian of the form, \\[H(t) = H_0 + \\sum_i a^i(t) H_i\\] there is the  UnitarySmoothPulseProblem  constructor which only requires the drift Hamiltonian,  $H_0$ the drive Hamiltonians,  $\\qty{H_i}$ the target unitary,  $U_{\\text{goal}}$ the number of timesteps,  $T$ the (initial) time step size,  $\\Delta t$"},{"id":24,"pagetitle":"Quickstart","title":"Smooth Pulse Problems","ref":"/Piccolo/dev/generated/quickstart/#Smooth-Pulse-Problems","content":" Smooth Pulse Problems For example, to create a problem for a single qubit  $X$  gate (with a bound on the drive of  $|a^i| < a_{\\text{bound}}$ ), i.e., with system hamiltonian \\[H(t) = \\frac{\\omega}{2} \\sigma_z + a^1(t) \\sigma_x + a^2(t) \\sigma_y\\] we can do the following: using CairoMakie\nusing Piccolo\n\n# set time parameters\nT = 50\nΔt = 0.2\n\n# define drift and drive Hamiltonians\nH_drift = 0.2 * PAULIS.Z\nH_drives = [PAULIS.X, PAULIS.Y]\n\n# create a QuantumSystem from the Hamiltonians\nsystem = QuantumSystem(H_drift, H_drives)\n\n# define target unitary\nU_goal = GATES.X\n\n# set bounds on the drive\na_bound = 0.2\ndda_bound = 5.0\n\n# build the problem\nprob = UnitarySmoothPulseProblem(\n    system,\n    U_goal,\n    T,\n    Δt;\n    a_bound = a_bound,\n    dda_bound = dda_bound,\n)\n\n# solve the problem\nsolve!(prob; max_iter = 50) << @example-block not executed in draft mode >> The above output comes from the Ipopt.jl solver. The problem's trajectory has been updated with the solution. We can see the final control amplitudes and the final unitary by accessing the  a  and  Ũ⃗  fields of the trajectory. size(prob.trajectory.a) |> println\nsize(prob.trajectory.Ũ⃗) |> println << @example-block not executed in draft mode >> The  Ũ⃗  field is a vectorized representation of the unitary, which we can convert back to a matrix using the  iso_vec_to_operator  function exported by PiccoloQuantumObjects.jl. iso_vec_to_operator(prob.trajectory.Ũ⃗[:, end]) |> pretty_print << @example-block not executed in draft mode >> To see the final fidelity we can use the  unitary_rollout_fidelity  function exported by QuantumCollocation.jl. println(\"Final fidelity: \", unitary_rollout_fidelity(prob.trajectory, system)) << @example-block not executed in draft mode >> We can also easily plot the solutions using the  plot  function exported by NamedTrajectories.jl. plot(prob.trajectory, [:Ũ⃗, :a]) << @example-block not executed in draft mode >>"},{"id":25,"pagetitle":"Quickstart","title":"Minimum Time Problems","ref":"/Piccolo/dev/generated/quickstart/#Minimum-Time-Problems","content":" Minimum Time Problems We can also easily set up and solve a minimum time problem, where we enforce a constraint on the final fidelity: \\[\\mathcal{F}(U_T, U_{\\text{goal}}) \\geq \\mathcal{F}_{\\text{min}}\\] Using the problem we just solved we can do the following: # final fidelity constraint\nfinal_fidelity = 0.99\n\nmin_time_prob = UnitaryMinimumTimeProblem(prob, U_goal; final_fidelity = final_fidelity)\n\nsolve!(min_time_prob; max_iter = 50) << @example-block not executed in draft mode >> We can see that the final fidelity is indeed greater than the minimum fidelity we set. println(\"Final fidelity:    \", unitary_rollout_fidelity(min_time_prob.trajectory, system)) << @example-block not executed in draft mode >> and that the duration of the pulse has decreased. initial_duration = get_times(prob.trajectory)[end]\nmin_time_duration = get_times(min_time_prob.trajectory)[end]\n\nprintln(\"Initial duration:  \", initial_duration)\nprintln(\"Minimum duration:  \", min_time_duration)\nprintln(\"Duration decrease: \", initial_duration - min_time_duration)\n\n# We can also plot the solutions for the minimum time problem, and see that the control amplitudes saturate the bound.\nplot(min_time_prob.trajectory, [:Ũ⃗, :a]) << @example-block not executed in draft mode >> This page was generated using  Literate.jl ."},{"id":28,"pagetitle":"Release Notes","title":"Release Notes","ref":"/Piccolo/dev/release_notes/#Release-Notes","content":" Release Notes The format is based on  Keep a Changelog , and this project adheres to  Semantic Versioning ."},{"id":29,"pagetitle":"Release Notes","title":"[v0.3.1] - 2024-10-17","ref":"/Piccolo/dev/release_notes/#[v0.3.1]-2024-10-17","content":" [v0.3.1] - 2024-10-17"},{"id":30,"pagetitle":"Release Notes","title":"Fixed","ref":"/Piccolo/dev/release_notes/#Fixed","content":" Fixed Fixed and added tests to  RydbergChainSystem"},{"id":31,"pagetitle":"Release Notes","title":"[v0.3.0] - 2024-10-10","ref":"/Piccolo/dev/release_notes/#[v0.3.0]-2024-10-10","content":" [v0.3.0] - 2024-10-10"},{"id":32,"pagetitle":"Release Notes","title":"Added","ref":"/Piccolo/dev/release_notes/#Added","content":" Added PiccoloOptions  to handle custome problem settings."},{"id":33,"pagetitle":"Release Notes","title":"Changed","ref":"/Piccolo/dev/release_notes/#Changed","content":" Changed Refactored trajectory initialization functions Improved documentation Typo fixes"},{"id":34,"pagetitle":"Release Notes","title":"[v0.2.0] - 2024-02-22","ref":"/Piccolo/dev/release_notes/#[v0.2.0]-2024-02-22","content":" [v0.2.0] - 2024-02-22"},{"id":35,"pagetitle":"Release Notes","title":"Added","ref":"/Piccolo/dev/release_notes/#Added-2","content":" Added EmbeddedOperator  to handle subspace gate optimization and leakage suppression Plotting methods for unitary populations"},{"id":36,"pagetitle":"Release Notes","title":"Changed","ref":"/Piccolo/dev/release_notes/#Changed-2","content":" Changed New quantum systems interface Transmon system template Restructured the code base for easier quantum system and problem template development"},{"id":37,"pagetitle":"Release Notes","title":"Removed","ref":"/Piccolo/dev/release_notes/#Removed","content":" Removed Stale examples "},{"id":38,"pagetitle":"Release Notes","title":"Fixed","ref":"/Piccolo/dev/release_notes/#Fixed-2","content":" Fixed Robustness improvements objective test fixes "},{"id":41,"pagetitle":"Home","title":"PiccoloQuantumObjects","ref":"/PiccoloQuantumObjects/dev/#PiccoloQuantumObjects","content":" PiccoloQuantumObjects PiccoloQuantumObjects.jl  is a Julia package for working with quantum objects. It provides tools for constructing and manipulating quantum states and operators. It is designed to be used with other packages in the  Piccolo.jl  ecosystem, such as  QuantumCollocation.jl  and  NamedTrajectories.jl ."},{"id":42,"pagetitle":"Home","title":"Installation","ref":"/PiccoloQuantumObjects/dev/#Installation","content":" Installation This package is registered! To install, enter the Julia REPL, type  ]  to enter pkg mode, and then run: pkg> add PiccoloQuantumObjects"},{"id":43,"pagetitle":"Home","title":"Usage","ref":"/PiccoloQuantumObjects/dev/#Usage","content":" Usage The following example demonstrates how to create a quantum state, create a quantum operator, and apply the operator to the state: using PiccoloQuantumObjects\n\n# Create a quantum state\nstate = ket_from_string(\"g\", [2])\n\n# Create a quantum operator\noperator = PAULIS.X\n\n# Apply the operator to the state\nnew_state = operator * state\n\n# Transform the state to its real representation\nnew_iso_state = ket_to_iso(new_state)\n\n# Transform back\niso_to_ket(new_iso_state)"},{"id":44,"pagetitle":"Home","title":"Building Documentation","ref":"/PiccoloQuantumObjects/dev/#Building-Documentation","content":" Building Documentation This package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility.  # first time only\n./docs/get_docs_utils.sh   # or ./get_docs_utils.sh if cwd is in ./docs/ To build the docs pages: julia --project=docs docs/make.jl or editing the docs live: julia --project=docs\n> using LiveServer, PiccoloQuantumObjects, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"], skip_files=[\"docs/src/index.md\"]) Note: servedocs  needs to watch a subset of the files in the  docs/  folder. If it watches files that are generated on a docs build/re-build,  servedocs  will continuously try to re-serve the pages. To prevent this, ensure all generated files are included in the skip dirs or skip files args for  servedocs . For example, if we forget index.md like so: julia --project=docs\n> using LiveServer, PiccoloQuantumObjects, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"]) it will not build and serve. \"It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to take away.\" - Antoine de Saint-Exupéry"},{"id":47,"pagetitle":"Isomorphisms","title":"Isomorphisms","ref":"/PiccoloQuantumObjects/dev/generated/isomorphisms/#Isomorphisms","content":" Isomorphisms using PiccoloQuantumObjects\nusing SparseArrays # for visualization Linear algebra operations on quantum objects are often performed on real vectors and matrices. We provide isomorphisms to convert between complex and real representations of quantum objects. These isomorphisms are used internally by the  QuantumSystem  type to perform quantum dynamics."},{"id":48,"pagetitle":"Isomorphisms","title":"Quantum state isomorphisms","ref":"/PiccoloQuantumObjects/dev/generated/isomorphisms/#Quantum-state-isomorphisms","content":" Quantum state isomorphisms ket_to_iso  is the real isomorphism of a quantum state  ψ ∈ ℂⁿ iso_to_ket  is the inverse isomorphism of a real vector  ψ̃ ∈ ℝ²ⁿ ψ = [1; 2] + im * [3; 4]\nψ̃ = ket_to_iso(ψ) 4-element Vector{Int64}:\n 1\n 2\n 3\n 4 iso_to_ket(ψ̃) 2-element Vector{Complex{Int64}}:\n 1 + 3im\n 2 + 4im"},{"id":49,"pagetitle":"Isomorphisms","title":"Quantum operator isomorphisms","ref":"/PiccoloQuantumObjects/dev/generated/isomorphisms/#Quantum-operator-isomorphisms","content":" Quantum operator isomorphisms We often need to convert a complex matrix  U  to a real vector  Ũ⃗ . We provoide the following isomorphisms to convert between the two representations. iso_vec_to_operator (Ũ⃗::AbstractVector{ℝ}) operator_to_iso_vec (U::AbstractVector{ℂ}) iso_vec_to_iso_operator (Ũ⃗::AbstractVector{ℝ}) iso_operator_to_iso_vec (Ũ::AbstractMatrix{ℝ}) iso_operator_to_operator (Ũ::AbstractMatrix{ℝ}) operator_to_iso_operator (U::AbstractMatrix{ℂ}) In additon, we provide  mat (x::AbstractVector)  to convert a vector  x  into a square matrix, as the inverse to Base's  vec . Julia uses column-major order. U = [1 5; 2 6] + im * [3 7; 4 8]\nŨ⃗ = operator_to_iso_vec(U) 8-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8 iso_vec_to_operator(Ũ⃗) 2×2 Matrix{Complex{Int64}}:\n 1+3im  5+7im\n 2+4im  6+8im"},{"id":50,"pagetitle":"Isomorphisms","title":"Density matrix isomorphisms","ref":"/PiccoloQuantumObjects/dev/generated/isomorphisms/#Density-matrix-isomorphisms","content":" Density matrix isomorphisms The isomorphisms for density matrices are: density_to_iso_vec (ρ::AbstractMatrix{ℂ}) iso_vec_to_density (ρ̃::AbstractVector{ℝ}) Warning The isomorphism  density_to_iso_vec  is not the same as  operator_to_iso_vec . ρ = [1 2; 3 4] + im * [5 6; 7 8]\nρ̃⃗ = density_to_iso_vec(ρ) 8-element Vector{Int64}:\n 1\n 3\n 2\n 4\n 5\n 7\n 6\n 8"},{"id":51,"pagetitle":"Isomorphisms","title":"Quantum dynamics isomorphisms","ref":"/PiccoloQuantumObjects/dev/generated/isomorphisms/#Quantum-dynamics-isomorphisms","content":" Quantum dynamics isomorphisms The quantum dynamics isomorphisms, which correspond to these state transformations, are handled internally by the  QuantumSystem  type. The  Isomorphisms.iso  isomorphism of a Hamiltonian  $H$  is: \\[\\text{iso}(H) := \\widetilde{H} = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] where  $\\Im(H)$  and  $\\Re(H)$  are the imaginary and real parts of  $H$  and the tilde indicates the standard isomorphism of a complex valued matrix: \\[\\widetilde{H} := \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] Hence, the generator  Isomorphisms.G  associated to a Hamiltonian  $H$  is: \\[G(H) := \\text{iso}(- i \\widetilde{H}) = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Im(H) - \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Re(H)\\] This page was generated using  Literate.jl ."},{"id":54,"pagetitle":"Quantum Objects","title":"Quantum Objects","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#Quantum-Objects","content":" Quantum Objects using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n⊗ = kron; Quantum states and operators are represented as complex vectors and matrices. We provide a number of convenient ways to construct these objects. We also provide some tools for working with these objects, such as embedding operators in larger Hilbert spaces and selecting subspace indices."},{"id":55,"pagetitle":"Quantum Objects","title":"Quantum states","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#Quantum-states","content":" Quantum states We can construct quantum states from bitstrings or string representations. The string representations use atomic notation (ground state  g , excited state  e , etc.). Ground state in a 2-level system. ket_from_string(\"g\", [2]) 2-element Vector{ComplexF64}:\n 1.0 + 0.0im\n 0.0 + 0.0im Superposition state coupled to a ground state in two 2-level systems. ket_from_string(\"(g+e)g\", [2,2]) 4-element Vector{ComplexF64}:\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im |01⟩  in a 2-qubit system. ket_from_bitstring(\"01\") 4-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im"},{"id":56,"pagetitle":"Quantum Objects","title":"Quantum operators","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#Quantum-operators","content":" Quantum operators Frequently used operators are provided in  PAULIS  and  GATES ."},{"id":57,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.Gates.GATES","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.Gates.GATES-generated-quantum_objects","content":" PiccoloQuantumObjects.Gates.GATES  —  Constant A constant dictionary  GATES  containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix. GATES[:I]  - Identity: Leaves the state unchanged. GATES[:X]  - Pauli-X (NOT): Flips the qubit state. GATES[:Y]  - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere. GATES[:Z]  - Pauli-Z: Flips the phase of the qubit state. GATES[:H]  - Hadamard: Creates superposition by transforming basis states. GATES[:CX]  - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1⟩. GATES[:CZ]  - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1⟩. GATES[:XI]  - Complex: A gate for complex operations. GATES[:sqrtiSWAP]  - Square root of iSWAP: Partially swaps two qubits with a phase. source Quantum operators can also be constructed from strings. operator_from_string(\"X\") 2×2 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im operator_from_string(\"XZ\") 4×4 Matrix{ComplexF64}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im Annihilation and creation operators are provided for oscillator systems. a = annihilate(3) 3×3 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im      0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.41421+0.0im\n 0.0+0.0im  0.0+0.0im      0.0+0.0im a⁺ = create(3) 3×3 Matrix{ComplexF64}:\n 0.0-0.0im      0.0-0.0im  0.0-0.0im\n 1.0-0.0im      0.0-0.0im  0.0-0.0im\n 0.0-0.0im  1.41421-0.0im  0.0-0.0im a'a 3×3 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  2.0+0.0im"},{"id":58,"pagetitle":"Quantum Objects","title":"Random operators","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#Random-operators","content":" Random operators The  haar_random  function draws random unitary operators according to the Haar measure. haar_random(3) 3×3 Matrix{ComplexF64}:\n -0.344257-0.252751im  -0.557612+0.534399im   -0.409915+0.230346im\n -0.290131-0.521412im   0.575591+0.0982209im  -0.335151-0.436664im\n -0.363455+0.573984im  -0.193296+0.158653im   0.0339102-0.689027im If we want to generate random operations that are close to the identity, we can use the  haar_identity  function. haar_identity(2, 0.1) 2×2 Matrix{ComplexF64}:\n  0.995849-0.0103972im  -0.0453862+0.0782051im\n 0.0478983+0.0766922im    0.995663-0.0219008im A smaller radius means the random operator is closer to the identity. haar_identity(2, 0.01) 2×2 Matrix{ComplexF64}:\n     0.999924+0.0100108im  0.00071255+0.00722396im\n -0.000750575+0.0072201im    0.999962-0.00474605im"},{"id":59,"pagetitle":"Quantum Objects","title":"Embedded operators","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#Embedded-operators","content":" Embedded operators Sometimes we want to embed a quantum operator into a larger Hilbert space,  $\\mathcal{H}$ , which we decompose into subspace and leakage components: \\[    \\mathcal{H} = \\mathcal{H}_{\\text{subspace}} \\oplus \\mathcal{H}_{\\text{leakage}},\\] In quantum computing, the computation is encoded in a  subspace , while the remaining  leakage  states should be avoided."},{"id":60,"pagetitle":"Quantum Objects","title":"The embed and unembed functions","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#The-embed-and-unembed-functions","content":" The  embed  and  unembed  functions The  embed  function allows to embed a quantum operator in a larger Hilbert space."},{"id":61,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.embed-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.embed  —  Function embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int) Embed an  operator  in the  subspace  of a larger matrix of size  levels x levels . source embed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator) Embed the  subspace_operator  in the subspace of a larger  embedded_operator . source The  unembed  function allows to unembed a quantum operator from a larger Hilbert space."},{"id":62,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.unembed-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Function unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}) Unembed a subspace operator from the  matrix . This is equivalent to calling  matrix[subspace, subspace] . source unembed(embedded_op::EmbeddedOperator) Unembed an embedded operator, returning the original operator. source unembed(op::AbstractMatrix, embedded_op::EmbeddedOperator) Unembed a sub-matrix from the  op  at the subspace defined by  embedded_op . source Embed a two-level X gate into a multilevel system. levels = 3\nX = GATES[:X]\nsubspace_indices = 1:2\nX_embedded = embed(X, subspace_indices, levels) 3×3 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im  0.0+0.0im\n 1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im Unembed to retrieve the original operator. X_original = unembed(X_embedded, subspace_indices) 2×2 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im"},{"id":63,"pagetitle":"Quantum Objects","title":"The EmbeddedOperator type","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#The-EmbeddedOperator-type","content":" The  EmbeddedOperator  type The  EmbeddedOperator  type stores information about an operator embedded in the subspace of a larger quantum system."},{"id":64,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Type EmbeddedOperator Embedded operator type to represent an operator embedded in a subspace of a larger quantum system. Fields operator::Matrix{<:Number} : Embedded operator of size    prod(subsystem_levels) x prod(subsystem_levels) . subspace::Vector{Int} : Indices of the subspace the operator is embedded in. subsystem_levels::Vector{Int} : Levels of the subsystems in the composite system. source We construct an embedded operator in the same manner as the  embed  function."},{"id":65,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{Matrix{<:Number}, AbstractVector{Int64}, AbstractVector{Int64}}-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int}) Create an embedded operator. The  operator  is embedded at the  subspace  of the system spanned by the  subsystem_levels . source Embed an X gate in the first qubit's subspace within two 3-level systems. gate = GATES[:X] ⊗ GATES[:I]\nsubsystem_levels = [3, 3]\nsubspace_indices = get_subspace_indices([1:2, 1:2], subsystem_levels)\nembedded_operator = EmbeddedOperator(gate, subspace_indices, subsystem_levels) EmbeddedOperator{ComplexF64}(ComplexF64[0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im; … ; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im], [1, 2, 4, 5], [3, 3]) Show the full operator. embedded_operator.operator .|> real |> sparse 9×9 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅  Get the original operator back. unembed(embedded_operator) .|> real |> sparse 4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅    ⋅   1.0   ⋅ \n  ⋅    ⋅    ⋅   1.0\n 1.0   ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅  Embedded operators for composite systems are also supported."},{"id":66,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n) Embed the  subspace_operator  into the provided  subspaces  of a composite system, where the  subsystem_indices  list the subspaces at which the operator is defined, and the  subsystem_levels  list the levels of the subsystems in which the operator is embedded. source This is a two step process. The provided subspace operator is  lift_operator -ed  from the  subsystem_indices  where  it is defined into the space spanned by the composite system's  subspaces . The lifted operator is embedded into the full Hilbert space spanned by the   subsystem_levels . Embed a CZ gate with control qubit 1 and target qubit 3 into a composite system made up of three 3-level systems. An identity is performed on qubit 2. subsystem_levels = [3, 3, 3]\nsubspaces = [1:2, 1:2, 1:2]\nembedded_operator = EmbeddedOperator(GATES[:CZ], [1, 3], subspaces, subsystem_levels)\nunembed(embedded_operator) .|> real |> sparse 8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n 1.0   ⋅    ⋅    ⋅    ⋅     ⋅    ⋅     ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅     ⋅    ⋅     ⋅ \n  ⋅    ⋅   1.0   ⋅    ⋅     ⋅    ⋅     ⋅ \n  ⋅    ⋅    ⋅   1.0   ⋅     ⋅    ⋅     ⋅ \n  ⋅    ⋅    ⋅    ⋅   1.0    ⋅    ⋅     ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅   -1.0   ⋅     ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅     ⋅   1.0    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅     ⋅    ⋅   -1.0"},{"id":67,"pagetitle":"Quantum Objects","title":"Subspace and leakage indices","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#Subspace-and-leakage-indices","content":" Subspace and leakage indices"},{"id":68,"pagetitle":"Quantum Objects","title":"The get_subspace_indices function","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#The-get_subspace_indices-function","content":" The  get_subspace_indices  function The  get_subspace_indices  function is a convenient way to get the indices of a subspace in a larger quantum system."},{"id":69,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices  —  Function get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)\nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator) Get the indices for the provided subspace of the quantum system. source Its dual function is  get_leakage_indices . get_subspace_indices(1:2, 5) |> collect, get_leakage_indices(1:2, 5) |> collect ([1, 2], [3, 4, 5]) Composite systems are supported. Get the indices of the two-qubit subspace within two 3-level systems. get_subspace_indices([1:2, 1:2], [3, 3]) 4-element Vector{Int64}:\n 1\n 2\n 4\n 5 Qubits are assumed if the indices are not provided. get_subspace_indices([3, 3]) 4-element Vector{Int64}:\n 1\n 2\n 4\n 5 get_leakage_indices([3, 3]) 5-element Vector{Int64}:\n 3\n 6\n 7\n 8\n 9"},{"id":70,"pagetitle":"Quantum Objects","title":"Excitation number restrictions","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#Excitation-number-restrictions","content":" Excitation number restrictions Sometimes we want to cap the number of excitations we allow across a composite system. For example, if we want to restrict ourselves to the ground and single excitation states of two 3-level systems: get_enr_subspace_indices(1, [3, 3]) 3-element Vector{Int64}:\n 1\n 2\n 4"},{"id":71,"pagetitle":"Quantum Objects","title":"The get_iso_vec_subspace_indices function","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#The-get_iso_vec_subspace_indices-function","content":" The  get_iso_vec_subspace_indices  function For isomorphic operators, the  get_iso_vec_subspace_indices  function can be used to find the appropriate vector indices of the equivalent operator subspace. See also,  Isomorphisms#Quantum-operator-isomorphisms ."},{"id":72,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","ref":"/PiccoloQuantumObjects/dev/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices  —  Function get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator) Get the indices for the subspace in the isomorphic vector space for operators. source Its dual function is  get_iso_vec_leakage_indices , which by default only returns the leakage indices of the blocks: \\[\\mathcal{H}_{\\text{subspace}} \\otimes \\mathcal{H}_{\\text{subspace}},\\quad\n\\mathcal{H}_{\\text{subspace}} \\otimes \\mathcal{H}_{\\text{leakage}},\\quad\n\\mathcal{H}_{\\text{leakage}} \\otimes \\mathcal{H}_{\\text{subspace}}\\] allowing for leakage-suppressing code to disregard the uncoupled pure-leakage space. get_iso_vec_subspace_indices(1:2, 3) 8-element Vector{Int64}:\n  1\n  2\n  4\n  5\n  7\n  8\n 10\n 11 without_pure_leakage = get_iso_vec_leakage_indices(1:2, 3) 8-element Vector{Int64}:\n  3\n  6\n  9\n 12\n 13\n 14\n 16\n 17 Show the pure-leakage indices. with_pure_leakage = get_iso_vec_leakage_indices(1:2, 3, ignore_pure_leakage=false)\nsetdiff(with_pure_leakage, without_pure_leakage) 2-element Vector{Int64}:\n 15\n 18 The pure-leakage indices can grow quickly! without_pure_leakage = get_iso_vec_leakage_indices([1:2, 1:2], [4, 4])\nwith_pure_leakage = get_iso_vec_leakage_indices([1:2, 1:2], [4, 4], ignore_pure_leakage=false)\nsetdiff(with_pure_leakage, without_pure_leakage) |> length 288 This page was generated using  Literate.jl ."},{"id":75,"pagetitle":"Quantum Systems","title":"Abstract Quantum Systems","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#Abstract-Quantum-Systems","content":" Abstract Quantum Systems using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n⊗ = kron;"},{"id":76,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem  —  Type AbstractQuantumSystem Abstract type for defining systems. source"},{"id":77,"pagetitle":"Quantum Systems","title":"Quantum Systems","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#Quantum-Systems","content":" Quantum Systems The  QuantumSystem  type is used to represent a quantum system with a drift Hamiltonian and a set of drive Hamiltonians, \\[H = H_{\\text{drift}} + \\sum_i a_i H_{\\text{drives}}^{(i)}\\]"},{"id":78,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystems.QuantumSystem  —  Type QuantumSystem <: AbstractQuantumSystem A struct for storing quantum dynamics. Fields H::Function : The Hamiltonian function, excluding dissipation: a -> H(a). G::Function : The isomorphic generator function, including dissipation, a -> G(a). levels::Int : The number of levels in the system. n_drives::Int : The number of drives in the system. source QuantumSystem 's are containers for quantum dynamics. Internally, they compute the necessary isomorphisms to perform the dynamics in a real vector space. H_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsystem = QuantumSystem(H_drift, H_drives)\n\na_drives = [1, 0]\nsystem.H(a_drives) 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n 1.0+0.0im   1.0+0.0im\n 1.0+0.0im  -1.0+0.0im To extract the drift and drive Hamiltonians from a  QuantumSystem , use the  get_drift  and  get_drives  functions. get_drift(system) |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n 1.0+0.0im       ⋅    \n     ⋅      -1.0+0.0im Get the X drive. drives = get_drives(system)\ndrives[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      1.0+0.0im\n 1.0+0.0im      ⋅     And the Y drive. drives[2] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      0.0-1.0im\n 0.0+1.0im      ⋅     Note We can also construct a  QuantumSystem  directly from a Hamiltonian function. Internally,  ForwardDiff.jl  is used to compute the drives. H(a) = PAULIS[:Z] + a[1] * PAULIS[:X] + a[2] * PAULIS[:Y]\nsystem = QuantumSystem(H, 2)\nget_drives(system)[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      1.0+0.0im\n 1.0+0.0im      ⋅     Create a noise model with a confusion matrix. function H(a; C::Matrix{Float64}=[1.0 0.0; 0.0 1.0])\n    b = C * a\n    return b[1] * PAULIS.X + b[2] * PAULIS.Y\nend\n\nC_matrix = [0.99 0.01; -0.01 1.01]\nsystem = QuantumSystem(a -> H(a, C=C_matrix), 2; params=Dict(:C => C_matrix))\nconfused_drives = get_drives(system)\nconfused_drives[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n      ⋅       0.99+0.01im\n 0.99-0.01im       ⋅     confused_drives[2] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n      ⋅       0.01-1.01im\n 0.01+1.01im       ⋅    "},{"id":79,"pagetitle":"Quantum Systems","title":"Open quantum systems","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#Open-quantum-systems","content":" Open quantum systems We can also construct an  OpenQuantumSystem  with Lindblad dynamics, enabling a user to pass a list of dissipation operators."},{"id":80,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem  —  Type OpenQuantumSystem <: AbstractQuantumSystem A struct for storing open quantum dynamics. Additional fields dissipation_operators::Vector{AbstractMatrix} : The dissipation operators. See also  QuantumSystem . source Add a dephasing and annihilation error channel. H_drives = [PAULIS[:X]]\na = annihilate(2)\ndissipation_operators = [a'a, a]\nsystem = OpenQuantumSystem(H_drives, dissipation_operators=dissipation_operators)\nsystem.dissipation_operators[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 1 stored entry:\n     ⋅          ⋅    \n     ⋅      1.0+0.0im system.dissipation_operators[2] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 1 stored entry:\n     ⋅      1.0+0.0im\n     ⋅          ⋅     Warning The Hamiltonian part  system.H  excludes the Lindblad operators. This is also true for functions that report properties of  system.H , such as  get_drift ,  get_drives , and  is_reachable . get_drift(system) |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 0 stored entries:\n     ⋅          ⋅    \n     ⋅          ⋅    "},{"id":81,"pagetitle":"Quantum Systems","title":"Time Dependent Quantum Systems","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#Time-Dependent-Quantum-Systems","content":" Time Dependent Quantum Systems A  TimeDependentQuantumSystem  is a  QuantumSystem  with time-dependent Hamiltonians."},{"id":82,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.TimeDependentQuantumSystem","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.TimeDependentQuantumSystem-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystems.TimeDependentQuantumSystem  —  Type TimeDependentQuantumSystem <: AbstractQuantumSystem A struct for storing time-dependent quantum dynamics. Fields H::Function : The Hamiltonian function with time: (a, t) -> H(a, t). G::Function : The isomorphic generator function with time, (a, t) -> G(a, t). n_drives::Int : The number of drives in the system. levels::Int : The number of levels in the system. params::Dict{Symbol, Any} : A dictionary of parameters. source A function  H(a, t)  or carrier and phase kwargs are used to specify time-dependent drives, \\[    H(a, t) = H_{\\text{drift}} + \\sum_i a_i \\cos(\\omega_i t + \\phi_i) H_{\\text{drives}}^{(i)}\\] Create a time-dependent Hamiltonian with a time-dependent drive. H(a, t) = PAULIS.Z + a[1] * cos(t) * PAULIS.X\nsystem = TimeDependentQuantumSystem(H, 1) TimeDependentQuantumSystem: levels = 2, n_drives = 1 The drift Hamiltonian is the Z operator, but its now a function of time! get_drift(system)(0.0) |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n 1.0+0.0im       ⋅    \n     ⋅      -1.0+0.0im The drive Hamiltonian is the X operator, but its now a function of time! get_drives(system)[1](0.0) |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      1.0+0.0im\n 1.0+0.0im      ⋅     Change the time to π. get_drives(system)[1](π) |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n      ⋅      -1.0+0.0im\n -1.0+0.0im       ⋅     Similar matrix constructors exist, but with carrier and phase kwargs. system = TimeDependentQuantumSystem(PAULIS.Z, [PAULIS.X], carriers=[1.0], phases=[0.0]) TimeDependentQuantumSystem: levels = 2, n_drives = 1 This is the same as before, t=0.0: get_drives(system)[1](0.0) |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      1.0+0.0im\n 1.0+0.0im      ⋅     and at π: get_drives(system)[1](π) |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n      ⋅      -1.0+0.0im\n -1.0+0.0im       ⋅    "},{"id":83,"pagetitle":"Quantum Systems","title":"Composite quantum systems","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#Composite-quantum-systems","content":" Composite quantum systems A  CompositeQuantumSystem  is constructed from a list of subsystems and their interactions. The interaction, in the form of drift or drive Hamiltonian, acts on the full Hilbert space. The subsystems, with their own drift and drive Hamiltonians, are internally lifted to the full Hilbert space. system_1 = QuantumSystem([PAULIS[:X]])\nsystem_2 = QuantumSystem([PAULIS[:Y]])\nH_drift = PAULIS[:Z] ⊗ PAULIS[:Z]\nsystem = CompositeQuantumSystem(H_drift, [system_1, system_2]); The drift Hamiltonian is the ZZ coupling. get_drift(system) |> sparse 4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n 1.0+0.0im       ⋅           ⋅          ⋅    \n     ⋅      -1.0+0.0im       ⋅          ⋅    \n     ⋅           ⋅      -1.0+0.0im      ⋅    \n     ⋅           ⋅           ⋅      1.0+0.0im The drives are the X and Y operators on the first and second subsystems. drives = get_drives(system)\ndrives[1] |> sparse 4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n     ⋅          ⋅      1.0+0.0im      ⋅    \n     ⋅          ⋅          ⋅      1.0+0.0im\n 1.0+0.0im      ⋅          ⋅          ⋅    \n     ⋅      1.0+0.0im      ⋅          ⋅     drives[2] |> sparse 4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n     ⋅      0.0-1.0im      ⋅          ⋅    \n 0.0+1.0im      ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅      0.0-1.0im\n     ⋅          ⋅      0.0+1.0im      ⋅    "},{"id":84,"pagetitle":"Quantum Systems","title":"The lift_operator function","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#The-lift_operator-function","content":" The  lift_operator  function To lift operators acting on a subsystem into the full Hilbert space, use  lift_operator ."},{"id":85,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.lift_operator","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.lift_operator-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystems.lift_operator  —  Function lift_operator(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift_operator(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift_operator(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift_operator(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...) Lift an  operator  acting on the  i -th subsystem within  subsystem_levels  to an operator acting on the entire system spanning  subsystem_levels . source Create an  a + a'  operator acting on the 1st subsystem of a qutrit and qubit system. subspace_levels = [3, 2]\nlift_operator(create(3) + annihilate(3), 1, subspace_levels) .|> real |> sparse 6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n  ⋅    ⋅   1.0       ⋅        ⋅        ⋅ \n  ⋅    ⋅    ⋅       1.0       ⋅        ⋅ \n 1.0   ⋅    ⋅        ⋅       1.41421   ⋅ \n  ⋅   1.0   ⋅        ⋅        ⋅       1.41421\n  ⋅    ⋅   1.41421   ⋅        ⋅        ⋅ \n  ⋅    ⋅    ⋅       1.41421   ⋅        ⋅  Create IXI operator on the 2nd qubit in a 3-qubit system. lift_operator(PAULIS[:X], 2, 3) .|> real |> sparse 8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n  ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ \n 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅  Create an XX operator acting on qubits 3 and 4 in a 4-qubit system. lift_operator([PAULIS[:X], PAULIS[:X]], [3, 4], 4) .|> real |> sparse 16×16 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:\n⎡⡠⠊⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⡠⠊⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⡠⠊⠀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⡠⠊⎦ We can also lift an operator that entangles different subspaces by passing the indices of the entangled subsystems. #_Here's another way to create an XX operator acting on qubits 3 and 4 in a 4-qubit system._\nlift_operator(kron(PAULIS[:X], PAULIS[:X]), [3, 4], 4) .|> real |> sparse 16×16 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:\n⎡⡠⠊⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⡠⠊⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⡠⠊⠀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⡠⠊⎦ Lift a CX gate acting on the 1st and 3rd qubits in a 3-qubit system. The result is independent of the state of the second qubit. lift_operator(GATES[:CX], [1, 3], 3) .|> real |> sparse 8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅ "},{"id":86,"pagetitle":"Quantum Systems","title":"Reachability tests","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#Reachability-tests","content":" Reachability tests Whether a quantum system can be used to reach a target state or operator can be tested by computing the dynamical Lie algebra. Access to this calculation is provided by the  is_reachable  function."},{"id":87,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystemUtils.is_reachable  —  Function is_reachable(gate, hamiltonians; kwargs...) Check if the  gate  is reachable using the given  hamiltonians . Arguments gate::AbstractMatrix : target gate hamiltonians::AbstractVector{<:AbstractMatrix} : generators of the Lie algebra Keyword Arguments subspace::AbstractVector{<:Int}=1:size(gate, 1) : subspace indices compute_basis::Bool=true : compute the basis or use the Hamiltonians directly remove_trace::Bool=true : remove trace from generators verbose::Bool=true : print information about the operator algebra atol::Float32=eps(Float32) : absolute tolerance See also  QuantumSystemUtils.operator_algebra . source is_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...) Check if the  gate  is reachable using the given  system . Keyword Arguments use_drift::Bool=true : include drift Hamiltonian in the generators kwargs... : keyword arguments for  is_reachable source Y can be reached by commuting Z and X. system = QuantumSystem(PAULIS[:Z], [PAULIS[:X]])\nis_reachable(PAULIS[:Y], system) true Y cannot be reached by X alone. system = QuantumSystem([PAULIS[:X]])\nis_reachable(PAULIS[:Y], system) false"},{"id":88,"pagetitle":"Quantum Systems","title":"Direct sums","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#Direct-sums","content":" Direct sums The direct sum of two quantum systems is constructed with the  direct_sum  function."},{"id":89,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.DirectSums.direct_sum","ref":"/PiccoloQuantumObjects/dev/generated/quantum_systems/#PiccoloQuantumObjects.DirectSums.direct_sum-generated-quantum_systems","content":" PiccoloQuantumObjects.DirectSums.direct_sum  —  Function direct_sum(A::AbstractMatrix, B::AbstractMatrix) Returns the direct sum of two matrices. source direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC) Returns the direct sum of two sparse matrices. source direct_sum(Ã⃗::AbstractVector, B̃⃗::AbstractVector) Returns the direct sum of two iso_vec operators. source direct_sum(sys1::QuantumSystem, sys2::QuantumSystem) Returns the direct sum of two  QuantumSystem  objects. source Create a pair of non-interacting qubits. system_1 = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]])\nsystem_2 = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]])\nsystem = direct_sum(system_1, system_2)\nget_drift(system) |> sparse 4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n 1.0+0.0im       ⋅          ⋅           ⋅    \n     ⋅      -1.0+0.0im      ⋅           ⋅    \n     ⋅           ⋅      1.0+0.0im       ⋅    \n     ⋅           ⋅          ⋅      -1.0+0.0im This page was generated using  Literate.jl ."},{"id":92,"pagetitle":"Rollouts","title":"Rollouts and fidelity","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#Rollouts-and-fidelity","content":" Rollouts and fidelity using PiccoloQuantumObjects\nusing NamedTrajectories\nusing SparseArrays # for visualization\nusing LinearAlgebra Rollouts are simulations of a quantum system. In a rollout, controls are integrated forward in time using the dynamics implied by a provided quantum systems. The defualt is to use zero-order hold integration to simulate the evolution–-that is, the controls are held constant between time steps. For quantum states, the Schrödinger equation is used: \\[\\psi(t + \\Delta t) = \\exp\\left(-i H(\\mathbf{a}(t)) \\Delta t\\right) \\psi(t)\\] The visited states are collected into a matrix of size  (2n, T) , for the isomorphic Hilbert space dimension  2n  and timesteps  T . Note All of the returned rollout are assumed to be real valued. It is helpful to use the appropriate isomorphisms to convert between real and complex quantum objects, and  eachcol  to iterate over the rollout columns. There are rollouts for each kind of quantum object:  quantum states ,  unitary operators , and  density operators . A fidelity function is also provided for each kind of quantum objectand a rollout fidelity function compares the final state of a rollout to a goal state."},{"id":93,"pagetitle":"Rollouts","title":"Fidelity functions","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#Fidelity-functions","content":" Fidelity functions The fidelity functions are used to measure how close two quantum states or operators are to each other. fidelity  calculates the fidelity between two quantum states. unitary_fidelity  calculates the fidelity between two unitary operators. State fidelity . ψ = GATES.X * [1.0, 0.0]\nψ_goal = [0.0, 1.0]\nfidelity(ψ, ψ_goal) 1.0 Unitary fidelity of orthogonal operations. U = GATES.Y\nU_goal = GATES.X\nunitary_fidelity(U, U_goal) 0.0"},{"id":94,"pagetitle":"Rollouts","title":"Quantum State Rollouts","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#Quantum-State-Rollouts","content":" Quantum State Rollouts The  rollout  function simulates the evolution of a real valued quantum state under given controls and quantum system."},{"id":95,"pagetitle":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.rollout","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#PiccoloQuantumObjects.Rollouts.rollout-generated-rollouts","content":" PiccoloQuantumObjects.Rollouts.rollout  —  Function rollout(\n    ψ̃_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout(\n    ψ_init::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout(\n    inits::AbstractVector{<:AbstractVector},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n) Rollout a quantum state  ψ̃_init  under the control  controls  for a time  Δt  using the system  system . If  exp_vector_product  is  true , the integrator is expected to have a signature like the exponential action,  expv . Otherwise, it is expected to have a signature like  exp . Types should allow for autodifferentiable controls and times. source"},{"id":96,"pagetitle":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.rollout_fidelity","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#PiccoloQuantumObjects.Rollouts.rollout_fidelity-generated-rollouts","content":" PiccoloQuantumObjects.Rollouts.rollout_fidelity  —  Function rollout_fidelity(\n    ψ̃_init::AbstractVector{<:Real},\n    ψ̃_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout_fidelity(\n    ψ_init::AbstractVector{<:Complex},\n    ψ_goal::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout_fidelity(\n    trajectory::NamedTrajectory,\n    system::AbstractQuantumSystem\n) Calculate the fidelity between the final state of a rollout and a goal state. source The rollout is a matrix of size  (2n, T) . T = 10\nψ_init = ComplexF64[1.0, 0.0]\ncontrols = rand(2, T)\nΔt = fill(0.1, T)\nsystem = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]])\nψ̃_rollout = rollout(ψ_init, controls, Δt, system)\nψ̃_rollout |> size (4, 10)"},{"id":97,"pagetitle":"Rollouts","title":"Quantum State Rollout Fidelity","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#Quantum-State-Rollout-Fidelity","content":" Quantum State Rollout Fidelity States must be cast to complex for the rollout to know the difference between real and isomorphic states. ψ_goal = ComplexF64[0.0, 1.0]\nrollout_fidelity(ψ_init, ψ_goal, controls, Δt, system) 0.253014988945093 Warning Don't forget to convert the quantum state to the appropriate isomorphism before calculating the fidelity. fidelity(iso_to_ket(ψ̃_rollout[:, end]), ψ_goal) 0.253014988945093 The initial state and goal are often inferred from the properly configured trajectory of a control problem. components = (ψ̃ = zeros(Float64, size(ψ̃_rollout)), a = controls, Δt = Δt)\ntraj = NamedTrajectory(\n    components;\n    timestep=:Δt,\n    controls=:a,\n    initial=(ψ̃ = ket_to_iso(ψ_init),),\n    goal=(ψ̃ = ket_to_iso(ψ_goal),),\n)\nrollout_fidelity(traj, system) 0.253014988945093 Note The rollout fidelity is not the same thing as the fidelity of the final trajectory state. fidelity(iso_to_ket(traj.ψ̃[:, end]), ψ_goal) 0.0"},{"id":98,"pagetitle":"Rollouts","title":"Unitary Rollouts","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#Unitary-Rollouts","content":" Unitary Rollouts"},{"id":99,"pagetitle":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.unitary_rollout","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#PiccoloQuantumObjects.Rollouts.unitary_rollout-generated-rollouts","content":" PiccoloQuantumObjects.Rollouts.unitary_rollout  —  Function unitary_rollout(\n    Ũ⃗_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n) Rollout a isomorphic unitary operator  Ũ⃗_init  under the control  controls  for a time  Δt  using the system  system . Arguments Ũ⃗_init::AbstractVector{<:Real} : Initial unitary vector controls::AbstractMatrix{<:Real} : Control matrix Δt::AbstractVector : Time steps system::AbstractQuantumSystem : Quantum system Keyword Arguments show_progress::Bool=false : Show progress bar integrator::Function=expv : Integrator function exp_vector_product::Bool : Infer whether the integrator is an exponential-vector product source"},{"id":100,"pagetitle":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity-generated-rollouts","content":" PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity  —  Function unitary_rollout_fidelity(\n    Ũ⃗_init::AbstractVector{<:Real},\n    Ũ⃗_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    Ũ⃗_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_init::AbstractMatrix{<:Complex},\n    U_goal::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_goal::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_goal::EmbeddedOperator,\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    subspace::AbstractVector{Int}=U_goal.subspace,\n    kwargs...\n)\nunitary_rollout_fidelity(\n    traj::NamedTrajectory,\n    sys::AbstractQuantumSystem;\n    kwargs...\n) Calculate the fidelity between the final state of a unitary rollout and a goal state.  If the initial unitary is not provided, the identity operator is assumed. If  phases  and  phase_operators  are provided, the free phase unitary fidelity is calculated. source Ũ⃗_rollout = unitary_rollout(controls, Δt, system)\nŨ⃗_rollout |> size (8, 10) Convert to unitary operators, and have a look at the initial unitary. iso_vec_to_operator.(eachcol(Ũ⃗_rollout[:, 1])) |> first 2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im"},{"id":101,"pagetitle":"Rollouts","title":"Open Quantum System Rollouts","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#Open-Quantum-System-Rollouts","content":" Open Quantum System Rollouts"},{"id":102,"pagetitle":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.open_rollout","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#PiccoloQuantumObjects.Rollouts.open_rollout-generated-rollouts","content":" PiccoloQuantumObjects.Rollouts.open_rollout  —  Function open_rollout(\n    ρ⃗₁::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::OpenQuantumSystem;\n    kwargs...\n) Rollout a quantum state  ρ⃗₁  under the control  controls  for a time  Δt Arguments ρ⃗₁::AbstractVector{<:Complex} : Initial state vector controls::AbstractMatrix{<:Real} : Control matrix Δt::AbstractVector : Time steps system::OpenQuantumSystem : Quantum system Keyword Arguments show_progress::Bool=false : Show progress bar integrator::Function=expv : Integrator function exp_vector_product::Bool : Infer whether the integrator is an exponential-vector product source"},{"id":103,"pagetitle":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.open_rollout_fidelity","ref":"/PiccoloQuantumObjects/dev/generated/rollouts/#PiccoloQuantumObjects.Rollouts.open_rollout_fidelity-generated-rollouts","content":" PiccoloQuantumObjects.Rollouts.open_rollout_fidelity  —  Function open_rollout_fidelity(\n    ρ⃗₁::AbstractVector{<:Complex},\n    ρ⃗₂::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::OpenQuantumSystem\n)\nopen_rollout_fidelity(\n    ρ₁::AbstractMatrix{<:Complex},\n    ρ₂::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::OpenQuantumSystem\n)\nopen_rollout_fidelity(\n    traj::NamedTrajectory,\n    system::OpenQuantumSystem;\n    state_name::Symbol=:ρ⃗̃,\n    control_name::Symbol=:a,\n    kwargs...\n) Calculate the fidelity between the final state of an open quantum system rollout and a goal state. source Open rollouts require open quantum systems . open_system = OpenQuantumSystem(system)\n\nρ_init = ψ_init * ψ_init'\nρ̃⃗_rollout = open_rollout(ρ_init, controls, Δt, open_system)\nρ̃⃗_rollout |> size (8, 10) This page was generated using  Literate.jl ."},{"id":106,"pagetitle":"Library","title":"Quantum Systems","ref":"/PiccoloQuantumObjects/dev/lib/#Quantum-Systems","content":" Quantum Systems"},{"id":107,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem  —  Type AbstractQuantumSystem Abstract type for defining systems. source"},{"id":108,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem  —  Type CompositeQuantumSystem <: AbstractQuantumSystem A composite quantum system consisting of  subsystems . Couplings between subsystems can be additionally defined. Subsystem drives are always appended to any new coupling drives. source"},{"id":109,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem  —  Type OpenQuantumSystem <: AbstractQuantumSystem A struct for storing open quantum dynamics. Additional fields dissipation_operators::Vector{AbstractMatrix} : The dissipation operators. See also  QuantumSystem . source"},{"id":110,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.QuantumSystem  —  Type QuantumSystem <: AbstractQuantumSystem A struct for storing quantum dynamics. Fields H::Function : The Hamiltonian function, excluding dissipation: a -> H(a). G::Function : The isomorphic generator function, including dissipation, a -> G(a). levels::Int : The number of levels in the system. n_drives::Int : The number of drives in the system. source"},{"id":111,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.TimeDependentQuantumSystem","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystems.TimeDependentQuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.TimeDependentQuantumSystem  —  Type TimeDependentQuantumSystem <: AbstractQuantumSystem A struct for storing time-dependent quantum dynamics. Fields H::Function : The Hamiltonian function with time: (a, t) -> H(a, t). G::Function : The isomorphic generator function with time, (a, t) -> G(a, t). n_drives::Int : The number of drives in the system. levels::Int : The number of levels in the system. params::Dict{Symbol, Any} : A dictionary of parameters. source"},{"id":112,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.VariationalQuantumSystem","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystems.VariationalQuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.VariationalQuantumSystem  —  Type VariationalQuantumSystem <: AbstractQuantumSystem A struct for storing variational quantum dynamics. Additional fields G_vars::AbstractVector{<:Function} : Variational generator functions See also  QuantumSystem . source"},{"id":113,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.get_drift","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystems.get_drift-Tuple{AbstractQuantumSystem}","content":" PiccoloQuantumObjects.QuantumSystems.get_drift  —  Method get_drift(sys::AbstractQuantumSystem) Returns the drift Hamiltonian of the system. source"},{"id":114,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.get_drives","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystems.get_drives-Tuple{AbstractQuantumSystem}","content":" PiccoloQuantumObjects.QuantumSystems.get_drives  —  Method get_drives(sys::AbstractQuantumSystem) Returns the drive Hamiltonians of the system. source"},{"id":115,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.lift_operator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystems.lift_operator","content":" PiccoloQuantumObjects.QuantumSystems.lift_operator  —  Function lift_operator(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift_operator(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift_operator(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift_operator(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...) Lift an  operator  acting on the  i -th subsystem within  subsystem_levels  to an operator acting on the entire system spanning  subsystem_levels . source"},{"id":116,"pagetitle":"Library","title":"Gates","ref":"/PiccoloQuantumObjects/dev/lib/#Gates","content":" Gates"},{"id":117,"pagetitle":"Library","title":"PiccoloQuantumObjects.Gates.GATES","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Gates.GATES","content":" PiccoloQuantumObjects.Gates.GATES  —  Constant A constant dictionary  GATES  containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix. GATES[:I]  - Identity: Leaves the state unchanged. GATES[:X]  - Pauli-X (NOT): Flips the qubit state. GATES[:Y]  - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere. GATES[:Z]  - Pauli-Z: Flips the phase of the qubit state. GATES[:H]  - Hadamard: Creates superposition by transforming basis states. GATES[:CX]  - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1⟩. GATES[:CZ]  - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1⟩. GATES[:XI]  - Complex: A gate for complex operations. GATES[:sqrtiSWAP]  - Square root of iSWAP: Partially swaps two qubits with a phase. source"},{"id":118,"pagetitle":"Library","title":"PiccoloQuantumObjects.Gates.PAULIS","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Gates.PAULIS","content":" PiccoloQuantumObjects.Gates.PAULIS  —  Constant The 2×2 Pauli matrics and identity. source"},{"id":119,"pagetitle":"Library","title":"Embedded Operators","ref":"/PiccoloQuantumObjects/dev/lib/#Embedded-Operators","content":" Embedded Operators"},{"id":120,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator","content":" PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator  —  Type AbstractPiccoloOperator Union type for operators. source"},{"id":121,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Type EmbeddedOperator Embedded operator type to represent an operator embedded in a subspace of a larger quantum system. Fields operator::Matrix{<:Number} : Embedded operator of size    prod(subsystem_levels) x prod(subsystem_levels) . subspace::Vector{Int} : Indices of the subspace the operator is embedded in. subsystem_levels::Vector{Int} : Levels of the subsystems in the composite system. source"},{"id":122,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n) Embed the  subspace_operator  into the provided  subspaces  of a composite system, where the  subsystem_indices  list the subspaces at which the operator is defined, and the  subsystem_levels  list the levels of the subsystems in which the operator is embedded. source"},{"id":123,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, CompositeQuantumSystem}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    composite_system::CompositeQuantumSystem\n) Embed the  subspace_operator  into the provided  subspaces  of a composite system. source"},{"id":124,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, QuantumSystem}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(subspace_operator::AbstractMatrix{<:Number}, system::QuantumSystem; kwargs...) Embed the  subspace_operator  into a quantum  system . source"},{"id":125,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{Int64}}} where T<:Number","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int}) Create an embedded operator. The  operator  is embedded at the  subspace  of the system spanned by the  subsystem_levels . source"},{"id":126,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.embed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","content":" PiccoloQuantumObjects.EmbeddedOperators.embed  —  Method embed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator) Embed the  subspace_operator  in the subspace of a larger  embedded_operator . source"},{"id":127,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.embed-Union{Tuple{R}, Tuple{AbstractMatrix{R}, AbstractVector{Int64}, Int64}} where R<:Number","content":" PiccoloQuantumObjects.EmbeddedOperators.embed  —  Method embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int) Embed an  operator  in the  subspace  of a larger matrix of size  levels x levels . source"},{"id":128,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices-Tuple{Int64, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices  —  Method get_enr_subspace_indices(excitation_restriction::Int, subsystem_levels::AbstractVector{Int}) Get the indices for the subspace of the quantum system with an excitation restriction. source"},{"id":129,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices  —  Function get_iso_vec_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_iso_vec_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_iso_vec_leakage_indices(op::EmbeddedOperator) Get the indices for the leakage in the isomorphic vector space for operators. source"},{"id":130,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices  —  Function get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator) Get the indices for the subspace in the isomorphic vector space for operators. source"},{"id":131,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices  —  Function get_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_leakage_indices(op::EmbeddedOperator) Get the indices for the states that are outside of the provided subspace of the quantum system. source"},{"id":132,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices  —  Function get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)\nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator) Get the indices for the provided subspace of the quantum system. source"},{"id":133,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Method unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}) Unembed a subspace operator from the  matrix . This is equivalent to calling  matrix[subspace, subspace] . source"},{"id":134,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Method unembed(op::AbstractMatrix, embedded_op::EmbeddedOperator) Unembed a sub-matrix from the  op  at the subspace defined by  embedded_op . source"},{"id":135,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{EmbeddedOperator}","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Method unembed(embedded_op::EmbeddedOperator) Unembed an embedded operator, returning the original operator. source"},{"id":136,"pagetitle":"Library","title":"Isomorphisims","ref":"/PiccoloQuantumObjects/dev/lib/#Isomorphisims","content":" Isomorphisims"},{"id":137,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.G","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.G-Tuple{AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.G  —  Method G(H::AbstractMatrix)::Matrix{Float64} Returns the isomorphism of  $-iH$ , i.e.  $G(H) = \\text{iso}(-iH)$ . See also  Isomorphisms.iso ,  Isomorphisms.H . source"},{"id":138,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.H","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.H-Tuple{AbstractMatrix{<:Real}}","content":" PiccoloQuantumObjects.Isomorphisms.H  —  Method H(G::AbstractMatrix{<:Real}) Returns the inverse of  $G(H) = iso(-iH)$ , i.e. returns H. See also  Isomorphisms.iso ,  Isomorphisms.G . source"},{"id":139,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ad_vec","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.ad_vec-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","content":" PiccoloQuantumObjects.Isomorphisms.ad_vec  —  Method ad_vec(H::AbstractMatrix{ℂ}; anti::Bool=false) where ℂ <: Number Returns the vectorized adjoint action of a matrix  H : \\[\\text{ad_vec}(H) = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes H - (-1)^{\\text{anti}} \\mqty(0 & 1 \\\\ 1 & 0) \\otimes H^*\\] source"},{"id":140,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec-Tuple{AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec  —  Method density_to_iso_vec(ρ::AbstractMatrix{<:Number}) Returns the isomorphism  ρ⃗̃ = ket_to_iso(vec(ρ))  of a density matrix  ρ source"},{"id":141,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso-Tuple{AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.iso  —  Method iso(H::AbstractMatrix{<:Number}) Returns the isomorphism of  $H$ : \\[iso(H) = \\widetilde{H} = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] where  $\\Im(H)$  and  $\\Re(H)$  are the imaginary and real parts of  $H$  and the tilde  indicates the standard isomorphism of a complex valued matrix: \\[\\widetilde{H} = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] See also  Isomorphisms.G ,  Isomorphisms.H . source"},{"id":142,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_D","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso_D-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","content":" PiccoloQuantumObjects.Isomorphisms.iso_D  —  Method iso_D(L::AbstractMatrix{ℂ}) where ℂ <: Number Returns the isomorphic representation of the Lindblad dissipator  L . source"},{"id":143,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec-Union{Tuple{AbstractMatrix{ℝ}}, Tuple{ℝ}} where ℝ<:Real","content":" PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec  —  Method iso_operator_to_iso_vec(Ũ::AbstractMatrix{ℝ}) where ℝ <: Real Convert a real matrix  Ũ  representing an isomorphism operator into a real vector. source"},{"id":144,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator-Tuple{Any}","content":" PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator  —  Method iso_operator_to_operator(Ũ) source"},{"id":145,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_to_ket","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso_to_ket-Tuple{AbstractVector{<:Real}}","content":" PiccoloQuantumObjects.Isomorphisms.iso_to_ket  —  Method iso_to_ket(ψ̃::AbstractVector{<:Real}) Convert a real isomorphism vector  ψ̃  into a ket vector. source"},{"id":146,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density-Tuple{AbstractVector{<:Real}}","content":" PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density  —  Method iso_vec_to_density(ρ⃗̃::AbstractVector{<:Real}) Returns the density matrix  ρ  from its isomorphism  ρ⃗̃ source"},{"id":147,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator-Union{Tuple{AbstractVector{ℝ}}, Tuple{ℝ}} where ℝ<:Real","content":" PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator  —  Method iso_vec_to_iso_operator(Ũ⃗::AbstractVector{ℝ}) where ℝ <: Real Convert a real vector  Ũ⃗  into a real matrix representing an isomorphism operator. source"},{"id":148,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator-Union{Tuple{AbstractVector{ℝ}}, Tuple{ℝ}} where ℝ<:Real","content":" PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator  —  Method iso_vec_to_operator(Ũ⃗::AbstractVector{ℝ}) where ℝ <: Real Convert a real vector  Ũ⃗  into a complex matrix representing an operator. source"},{"id":149,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ket_to_iso","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.ket_to_iso-Tuple{AbstractVector{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.ket_to_iso  —  Method ket_to_iso(ψ::AbstractVector{<:Number}) Convert a ket vector  ψ  into a complex vector with real and imaginary parts. source"},{"id":150,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.mat","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.mat-Tuple{AbstractVector}","content":" PiccoloQuantumObjects.Isomorphisms.mat  —  Method mat(x::AbstractVector) Convert a vector  x  into a square matrix. The length of  x  must be a perfect square. source"},{"id":151,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator-Tuple{Any}","content":" PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator  —  Method operator_to_iso_operator(U) source"},{"id":152,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","content":" PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec  —  Method operator_to_iso_vec(U::AbstractMatrix{ℂ}) where ℂ <: Number Convert a complex matrix  U  representing an operator into a real vector. source"},{"id":153,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.var_G","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Isomorphisms.var_G-Union{Tuple{ℝ2}, Tuple{ℝ1}, Tuple{AbstractMatrix{ℝ1}, AbstractVector{<:AbstractMatrix{ℝ2}}}} where {ℝ1<:Real, ℝ2<:Real}","content":" PiccoloQuantumObjects.Isomorphisms.var_G  —  Method var_G(G::AbstractMatrix{<:Real}, G_vars::AbstractVector{<:AbstractMatrix{<:Real}}) Returns the variational generator of  G  with variational derivatives,  G_vars . The variational generator is  \\[\\text{var}_G(G, [G_a, G_b]) = \\mqty( G & 0 & 0 \\\\ G_a & G & 0 \\\\ G_b & 0 & G )\\] where  G  is the isomorphism of a Hamiltonian and  G_a  and  G_b  are the variational  derivatives of  G  for parameters  a  and  b , respectively. source"},{"id":154,"pagetitle":"Library","title":"Quantum Object Utilities","ref":"/PiccoloQuantumObjects/dev/lib/#Quantum-Object-Utilities","content":" Quantum Object Utilities"},{"id":155,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.annihilate","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumObjectUtils.annihilate-Tuple{Int64}","content":" PiccoloQuantumObjects.QuantumObjectUtils.annihilate  —  Method annihilate(levels::Int) Get the annihilation operator for a system with  levels . source"},{"id":156,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.create","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumObjectUtils.create-Tuple{Int64}","content":" PiccoloQuantumObjects.QuantumObjectUtils.create  —  Method create(levels::Int) Get the creation operator for a system with  levels . source"},{"id":157,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.haar_identity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumObjectUtils.haar_identity-Tuple{Int64, Number}","content":" PiccoloQuantumObjects.QuantumObjectUtils.haar_identity  —  Method haar_identity(n::Int, radius::Number) Generate a random unitary matrix close to the identity matrix using the Haar measure for an  n -dimensional system with a given  radius . The smaller the radius, the closer the matrix will be to the identity. source"},{"id":158,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.haar_random","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumObjectUtils.haar_random-Tuple{Int64}","content":" PiccoloQuantumObjects.QuantumObjectUtils.haar_random  —  Method haar_random(n::Int) Generate a random unitary matrix using the Haar measure for an  n -dimensional system. source"},{"id":159,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring-Tuple{String}","content":" PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring  —  Method ket_from_bitstring(ket::String) Get the state vector for a qubit system given a ket string  ket  of 0s and 1s. source"},{"id":160,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string-Tuple{String, Vector{Int64}}","content":" PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string  —  Method ket_from_string(\n    ket::String,\n    levels::Vector{Int};\n    level_dict=Dict(:g => 0, :e => 1, :f => 2, :h => 3, :i => 4, :j => 5, :k => 6, :l => 7),\n    return_states=false\n) Construct a quantum state from a string ket representation. source"},{"id":161,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string-Tuple{String}","content":" PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string  —  Method operator_from_string(operator::String; lookup=PAULIS) Reduce the string (each character is one key) via operators from a dictionary. source"},{"id":162,"pagetitle":"Library","title":"Quantum System Utilities","ref":"/PiccoloQuantumObjects/dev/lib/#Quantum-System-Utilities","content":" Quantum System Utilities"},{"id":163,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_linearly_dependent","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_linearly_dependent-Tuple{AbstractMatrix}","content":" PiccoloQuantumObjects.QuantumSystemUtils.is_linearly_dependent  —  Method is_linearly_dependent(M::AbstractMatrix; eps=eps(Float32), verbose=true) Check if the columns of the matrix  M  are linearly dependent. source"},{"id":164,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractQuantumSystem}","content":" PiccoloQuantumObjects.QuantumSystemUtils.is_reachable  —  Method is_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...) Check if the  gate  is reachable using the given  system . Keyword Arguments use_drift::Bool=true : include drift Hamiltonian in the generators kwargs... : keyword arguments for  is_reachable source"},{"id":165,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}}","content":" PiccoloQuantumObjects.QuantumSystemUtils.is_reachable  —  Method is_reachable(gate, hamiltonians; kwargs...) Check if the  gate  is reachable using the given  hamiltonians . Arguments gate::AbstractMatrix : target gate hamiltonians::AbstractVector{<:AbstractMatrix} : generators of the Lie algebra Keyword Arguments subspace::AbstractVector{<:Int}=1:size(gate, 1) : subspace indices compute_basis::Bool=true : compute the basis or use the Hamiltonians directly remove_trace::Bool=true : remove trace from generators verbose::Bool=true : print information about the operator algebra atol::Float32=eps(Float32) : absolute tolerance See also  QuantumSystemUtils.operator_algebra . source"},{"id":166,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra-Union{Tuple{Vector{<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","content":" PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra  —  Method operator_algebra(generators; kwargs...) Compute the Lie algebra basis for the given  generators . Arguments generators::Vector{<:AbstractMatrix} : generators of the Lie algebra Keyword Arguments return_layers::Bool=false : return the Lie tree layers normalize::Bool=false : normalize the basis verbose::Bool=false : print information remove_trace::Bool=true : remove trace from generators source"},{"id":167,"pagetitle":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}","content":" PiccoloQuantumObjects.DirectSums.direct_sum  —  Method direct_sum(A::AbstractMatrix, B::AbstractMatrix) Returns the direct sum of two matrices. source"},{"id":168,"pagetitle":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}","content":" PiccoloQuantumObjects.DirectSums.direct_sum  —  Method direct_sum(Ã⃗::AbstractVector, B̃⃗::AbstractVector) Returns the direct sum of two iso_vec operators. source"},{"id":169,"pagetitle":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}","content":" PiccoloQuantumObjects.DirectSums.direct_sum  —  Method direct_sum(sys1::QuantumSystem, sys2::QuantumSystem) Returns the direct sum of two  QuantumSystem  objects. source"},{"id":170,"pagetitle":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}","content":" PiccoloQuantumObjects.DirectSums.direct_sum  —  Method direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC) Returns the direct sum of two sparse matrices. source"},{"id":171,"pagetitle":"Library","title":"Rollouts","ref":"/PiccoloQuantumObjects/dev/lib/#Rollouts","content":" Rollouts"},{"id":172,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.fidelity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.fidelity-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Rollouts.fidelity  —  Method fidelity(ρ::AbstractMatrix{<:Number}, ρ_goal::AbstractMatrix{<:Number}) Calculate the fidelity between two density matrices  ρ  and  ρ_goal . source"},{"id":173,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.fidelity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.fidelity-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","content":" PiccoloQuantumObjects.Rollouts.fidelity  —  Method fidelity(ψ::AbstractVector{<:Number}, ψ_goal::AbstractVector{<:Number}) Calculate the fidelity between two quantum states  ψ  and  ψ_goal . source"},{"id":174,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.free_phase","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.free_phase-Union{Tuple{ℂ}, Tuple{AbstractVector{<:Real}, AbstractVector{<:AbstractMatrix{<:ℂ}}}} where ℂ<:Number","content":" PiccoloQuantumObjects.Rollouts.free_phase  —  Method free_phase(phases::AbstractVector{<:Real}, phase_operators::AbstractVector{<:AbstractMatrix{<:ℂ}}) Rotate the  phase_operators  by the  phases  and return the Kronecker product. source"},{"id":175,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.infer_is_evp","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.infer_is_evp-Tuple{Function}","content":" PiccoloQuantumObjects.Rollouts.infer_is_evp  —  Method infer_is_evp(integrator::Function) Infer whether the integrator is a exponential-vector product (EVP) function. If  true , the integrator is expected to have a signature like the exponential action,  expv . Otherwise, it is expected to have a signature like  exp . source"},{"id":176,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.open_rollout","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.open_rollout","content":" PiccoloQuantumObjects.Rollouts.open_rollout  —  Function open_rollout(\n    ρ⃗₁::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::OpenQuantumSystem;\n    kwargs...\n) Rollout a quantum state  ρ⃗₁  under the control  controls  for a time  Δt Arguments ρ⃗₁::AbstractVector{<:Complex} : Initial state vector controls::AbstractMatrix{<:Real} : Control matrix Δt::AbstractVector : Time steps system::OpenQuantumSystem : Quantum system Keyword Arguments show_progress::Bool=false : Show progress bar integrator::Function=expv : Integrator function exp_vector_product::Bool : Infer whether the integrator is an exponential-vector product source"},{"id":177,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.open_rollout","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.open_rollout-Tuple{AbstractMatrix{<:Complex}, AbstractMatrix{<:Real}, AbstractVector, OpenQuantumSystem}","content":" PiccoloQuantumObjects.Rollouts.open_rollout  —  Method open_rollout(\n    ρ₁::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::OpenQuantumSystem;\n    kwargs...\n) Rollout a density matrix  ρ₁  under the control  controls  and timesteps  Δt source"},{"id":178,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.open_rollout_fidelity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.open_rollout_fidelity","content":" PiccoloQuantumObjects.Rollouts.open_rollout_fidelity  —  Function open_rollout_fidelity(\n    ρ⃗₁::AbstractVector{<:Complex},\n    ρ⃗₂::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::OpenQuantumSystem\n)\nopen_rollout_fidelity(\n    ρ₁::AbstractMatrix{<:Complex},\n    ρ₂::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::OpenQuantumSystem\n)\nopen_rollout_fidelity(\n    traj::NamedTrajectory,\n    system::OpenQuantumSystem;\n    state_name::Symbol=:ρ⃗̃,\n    control_name::Symbol=:a,\n    kwargs...\n) Calculate the fidelity between the final state of an open quantum system rollout and a goal state. source"},{"id":179,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.rollout","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.rollout","content":" PiccoloQuantumObjects.Rollouts.rollout  —  Function rollout(\n    ψ̃_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout(\n    ψ_init::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout(\n    inits::AbstractVector{<:AbstractVector},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n) Rollout a quantum state  ψ̃_init  under the control  controls  for a time  Δt  using the system  system . If  exp_vector_product  is  true , the integrator is expected to have a signature like the exponential action,  expv . Otherwise, it is expected to have a signature like  exp . Types should allow for autodifferentiable controls and times. source"},{"id":180,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.rollout_fidelity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.rollout_fidelity","content":" PiccoloQuantumObjects.Rollouts.rollout_fidelity  —  Function rollout_fidelity(\n    ψ̃_init::AbstractVector{<:Real},\n    ψ̃_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout_fidelity(\n    ψ_init::AbstractVector{<:Complex},\n    ψ_goal::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout_fidelity(\n    trajectory::NamedTrajectory,\n    system::AbstractQuantumSystem\n) Calculate the fidelity between the final state of a rollout and a goal state. source"},{"id":181,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.unitary_fidelity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.unitary_fidelity-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Rollouts.unitary_fidelity  —  Method unitary_fidelity(U::AbstractMatrix{<:Number}, U_goal::AbstractMatrix{<:Number}) Calculate the fidelity between unitary operators  U  and  U_goal  in the  subspace . source"},{"id":182,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.unitary_free_phase_fidelity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.unitary_free_phase_fidelity-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector{<:Real}, AbstractVector{<:AbstractMatrix}}","content":" PiccoloQuantumObjects.Rollouts.unitary_free_phase_fidelity  —  Method unitary_free_phase_fidelity(\n    U::AbstractMatrix,\n    U_goal::AbstractMatrix,\n    phases::AbstractVector{<:Real},\n    phase_operators::AbstractVector{<:AbstractMatrix};\n    subspace::AbstractVector{Int}=axes(U, 1)\n) Calculate the fidelity between unitary operators  U  and  U_goal  in the  subspace , including the  phase  rotations about the  phase_operators . source"},{"id":183,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.unitary_rollout","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.unitary_rollout","content":" PiccoloQuantumObjects.Rollouts.unitary_rollout  —  Function unitary_rollout(\n    Ũ⃗_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n) Rollout a isomorphic unitary operator  Ũ⃗_init  under the control  controls  for a time  Δt  using the system  system . Arguments Ũ⃗_init::AbstractVector{<:Real} : Initial unitary vector controls::AbstractMatrix{<:Real} : Control matrix Δt::AbstractVector : Time steps system::AbstractQuantumSystem : Quantum system Keyword Arguments show_progress::Bool=false : Show progress bar integrator::Function=expv : Integrator function exp_vector_product::Bool : Infer whether the integrator is an exponential-vector product source"},{"id":184,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity","content":" PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity  —  Function unitary_rollout_fidelity(\n    Ũ⃗_init::AbstractVector{<:Real},\n    Ũ⃗_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    Ũ⃗_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_init::AbstractMatrix{<:Complex},\n    U_goal::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_goal::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_goal::EmbeddedOperator,\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::AbstractQuantumSystem;\n    subspace::AbstractVector{Int}=U_goal.subspace,\n    kwargs...\n)\nunitary_rollout_fidelity(\n    traj::NamedTrajectory,\n    sys::AbstractQuantumSystem;\n    kwargs...\n) Calculate the fidelity between the final state of a unitary rollout and a goal state.  If the initial unitary is not provided, the identity operator is assumed. If  phases  and  phase_operators  are provided, the free phase unitary fidelity is calculated. source"},{"id":185,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.variational_rollout","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.variational_rollout","content":" PiccoloQuantumObjects.Rollouts.variational_rollout  —  Function variational_rollout(\n    ψ̃_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector{<:Real},\n    system::VariationalQuantumSystem;\n    show_progress::Bool=false,\n    integrator::Function=expv,\n    exp_vector_product::Bool=infer_is_evp(integrator)\n)\nvariational_rollout(ψ::Vector{<:Complex}, args...; kwargs...)\nvariational_rollout(inits::AbstractVector{<:AbstractVector}, args...; kwargs...)\nvariational_rollout(\n    traj::NamedTrajectory, \n    system::AbstractQuantumSystem; \n    state_name::Symbol=:ψ̃,\n    drive_name::Symbol=:a,\n    kwargs...\n) Simulates the variational evolution of a quantum state under a given control trajectory. Returns Ψ̃::Matrix{<:Real} : The evolved quantum state at each timestep. Ψ̃_vars::Vector{<:Matrix{<:Real}} : The variational derivatives of the    quantum state with respect to the variational parameters. Notes This function computes the variational evolution of a quantum state using the  variational generators of the system. It supports autodifferentiable controls and  timesteps, making it suitable for optimization tasks. The variational derivatives are  computed alongside the state evolution, enabling sensitivity analysis and gradient-based  optimization. source"},{"id":186,"pagetitle":"Library","title":"PiccoloQuantumObjects.Rollouts.variational_unitary_rollout","ref":"/PiccoloQuantumObjects/dev/lib/#PiccoloQuantumObjects.Rollouts.variational_unitary_rollout","content":" PiccoloQuantumObjects.Rollouts.variational_unitary_rollout  —  Function variational_unitary_rollout(\n    Ũ⃗_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector{<:Real},\n    system::VariationalQuantumSystem;\n    show_progress::Bool=false,\n    integrator::Function=expv,\n    exp_vector_product::Bool=infer_is_evp(integrator)\n)\nvariational_unitary_rollout(\n    controls::AbstractMatrix{<:Real},\n    Δt::AbstractVector,\n    system::VariationalQuantumSystem;\n    kwargs...\n)\nvariational_unitary_rollout(\n    traj::NamedTrajectory,\n    system::VariationalQuantumSystem;\n    unitary_name::Symbol=:Ũ⃗,\n    drive_name::Symbol=:a,\n    kwargs...\n) Simulates the variational evolution of a quantum state under a given control trajectory. Returns Ũ⃗::Matrix{<:Real} : The evolved unitary at each timestep. Ũ⃗_vars::Vector{<:Matrix{<:Real}} : The variational derivatives of the  unitary with    respect to the variational parameters. Notes This function computes the variational evolution of a unitary using the  variational generators of the system. It supports autodifferentiable controls and  timesteps, making it suitable for optimization tasks. The variational derivatives are  computed alongside the state evolution, enabling sensitivity analysis and gradient-based  optimization. source"},{"id":189,"pagetitle":"Home","title":"QuantumCollocation.jl","ref":"/QuantumCollocation/dev/#QuantumCollocation.jl","content":" QuantumCollocation.jl QuantumCollocation.jl  sets up and solves  quantum control problems  as nonlinear programs (NLPs). In this context, a generic quantum control problem looks like \\[\\begin{aligned}\n    \\arg \\min_{\\mathbf{Z}}\\quad & J(\\mathbf{Z}) \\\\\n    \\nonumber \\text{s.t.}\\qquad & \\mathbf{f}(\\mathbf{Z}) = 0 \\\\\n    \\nonumber & \\mathbf{g}(\\mathbf{Z}) \\le 0  \n\\end{aligned}\\] where  $\\mathbf{Z}$  is a trajectory  containing states and controls, from  NamedTrajectories.jl . We provide a number of  problem templates  for making it simple and easy to set up and solve  certain types of quantum optimal control problems. These templates all construct a   DirectTrajOptProblem  object from  DirectTrajOpt.jl , which stores all the parts of the optimal control problem."},{"id":190,"pagetitle":"Home","title":"Get started","ref":"/QuantumCollocation/dev/#Get-started","content":" Get started The problem templates are broken down by the state variable of the problem being solved. Ket Problem Templates: Quantum State Smooth Pulse Problem Quantum State Minimum Time Problem Quantum State Sampling Problem Unitary Problem Templates: Unitary Smooth Pulse Problem Unitary Minimum Time Problem Unitary Sampling Problem"},{"id":191,"pagetitle":"Home","title":"Background","ref":"/QuantumCollocation/dev/#Background","content":" Background Problem Templates  are reusable design patterns for setting up and solving common quantum control problems.  For example, a  UnitarySmoothPulseProblem  is tasked with generating a  pulse  sequence  $a_{1:T-1}$  in orderd to minimize infidelity, subject to constraints from the Schroedinger equation, \\[    \\begin{aligned}\n        \\arg \\min_{\\mathbf{Z}}\\quad & |1 - \\mathcal{F}(U_T, U_\\text{goal})|  \\\\\n        \\nonumber \\text{s.t.}\n        \\qquad & U_{t+1} = \\exp\\{- i H(a_t) \\Delta t_t \\} U_t, \\quad \\forall\\, t \\\\\n    \\end{aligned}\\] while a  UnitaryMinimumTimeProblem  minimizes time and constrains fidelity, \\[    \\begin{aligned}\n        \\arg \\min_{\\mathbf{Z}}\\quad & \\sum_{t=1}^T \\Delta t_t \\\\\n        \\qquad & U_{t+1} = \\exp\\{- i H(a_t) \\Delta t_t \\} U_t, \\quad \\forall\\, t \\\\\n        \\nonumber & \\mathcal{F}(U_T, U_\\text{goal}) \\ge 0.9999\n    \\end{aligned}\\] In each case, the dynamics between  knot points $(U_t, a_t)$  and  $(U_{t+1}, a_{t+1})$  are enforced as constraints on the states, which are free variables in the solver; this optimization framework is called  direct trajectory optimization .  Problem templates give the user the ability to add other constraints and objective functions to this problem and solve it efficiently using  Ipopt.jl  and  MathOptInterface.jl  under the hood."},{"id":194,"pagetitle":"Multilevel Transmon","title":"Multilevel Transmon","ref":"/QuantumCollocation/dev/generated/examples/multilevel_transmon/#Multilevel-Transmon","content":" Multilevel Transmon In this example we will look at a multilevel transmon qubit with a Hamiltonian given by \\[\\hat{H}(t) = -\\frac{\\delta}{2} \\hat{n}(\\hat{n} - 1) + u_1(t) (\\hat{a} + \\hat{a}^\\dagger) + u_2(t) i (\\hat{a} - \\hat{a}^\\dagger)\\] where  $\\hat{n} = \\hat{a}^\\dagger \\hat{a}$  is the number operator,  $\\hat{a}$  is the annihilation operator,  $\\delta$  is the anharmonicity, and  $u_1(t)$  and  $u_2(t)$  are control fields. We will use the following parameter values: \\[\\begin{aligned}\n\\delta &= 0.2 \\text{ GHz}\\\\\n\\abs{u_i(t)} &\\leq 0.2 \\text{ GHz}\\\\\nT_0 &= 10 \\text{ ns}\\\\\n\\end{aligned}\\] For convenience, we have defined the  TransmonSystem  function in the  QuantumSystemTemplates  module, which returns a  QuantumSystem  object for a transmon qubit. We will use this function to define the system."},{"id":195,"pagetitle":"Multilevel Transmon","title":"Setting up the problem","ref":"/QuantumCollocation/dev/generated/examples/multilevel_transmon/#Setting-up-the-problem","content":" Setting up the problem To begin, let's load the necessary packages, define the system parameters, and create a a  QuantumSystem  object using the  TransmonSystem  function. using QuantumCollocation\nusing PiccoloQuantumObjects\nusing NamedTrajectories\nusing LinearAlgebra\nusing SparseArrays\nusing Random; Random.seed!(123)\n\nusing PiccoloPlots\nusing CairoMakie\n\n# define the time parameters\n\nT₀ = 10     # total time in ns\nT = 50      # number of time steps\nΔt = T₀ / T # time step\n\n# define the system parameters\nlevels = 5\nδ = 0.2\n\n# add a bound to the controls\na_bound = 0.2\n\n# create the system\nsys = TransmonSystem(levels=levels, δ=δ)\n\n# let's look at the parameters of the system\nsys.params Dict{Symbol, Any} with 8 entries:\n  :lab_frame_type => :duffing\n  :ω              => 4.0\n  :lab_frame      => false\n  :δ              => 0.2\n  :mutiply_by_2π  => true\n  :drives         => true\n  :levels         => 5\n  :frame_ω        => 4.0 Since this is a multilevel transmon and we want to implement an, let's say,  $X$  gate on the qubit subspace, i.e., the first two levels we can utilize the  EmbeddedOperator  type to define the target operator. # define the target operator\nop = EmbeddedOperator(:X, sys)\n\n# show the full operator\nop.operator |> sparse 5×5 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      1.0+0.0im      ⋅          ⋅          ⋅    \n 1.0+0.0im      ⋅          ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅     In this formulation, we also use a subspace identity as the initial state, which looks like function get_subspace_identity(op::EmbeddedOperator)\n    return embed(\n        Matrix{ComplexF64}(I(length(op.subspace))),\n        op.subspace,\n        size(op)[1]\n    )\nend\nget_subspace_identity(op) |> sparse 5×5 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n 1.0+0.0im      ⋅          ⋅          ⋅          ⋅    \n     ⋅      1.0+0.0im      ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅     We can then pass this embedded operator to the  UnitarySmoothPulseProblem  template to create the problem # create the problem\nprob = UnitarySmoothPulseProblem(sys, op, T, Δt; a_bound=a_bound)\n\n# solve the problem\nsolve!(prob; max_iter=50)     constructing UnitarySmoothPulseProblem...\n\tusing integrator: typeof(UnitaryIntegrator)\n\tcontrol derivative names: [:da, :dda]\n\tapplying timesteps_all_equal constraint: Δt\n    initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt\n\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************\n\nThis is Ipopt version 3.14.17, running with linear solver MUMPS 5.8.0.\n\nNumber of nonzeros in equality constraint Jacobian...:   130578\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:    11223\n\nTotal number of variables............................:     2796\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:      246\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     2695\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  6.3299435e-04 9.98e-01 1.21e+01   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.7461331e+01 4.87e-01 3.66e+03  -0.6 1.02e+00   2.0 6.32e-01 5.00e-01h  2\n   2  1.1690187e+01 1.94e-01 6.11e+03   0.0 9.75e-01   2.4 1.00e+00 6.00e-01h  1\n   3  1.0956380e+00 1.36e-01 4.05e+03  -0.3 6.45e-01   2.9 1.00e+00 3.00e-01f  1\n   4  3.9110348e+00 1.13e-01 3.98e+03  -1.0 5.07e-01   3.3 1.00e+00 1.68e-01h  1\n   5  1.8650893e+01 4.46e-02 4.75e+03  -1.4 4.88e-01   2.8 1.00e+00 6.04e-01h  1\n   6  2.1587340e+01 3.10e-02 3.39e+03  -2.5 1.91e-01   3.2 1.00e+00 3.05e-01h  1\n   7  2.3916251e+01 2.00e-02 2.39e+03  -3.6 1.32e-01   2.7 1.00e+00 3.54e-01h  1\n   8  2.5059257e+01 1.40e-02 1.70e+03  -3.5 9.07e-02   3.2 1.00e+00 2.99e-01h  1\n   9  2.7401103e+01 4.99e-04 9.84e+02  -4.0 6.26e-02   2.7 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10  2.6662020e+01 2.47e-05 8.42e+00  -1.9 1.25e-02   2.2 9.92e-01 1.00e+00f  1\n  11  2.4573360e+01 1.87e-04 1.95e+00  -3.1 3.51e-02   1.7 1.00e+00 1.00e+00f  1\n  12  1.9710930e+01 1.13e-03 1.57e+00  -3.5 8.47e-02   1.3 1.00e+00 1.00e+00f  1\n  13  1.3214702e+01 3.33e-03 2.21e+00  -2.8 1.36e-01   0.8 1.00e+00 1.00e+00f  1\n  14  8.9713575e+00 5.27e-03 3.39e+00  -2.4 1.44e-01   0.3 1.00e+00 1.00e+00f  1\n  15  5.6268437e+00 9.48e-02 1.50e+01  -1.1 2.43e+00  -0.2 6.20e-01 2.66e-01f  1\n  16  2.8332166e+00 8.38e-03 8.30e+00  -1.7 1.95e-01   0.3 9.97e-01 1.00e+00h  1\n  17  2.3173027e+00 1.07e-02 2.03e+02  -2.2 2.13e-01  -0.2 1.00e+00 1.00e+00h  1\n  18  3.5518904e+00 3.98e-03 1.95e+02  -1.9 1.73e-01   0.2 1.00e+00 1.00e+00h  1\n  19  2.8780348e+00 7.54e-05 1.50e+01  -3.3 2.12e-02   1.5 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20  2.8000721e+00 1.94e-05 1.26e-01  -4.0 1.09e-02   1.1 1.00e+00 1.00e+00h  1\n  21  2.4804159e+00 1.27e-04 1.66e-01  -4.0 2.97e-02   0.6 1.00e+00 1.00e+00f  1\n  22  1.6341968e+00 8.22e-04 1.25e+00  -4.0 7.05e-02   0.1 1.00e+00 1.00e+00f  1\n  23  1.6390439e+00 6.27e-05 1.40e-01  -4.0 2.16e-02   0.5 1.00e+00 1.00e+00h  1\n  24  8.8490886e-01 8.76e-04 1.83e+00  -4.0 5.89e-02   0.1 1.00e+00 1.00e+00f  1\n  25  1.0781093e+00 6.37e-05 9.24e-02  -4.0 2.09e-02   0.5 1.00e+00 1.00e+00h  1\n  26  1.0394450e+00 8.22e-06 6.02e-02  -4.0 7.43e-03   0.9 1.00e+00 1.00e+00h  1\n  27  9.1719824e-01 6.75e-05 1.43e-01  -4.0 2.07e-02   0.4 1.00e+00 1.00e+00f  1\n  28  8.8207275e-01 9.13e-06 5.61e-02  -4.0 7.78e-03   0.9 1.00e+00 1.00e+00h  1\n  29  7.6943296e-01 7.46e-05 1.76e-01  -4.0 2.16e-02   0.4 1.00e+00 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  30  7.3872292e-01 9.90e-06 5.17e-02  -4.0 8.08e-03   0.8 1.00e+00 1.00e+00h  1\n  31  6.3617857e-01 8.02e-05 2.02e-01  -4.0 2.24e-02   0.3 1.00e+00 1.00e+00f  1\n  32  6.1009072e-01 1.04e-05 4.71e-02  -4.0 8.27e-03   0.8 1.00e+00 1.00e+00h  1\n  33  5.1753483e-01 8.38e-05 2.35e-01  -4.0 2.28e-02   0.3 1.00e+00 1.00e+00f  1\n  34  4.9659870e-01 1.06e-05 4.21e-02  -4.0 8.31e-03   0.7 1.00e+00 1.00e+00h  1\n  35  4.1286956e-01 8.49e-05 2.86e-01  -4.0 2.30e-02   0.2 1.00e+00 1.00e+00f  1\n  36  3.9824804e-01 1.03e-05 3.92e-02  -4.0 8.19e-03   0.7 1.00e+00 1.00e+00h  1\n  37  3.1915370e-01 8.79e-05 3.87e-01  -4.0 2.28e-02   0.2 1.00e+00 1.00e+00f  1\n  38  3.1446190e-01 9.70e-06 3.30e-02  -4.0 7.88e-03   0.6 1.00e+00 1.00e+00h  1\n  39  2.1762752e-01 1.13e-04 6.66e-01  -4.0 2.31e-02   0.1 1.00e+00 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  40  2.4363453e-01 9.72e-06 2.96e-02  -4.0 7.55e-03   0.6 1.00e+00 1.00e+00h  1\n  41  2.1604015e-01 6.65e-04 1.88e+02  -4.0 4.17e-01   0.1 1.00e+00 1.61e-01h  1\n  42  3.6597306e-01 1.29e-04 1.88e+02  -2.7 7.52e-02  -0.4 1.00e+00 1.00e+00H  1\n  43  3.5647971e-01 1.17e-06 1.64e+00  -2.8 2.13e-03   1.8 1.00e+00 1.00e+00h  1\n  44  3.4753360e-01 1.58e-06 6.64e-02  -4.0 2.95e-03   1.4 1.00e+00 1.00e+00h  1\n  45  3.3045607e-01 3.45e-06 9.48e-02  -4.0 4.85e-03   0.9 1.00e+00 1.00e+00f  1\n  46  2.9815119e-01 2.50e-05 8.55e-02  -4.0 1.35e-02   0.4 1.00e+00 1.00e+00h  1\n  47  2.8948071e-01 3.32e-06 3.25e-02  -4.1 4.88e-03   0.8 1.00e+00 1.00e+00h  1\n  48  2.5998426e-01 2.55e-05 6.31e-02  -4.0 1.35e-02   0.3 1.00e+00 1.00e+00h  1\n  49  2.5126499e-01 3.58e-06 2.93e-02  -4.1 4.94e-03   0.8 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50  2.2337171e-01 2.87e-05 8.86e-02  -4.0 1.34e-02   0.3 1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 50\n\n                                   (scaled)                 (unscaled)\nObjective...............:   2.2337171204369502e-01    2.2337171204369502e-01\nDual infeasibility......:   8.8610846417012112e-02    8.8610846417012112e-02\nConstraint violation....:   2.8712906816774630e-05    2.8712906816774630e-05\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   1.0048178594190573e-04    1.0048178594190573e-04\nOverall NLP error.......:   8.8610846417012112e-02    8.8610846417012112e-02\n\n\nNumber of objective function evaluations             = 55\nNumber of objective gradient evaluations             = 51\nNumber of equality constraint evaluations            = 55\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 51\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 50\nTotal seconds in IPOPT                               = 457.401\n\nEXIT: Maximum Number of Iterations Exceeded. Let's look at the fidelity in the subspace fid = unitary_rollout_fidelity(prob.trajectory, sys; subspace=op.subspace)\nprintln(\"Fidelity: \", fid)\n@assert fid > 0.99 Fidelity: 0.997779151119143 and plot the result using the  plot_unitary_populations  function. plot_unitary_populations(prob.trajectory; fig_size=(900, 700))"},{"id":196,"pagetitle":"Multilevel Transmon","title":"Leakage suppresion","ref":"/QuantumCollocation/dev/generated/examples/multilevel_transmon/#Leakage-suppresion","content":" Leakage suppresion As can be seen from the above plot, there is a substantial amount of leakage into the higher levels during the evolution. To mitigate this, we have implemented a constraint to avoid populating the leakage levels, which should ideally drive those leakage populations down to zero. To implement this, pass  leakage_constraint=true  and set  leakage_constraint_value={value}  and  leakage_cost={value}  to the  PiccoloOptions  instance passed to the  UnitarySmoothPulseProblem  template. # create the a leakage suppression problem, initializing with the previous solution\n\nprob_leakage = UnitarySmoothPulseProblem(sys, op, T, Δt;\n    a_bound=a_bound,\n    a_guess=prob.trajectory.a[:, :],\n    piccolo_options=PiccoloOptions(\n        leakage_constraint=true,\n        leakage_constraint_value=1e-2,\n        leakage_cost=1e-2,\n    ),\n)\n\n# solve the problem\n\nsolve!(prob_leakage; max_iter=250)     constructing UnitarySmoothPulseProblem...\n\tusing integrator: typeof(UnitaryIntegrator)\n\tcontrol derivative names: [:da, :dda]\n\tapplying leakage suppression: Ũ⃗ < 0.01\n\tapplying timesteps_all_equal constraint: Δt\n    initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt\nThis is Ipopt version 3.14.17, running with linear solver MUMPS 5.8.0.\n\nNumber of nonzeros in equality constraint Jacobian...:   130578\nNumber of nonzeros in inequality constraint Jacobian.:    58800\nNumber of nonzeros in Lagrangian Hessian.............:   196198\n\nTotal number of variables............................:     2796\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:      246\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     2695\nTotal number of inequality constraints...............:     1200\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:     1200\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  2.2434810e-01 1.80e-01 2.30e-01   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  5.1360583e-01 1.65e-01 1.95e+02  -1.4 7.80e-01   0.0 3.96e-01 1.19e-01h  1\n   2  3.3978388e-01 1.50e-01 1.74e+02  -2.6 9.24e-01    -  1.15e-01 1.04e-01h  1\n   3  1.5298834e-01 1.41e-01 1.63e+02  -1.4 1.88e+00    -  1.06e-01 6.31e-02f  1\n   4  1.7494458e-01 1.29e-01 4.47e+01  -2.1 1.72e+00    -  9.03e-02 8.41e-02h  1\n   5  3.5467772e-01 1.24e-01 4.26e+01  -4.0 2.44e+00    -  3.22e-02 4.34e-02h  1\n   6  6.4298267e-01 1.18e-01 4.07e+01  -2.7 3.39e+00    -  5.09e-02 4.23e-02h  1\n   7  1.0024286e+00 1.14e-01 3.91e+01  -4.0 5.49e+00    -  1.37e-02 3.81e-02h  2\n   8  1.0670467e+00 1.14e-01 3.90e+01  -2.0 2.79e+01    -  1.34e-02 2.36e-03h  4\n   9  2.1279853e+00 1.06e-01 3.66e+01  -0.8 2.04e+00  -0.5 4.67e-02 6.21e-02f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10  2.9482553e+00 9.76e-02 3.39e+01  -1.5 2.87e+00    -  1.14e-01 7.71e-02h  1\n  11  3.6354733e+00 8.55e-02 2.98e+01  -1.6 3.21e+00    -  1.45e-01 1.27e-01h  1\n  12  3.9542845e+00 8.22e-02 3.53e+01  -3.2 1.25e+00  -1.0 1.51e-01 3.99e-02h  1\n  13  4.6058365e+00 7.25e-02 2.53e+01  -2.9 2.91e+00  -1.4 7.32e-02 1.23e-01h  1\n  14  4.4192139e+00 7.13e-02 2.48e+01  -4.0 2.34e+01  -1.9 1.58e-02 1.65e-02h  1\n  15  4.4716125e+00 7.06e-02 2.92e+01  -1.6 1.25e+01  -1.5 4.57e-02 9.32e-03h  2\n  16  5.2029137e+00 6.41e-02 2.31e+01  -4.0 1.27e+00  -1.1 4.50e-02 9.55e-02h  1\n  17  5.8079662e+00 5.89e-02 2.10e+01  -2.3 4.45e+00  -1.5 6.89e-02 8.31e-02h  1\n  18  6.0649488e+00 5.68e-02 2.00e+01  -4.0 1.51e+00  -1.1 7.23e-02 3.56e-02h  1\n  19  6.1470389e+00 5.50e-02 1.94e+01  -1.9 1.01e+01  -1.6 3.33e-02 3.11e-02f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20  7.3900832e+00 4.73e-02 9.26e+01  -1.5 2.16e+00  -1.2 8.51e-03 1.41e-01h  1\n  21  7.3175121e+00 4.64e-02 9.28e+01  -4.0 7.91e+00  -1.6 3.53e-02 1.89e-02h  1\n  22  7.2518493e+00 4.47e-02 8.74e+01  -2.4 2.67e+00  -1.2 5.36e-02 3.74e-02f  1\n  23  7.4999270e+00 4.22e-02 8.11e+01  -4.0 2.69e+00  -1.7 1.01e-01 5.58e-02h  1\n  24  9.3286084e+00 3.55e-02 6.99e+01  -1.2 3.01e+00  -1.3 5.23e-02 1.51e-01f  1\n  25  9.2556249e+00 3.47e-02 7.09e+01  -1.6 1.19e+01  -1.7 3.77e-02 2.28e-02h  2\n  26  1.0820117e+01 2.59e-02 6.61e+01  -1.6 1.64e+00  -1.3 1.64e-01 2.65e-01h  1\n  27  1.1406085e+01 2.23e-02 5.64e+01  -2.4 7.21e-01  -0.9 2.58e-01 1.44e-01h  1\n  28  1.1873495e+01 1.98e-02 4.85e+01  -2.8 1.25e+00  -1.4 2.25e-01 1.40e-01h  1\n  29  1.2962332e+01 1.60e-02 4.00e+01  -1.9 5.99e-01  -0.9 4.93e-01 1.93e-01h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  30  1.3655030e+01 1.29e-02 2.97e+01  -3.5 1.14e+00  -1.4 3.82e-01 2.48e-01h  1\n  31  1.4246526e+01 1.02e-02 4.19e+01  -3.1 7.10e-01  -1.0 5.61e-01 2.10e-01h  1\n  32  1.4273160e+01 1.03e-02 3.94e+01  -4.0 2.86e+00  -1.5 9.80e-02 7.56e-02h  1\n  33  1.6584320e+01 9.17e-03 4.71e+01  -1.6 9.30e-01  -1.0 3.37e-01 4.96e-01h  1\n  34  1.6353390e+01 9.01e-03 3.80e+01  -4.0 1.16e+00  -1.5 3.17e-01 1.81e-01h  1\n  35  1.7121024e+01 1.11e-02 2.29e+01  -1.8 8.51e-01  -1.1 5.44e-01 4.72e-01h  1\n  36  1.7000596e+01 1.03e-02 2.89e+01  -2.1 1.52e+00  -1.6 4.17e-01 1.66e-01h  1\n  37  1.7009235e+01 1.13e-02 8.85e+00  -2.2 5.82e-01  -1.1 1.00e+00 7.66e-01h  1\n  38  1.6715807e+01 1.14e-02 8.39e+00  -4.0 4.85e+00  -1.6 8.01e-02 7.52e-02f  1\n  39  1.6583232e+01 1.31e-02 2.10e+01  -2.0 1.08e+00  -1.2 5.96e-01 2.87e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  40  1.6387643e+01 1.43e-02 1.96e+01  -4.0 5.65e+00  -1.7 2.87e-02 3.86e-02f  1\n  41  1.6176015e+01 1.19e-02 2.87e+01  -2.4 6.66e-01  -1.2 5.17e-01 2.27e-01h  1\n  42  1.5766440e+01 4.69e-03 9.78e+00  -2.8 2.38e-01  -0.8 1.00e+00 6.89e-01h  1\n  43  1.5502061e+01 5.75e-03 7.89e+00  -4.0 1.50e+00  -1.3 1.27e-01 2.65e-01h  1\n  44  1.5464772e+01 5.67e-03 6.62e+00  -3.6 4.26e+00  -1.8 5.48e-02 1.95e-02h  1\n  45  1.5363978e+01 4.82e-03 2.08e+01  -3.7 9.38e-01  -1.3 4.76e-01 1.70e-01h  1\n  46  1.5272266e+01 7.92e-03 2.18e+01  -2.5 4.89e+00  -1.8 1.16e-01 9.52e-02f  1\n  47  1.5200604e+01 6.91e-03 1.79e+01  -4.0 5.59e-01  -1.4 1.63e-01 1.67e-01h  1\n  48  1.5101997e+01 3.17e-03 9.84e+00  -3.3 1.68e-01  -1.0 1.00e+00 5.43e-01h  1\n  49  1.5130170e+01 3.73e-03 6.11e+00  -2.4 1.19e+00  -1.4 2.86e-01 3.25e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50  1.4961266e+01 2.34e-03 2.16e-01  -3.0 2.32e-01  -1.0 1.00e+00 1.00e+00h  1\n  51  1.4901420e+01 3.82e-03 2.50e+00  -4.0 2.05e+01  -1.5 1.78e-02 2.70e-02f  1\n  52  1.4820033e+01 3.34e-03 1.34e+01  -3.2 5.63e-01  -1.1 4.46e-01 2.65e-01h  1\n  53  1.4695331e+01 1.04e-03 2.87e+00  -3.2 1.98e-01  -0.6 1.00e+00 8.87e-01h  1\n  54  1.4710827e+01 1.40e-03 2.75e+01  -2.1 1.22e+00  -1.1 2.90e-01 1.37e-01f  1\n  55  1.4638807e+01 1.31e-03 3.05e-01  -2.7 2.01e-01  -0.7 9.87e-01 9.76e-01h  1\n  56  1.4546595e+01 1.63e-03 2.35e+01  -2.8 5.84e-01  -1.2 6.52e-01 2.55e-01f  1\n  57  1.4388272e+01 1.11e-03 1.58e-01  -2.9 1.74e-01  -0.8 1.00e+00 1.00e+00h  1\n  58  1.4242355e+01 2.38e-03 2.04e-01  -2.9 8.04e-01  -1.2 3.22e-01 3.28e-01h  1\n  59  1.4172905e+01 1.83e-03 2.73e+01  -3.5 2.43e-01  -0.8 1.00e+00 2.68e-01h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  60  1.4055939e+01 1.07e-02 1.53e+01  -2.5 8.02e-01  -1.3 1.00e+00 7.28e-01f  1\n  61  1.4044108e+01 2.44e-02 1.78e+01  -2.0 2.89e+00  -1.8 1.31e-01 2.47e-01f  1\n  62  1.3933915e+01 2.05e-02 1.14e+01  -2.0 1.45e+00  -1.3 4.07e-01 3.32e-01f  1\n  63  1.3615248e+01 1.21e-02 1.50e+01  -3.3 3.10e-01  -0.9 7.46e-01 4.31e-01h  1\n  64  1.3465368e+01 1.15e-02 1.38e+01  -3.0 2.73e+00  -1.4 1.49e-01 1.03e-01h  1\n  65  1.3260366e+01 6.18e-03 3.14e+00  -2.4 4.62e-01  -1.0 9.12e-01 1.00e+00f  1\n  66  1.3217326e+01 6.81e-03 3.67e+00  -1.8 3.54e+00  -1.4 1.37e-01 1.02e-01f  1\n  67  1.3299395e+01 8.59e-03 8.89e+00  -1.7 3.42e+00  -1.9 2.32e-01 1.87e-01f  1\n  68  1.3098262e+01 1.42e-02 7.76e+00  -2.2 1.32e+01  -2.4 1.59e-02 3.97e-02f  1\n  69  1.3780887e+01 1.23e-02 2.33e+01  -1.2 2.40e+00  -2.0 2.07e-01 1.33e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  70  1.3452914e+01 4.12e-02 2.98e+01  -1.8 6.63e+00    -  4.61e-02 1.23e-01f  1\n  71  1.3203138e+01 3.51e-02 3.14e+01  -1.8 1.75e+00  -1.5 1.71e-01 2.66e-01f  1\n  72  1.3005919e+01 9.25e-03 7.47e+00  -1.8 4.24e-01  -1.1 1.00e+00 7.88e-01h  1\n  73  1.2840830e+01 1.10e-02 1.59e+01  -4.0 4.11e+01    -  1.41e-02 6.36e-03f  1\n  74  1.4063072e+01 5.81e-02 9.13e+00  -1.3 2.18e+00  -1.6 4.67e-01 4.45e-01f  1\n  75  1.2905266e+01 1.79e-02 2.25e+00  -1.6 8.13e-01  -1.2 1.00e+00 1.00e+00f  1\n  76  1.2495253e+01 1.78e-02 9.59e+00  -1.6 3.37e+00    -  2.29e-01 1.51e-01f  1\n  77  1.1698663e+01 1.56e-02 3.54e+01  -2.0 9.73e-01  -1.6 8.85e-01 4.41e-01f  1\n  78  1.0745079e+01 8.08e-03 5.32e+00  -2.1 4.59e-01  -1.2 1.00e+00 8.09e-01h  1\n  79  1.0470890e+01 1.31e-02 4.04e+00  -2.4 1.69e+00  -1.7 2.34e-01 2.40e-01h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  80  1.0359829e+01 2.79e-02 1.04e+01  -1.9 1.07e+00  -1.3 1.00e+00 5.13e-01f  1\n  81  9.9471423e+00 3.19e-02 1.08e+01  -2.4 1.95e+00  -1.7 1.90e-01 1.63e-01h  1\n  82  9.6175434e+00 2.17e-02 1.16e+01  -2.4 9.15e-01  -1.3 4.81e-01 3.43e-01h  1\n  83  9.3639825e+00 1.94e-02 1.58e+01  -2.3 3.99e+00  -1.8 1.46e-01 9.89e-02h  1\n  84  9.2283067e+00 1.80e-02 9.57e+00  -4.0 1.57e+01  -2.3 1.44e-02 2.71e-02h  1\n  85  9.0613062e+00 3.94e-03 5.28e-01  -2.2 2.39e-01  -0.9 1.00e+00 1.00e+00h  1\n  86  9.2253653e+00 1.88e-02 4.18e+00  -2.0 5.04e-01  -1.4 8.46e-01 1.00e+00f  1\n  87  9.0268998e+00 2.41e-02 4.69e+00  -2.1 7.11e+00  -1.9 6.14e-02 5.36e-02h  1\n  88  8.6275632e+00 2.21e-02 1.02e+01  -4.0 9.11e-01  -1.5 4.55e-01 2.59e-01h  1\n  89  8.5260991e+00 3.10e-02 1.16e+01  -1.7 5.87e+00  -1.9 7.65e-02 1.31e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  90  8.3488203e+00 3.06e-02 9.13e+00  -1.9 1.48e+00  -1.5 4.29e-01 3.31e-01f  1\n  91  8.1810916e+00 2.95e-02 8.59e+00  -4.0 3.58e+00  -2.0 6.30e-02 7.11e-02h  1\n  92  8.0188750e+00 2.75e-02 5.42e+00  -2.1 1.62e+00  -1.6 3.78e-01 3.68e-01f  1\n  93  7.4577245e+00 9.96e-03 5.39e-01  -2.4 3.50e-01  -1.1 9.51e-01 9.73e-01h  1\n  94  7.2737975e+00 1.42e-02 4.18e-01  -2.6 1.53e+00  -1.6 2.24e-01 2.24e-01h  1\n  95  7.2063198e+00 1.53e-02 2.54e+01  -1.7 9.17e+01  -2.1 1.01e-02 2.36e-03f  1\n  96  7.2412085e+00 1.21e-02 1.93e+01  -2.1 1.10e+00  -1.7 2.76e-01 1.93e-01f  1\n  97  7.0026225e+00 5.15e-03 3.48e+00  -2.5 2.77e-01  -1.2 1.00e+00 8.68e-01h  1\n  98  7.1189860e+00 4.56e-02 5.52e+00  -1.7 3.37e+00  -1.7 2.85e-01 2.33e-01f  1\n  99  6.9630233e+00 4.38e-02 7.74e+00  -2.2 6.67e+00  -2.2 5.20e-02 4.18e-02h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 100  6.7431755e+00 3.53e-02 1.88e+01  -2.6 1.25e+00  -1.8 2.99e-01 1.92e-01h  1\n 101  6.4648467e+00 9.10e-03 2.08e+00  -2.3 4.37e-01  -1.3 8.78e-01 8.97e-01h  1\n 102  6.4457630e+00 2.49e-02 2.11e+00  -2.1 1.50e+00  -1.8 3.43e-01 3.27e-01f  1\n 103  6.3123507e+00 3.23e-02 2.03e+00  -4.0 1.79e+01  -2.3 1.43e-02 1.53e-02f  1\n 104  6.2464306e+00 2.91e-02 2.47e+01  -2.5 9.86e-01  -1.9 3.63e-01 9.73e-02f  1\n 105  6.0788120e+00 1.46e-02 1.20e+01  -2.4 5.63e-01  -1.4 1.00e+00 4.96e-01h  1\n 106  5.8880884e+00 1.45e-02 6.26e+00  -4.0 1.68e+00  -1.9 1.38e-01 2.16e-01h  1\n 107  6.0767328e+00 1.84e-02 4.66e+00  -1.9 1.18e+00  -1.5 4.61e-01 3.99e-01f  1\n 108  5.8326608e+00 5.23e-03 6.27e-01  -2.2 3.36e-01  -1.1 1.00e+00 1.00e+00h  1\n 109  5.3388134e+00 2.69e-02 6.02e-01  -2.8 1.10e+00  -1.6 5.51e-01 5.19e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 110  5.2148964e+00 2.02e-02 1.25e+01  -2.9 3.75e-01  -1.1 8.46e-01 2.82e-01h  1\n 111  5.0192896e+00 2.00e-02 1.21e+01  -3.0 1.10e+00  -1.6 3.14e-01 2.58e-01h  1\n 112  5.1541815e+00 5.72e-03 4.03e+00  -2.2 3.54e-01  -1.2 7.04e-01 7.34e-01f  1\n 113  5.0029938e+00 1.51e-02 1.02e+01  -4.0 1.27e+01    -  1.06e-02 2.67e-02f  1\n 114  4.9696001e+00 1.48e-02 7.18e+00  -4.0 4.11e+00    -  6.28e-02 2.03e-02h  1\n 115  4.9658473e+00 1.08e-02 1.83e+01  -2.1 1.01e+00  -1.7 5.52e-01 2.68e-01f  1\n 116  4.7380721e+00 4.71e-02 1.26e+01  -4.0 5.02e+00  -2.1 4.11e-02 1.76e-01h  1\n 117  4.6109574e+00 3.50e-02 7.98e+00  -2.5 1.02e+00  -1.7 4.28e-01 2.54e-01h  1\n 118  4.2469478e+00 5.91e-03 3.83e-01  -2.8 3.23e-01  -1.3 1.00e+00 1.00e+00h  1\n 119  4.1613474e+00 7.53e-03 7.05e+00  -2.8 1.18e+00  -1.8 4.39e-01 2.22e-01h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 120  4.1656938e+00 6.97e-03 8.65e+00  -2.0 2.80e+00  -2.2 1.01e-01 6.36e-02f  1\n 121  4.0987005e+00 5.69e-03 6.36e+00  -2.7 8.42e-01  -1.8 2.68e-01 2.53e-01h  1\n 122  4.0647900e+00 4.41e-03 9.30e+00  -2.7 2.72e-01  -1.4 9.73e-01 3.93e-01h  1\n 123  3.8982308e+00 7.11e-04 1.12e-01  -3.4 8.47e-02  -1.0 1.00e+00 1.00e+00h  1\n 124  4.0882464e+00 1.20e-02 7.22e+00  -2.4 5.90e-01  -1.4 4.64e-01 7.89e-01f  1\n 125  4.0163103e+00 7.31e-03 1.45e+01  -2.8 1.26e-01  -1.0 7.76e-01 3.87e-01h  1\n 126  3.8891402e+00 1.21e-02 9.03e+00  -2.8 1.09e+00  -1.5 3.84e-01 3.47e-01f  1\n 127  3.8642572e+00 6.11e-03 5.27e+00  -2.5 2.00e-01  -1.1 1.00e+00 5.61e-01f  1\n 128  3.9622154e+00 9.47e-03 8.49e+00  -2.1 5.40e-01  -1.5 1.00e+00 5.67e-01f  1\n 129  3.8882506e+00 1.71e-02 7.96e+00  -2.2 8.29e+00    -  6.85e-02 6.76e-02h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 130  3.7952046e+00 2.10e-02 6.52e+00  -2.2 2.04e+00  -2.0 1.61e-01 1.66e-01f  1\n 131  3.6709818e+00 1.58e-02 5.59e+00  -2.2 7.10e-01  -1.6 1.00e+00 7.54e-01f  1\n 132  3.5684130e+00 2.17e-02 5.56e+00  -2.3 8.33e+00  -2.1 5.40e-02 3.80e-02h  1\n 133  3.6915863e+00 2.65e-02 2.49e+00  -2.0 8.09e-01  -1.6 5.85e-01 6.03e-01f  1\n 134  3.5313636e+00 2.51e-02 5.26e+00  -2.1 2.45e+00  -2.1 1.77e-01 2.15e-01h  1\n 135  3.1036174e+00 2.88e-02 2.77e+00  -2.5 1.18e+00  -1.7 5.19e-01 4.98e-01h  1\n 136  3.0760896e+00 2.82e-02 1.87e+01  -4.0 5.16e+00    -  8.28e-02 2.04e-02h  1\n 137  2.8415770e+00 6.44e-03 3.24e+00  -2.6 3.48e-01  -1.3 1.00e+00 8.35e-01h  1\n 138  2.8400769e+00 1.44e-02 2.83e+00  -2.3 8.20e-01  -1.7 5.43e-01 5.05e-01f  1\n 139  2.7949017e+00 3.97e-02 3.54e+00  -2.0 2.80e+00  -2.2 2.88e-01 2.19e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 140  2.7304637e+00 3.60e-02 1.07e+01  -3.8 1.41e+00    -  2.13e-01 9.22e-02h  1\n 141  2.8805768e+00 4.66e-02 8.96e+00  -2.1 9.94e-01  -1.8 5.54e-01 1.00e+00f  1\n 142  2.6585759e+00 1.88e-02 6.14e+00  -2.3 5.15e-01  -1.4 1.00e+00 6.33e-01h  1\n 143  3.3455577e+00 5.42e-02 1.17e+01  -1.7 1.29e+00  -1.8 4.21e-01 6.97e-01f  1\n 144  3.0767662e+00 6.73e-02 1.14e+01  -2.0 1.95e+01  -2.3 5.11e-02 3.33e-02h  1\n 145  2.7528424e+00 4.85e-02 7.33e+00  -2.0 1.82e+00  -1.9 2.75e-01 3.24e-01h  1\n 146  2.5427397e+00 5.94e-02 6.15e+00  -2.0 9.09e+00  -2.4 7.22e-02 1.04e-01h  1\n 147  2.2370102e+00 4.16e-02 4.19e+00  -2.5 1.67e+00  -1.9 3.38e-01 3.21e-01h  1\n 148  2.6385292e+00 4.86e-02 7.10e-01  -1.8 8.76e-01  -1.5 1.00e+00 1.00e+00f  1\n 149  2.2018396e+00 7.09e-02 1.45e+00  -4.0 6.07e+00    -  1.71e-01 1.67e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 150  1.7615556e+00 5.90e-02 5.46e+00  -3.2 1.91e+00  -2.0 5.25e-01 3.25e-01h  1\n 151  3.1307050e+00 5.11e-02 6.87e+00  -1.5 9.24e-01  -1.6 7.18e-01 8.65e-01f  1\n 152  2.4006929e+00 3.05e-02 5.13e+00  -1.7 1.32e+00  -2.0 9.74e-01 7.78e-01h  1\n 153  3.4908891e+00 4.43e-02 9.75e-01  -1.4 8.97e-01  -1.6 1.00e+00 1.00e+00f  1\n 154  2.6996582e+00 1.96e-01 1.15e+01  -1.5 7.30e+00    -  3.08e-01 3.79e-01h  1\n 155  2.7697532e+00 1.08e-01 8.09e+00  -1.5 1.25e+00  -2.1 1.00e+00 5.00e-01h  2\n 156  2.5738993e+00 8.54e-02 8.98e+00  -1.5 6.47e+00  -2.6 4.14e-01 2.08e-01h  1\n 157  2.4062377e+00 2.08e-01 1.62e+00  -1.5 2.60e+00  -2.1 1.00e+00 1.00e+00f  1\n 158  1.9647763e+00 2.80e-01 8.33e+00  -1.5 1.59e+01  -2.6 1.70e-01 1.84e-01h  1\n 159  2.1442814e+00 5.56e-02 7.08e+00  -1.5 1.46e+00  -1.3 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 160  2.2489535e+00 2.34e-02 2.96e+00  -1.5 1.01e+00    -  1.00e+00 1.00e+00h  1\n 161  1.5484583e+00 1.21e-01 4.58e+00  -4.0 1.10e+01    -  1.77e-01 2.11e-01f  1\n 162  1.4466123e+00 2.36e-02 1.18e+00  -1.7 1.37e+00  -1.8 1.00e+00 1.00e+00h  1\n 163  8.6378982e-01 1.72e-02 9.39e-01  -2.0 8.89e-01    -  9.95e-01 1.00e+00h  1\n 164  6.7298093e-01 8.70e-02 2.17e+00  -4.0 1.76e+01    -  7.12e-02 8.63e-02h  1\n 165  6.9834815e-01 5.69e-02 6.63e-01  -2.0 1.37e+00  -2.3 9.13e-01 1.00e+00h  1\n 166  4.8850197e-01 6.66e-02 7.89e-01  -4.0 2.47e+00    -  3.13e-01 3.02e-01h  1\n 167  3.7116047e-01 8.13e-02 1.38e+00  -2.9 3.71e+00  -2.7 2.92e-01 2.39e-01h  1\n 168  2.6880903e-01 3.97e-02 3.47e+00  -2.6 1.16e+00  -2.3 1.00e+00 5.60e-01h  1\n 169  9.1763010e-02 5.94e-03 1.98e-01  -3.1 3.64e-01  -1.9 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 170  1.0082789e-01 4.50e-03 1.24e+00  -2.8 4.22e-01  -2.4 1.00e+00 2.50e-01h  3\n 171  8.5138450e-02 1.43e-02 6.57e-01  -3.0 6.20e-01  -2.8 1.00e+00 7.65e-01h  1\n 172  5.9392940e-02 2.88e-02 1.40e+00  -4.0 3.03e+00    -  1.10e-01 2.31e-01h  1\n 173  4.7476179e-02 1.71e-02 8.39e-01  -3.3 5.71e-01  -2.4 9.12e-01 6.84e-01h  1\n 174  4.7124067e-02 1.40e-02 1.22e+00  -3.0 1.39e+00  -2.9 2.36e-01 1.87e-01h  1\n 175  2.9474316e-02 7.79e-02 9.57e-01  -3.4 2.45e+00  -3.4 1.87e-01 3.38e-01h  1\n 176  2.4908553e-02 7.01e-02 8.19e-01  -4.0 3.34e+00    -  1.02e-01 8.95e-02h  1\n 177  1.0484464e-02 2.01e-02 1.99e+02  -4.0 6.13e-01  -2.9 4.94e-01 9.43e-01h  1\n 178  1.3256443e-02 1.69e-02 3.82e+01  -4.0 1.32e+00    -  1.13e-01 1.93e-01h  1\n 179  9.9204934e-03 9.84e-04 5.64e+00  -3.5 6.33e-02  -1.6 9.34e-01 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 180  6.0344733e-03 1.44e-04 6.56e-02  -4.0 4.02e-02  -2.1 1.00e+00 1.00e+00h  1\n 181  6.1998405e-03 1.44e-04 2.07e-01  -4.0 1.16e-01  -2.6 1.00e+00 1.25e-01h  4\n 182  5.4637353e-03 3.86e-03 1.76e-01  -4.0 9.15e-01  -3.0 2.58e-01 2.33e-01h  2\n 183  4.3107781e-03 1.67e-02 1.99e+02  -4.0 1.91e+01    -  1.09e-02 2.38e-02h  1\n 184  9.4764188e-03 1.67e-02 2.18e+01  -4.0 1.44e+00    -  1.25e-01 1.10e-01h  1\n 185  4.9603370e-03 1.29e-02 1.68e+01  -4.1 3.36e-01  -2.6 6.89e-01 2.29e-01h  1\n 186  4.6286083e-03 1.30e-03 1.98e+02  -4.0 8.80e-02  -2.2 1.00e+00 1.00e+00h  1\n 187  9.2890850e-03 2.61e-03 1.99e+02  -3.7 2.47e-01  -2.7 1.00e+00 1.00e+00h  1\n 188  1.2524551e-02 1.28e-06 1.14e+00  -3.8 6.00e-03   2.3 1.00e+00 1.00e+00h  1\n 189  1.1490307e-02 9.56e-08 4.89e-02  -4.0 7.68e-04   1.8 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 190  9.9449741e-03 4.17e-07 2.61e-02  -4.0 1.23e-03   1.3 1.00e+00 1.00e+00h  1\n 191  8.5106712e-03 9.44e-07 1.24e-02  -4.0 1.75e-03   0.8 1.00e+00 1.00e+00h  1\n 192  7.1234938e-03 9.67e-07 9.94e-03  -4.0 2.14e-03   0.4 1.00e+00 1.00e+00h  1\n 193  6.2267266e-03 9.54e-07 7.86e-03  -4.0 2.02e-03  -0.1 1.00e+00 1.00e+00h  1\n 194  5.9417411e-03 1.36e-06 2.10e-03  -4.0 3.54e-03  -0.6 1.00e+00 1.00e+00h  1\n 195  5.8182547e-03 5.98e-06 5.52e-03  -4.0 1.17e-02  -1.1 1.00e+00 1.00e+00h  1\n 196  5.6639464e-03 3.28e-05 1.36e-02  -4.0 2.72e-02  -1.5 1.00e+00 1.00e+00h  1\n 197  5.4774368e-03 1.48e-04 1.86e-02  -4.0 4.66e-02  -2.0 1.00e+00 1.00e+00h  1\n 198  5.2580864e-03 6.70e-04 2.07e-02  -4.0 6.43e-02  -2.5 1.00e+00 1.00e+00h  1\n 199  4.8541139e-03 2.95e-03 3.61e-02  -4.0 1.82e-01  -3.0 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 200  3.5736593e-03 1.51e-02 1.27e-01  -4.1 4.72e-01  -3.4 1.00e+00 1.00e+00h  1\n 201  3.6256964e-03 2.07e-02 1.31e-01  -4.0 1.04e+00  -3.9 4.45e-01 7.42e-01h  1\n 202  2.7992730e-03 8.37e-04 2.20e-02  -4.2 2.86e-01  -2.6 1.00e+00 1.00e+00h  1\n 203  3.1256048e-03 1.40e-04 4.48e-02  -4.0 4.13e-02  -2.2 1.00e+00 1.00e+00h  1\n 204  3.0974848e-03 5.13e-04 3.89e-02  -4.0 5.95e-02  -2.6 1.00e+00 1.00e+00h  1\n 205  3.2042137e-03 1.33e-04 2.87e-02  -4.0 3.34e-02  -2.2 1.00e+00 1.00e+00h  1\n 206  3.1928337e-03 2.22e-04 9.79e-03  -4.0 6.51e-02  -2.7 1.00e+00 1.00e+00h  1\n 207  2.9865357e-03 3.34e-05 5.60e-03  -4.1 2.07e-02  -2.3 1.00e+00 1.00e+00h  1\n 208  2.7112709e-03 1.47e-03 1.99e+02  -4.0 1.21e-01  -2.7 1.00e+00 1.00e+00h  1\n 209  2.5885455e-03 9.04e-03 3.87e+01  -4.0 2.56e+00    -  2.66e-01 1.95e-01h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 210  4.3462817e-03 1.52e-03 1.99e+02  -4.0 1.22e-01  -1.4 1.00e+00 1.00e+00h  1\n 211  3.0330185e-03 1.01e-03 1.32e+02  -4.1 9.04e-02  -1.9 4.50e-01 3.37e-01h  1\n 212  5.3802479e-03 4.89e-05 1.99e+02  -4.1 1.16e-02  -0.6 7.36e-01 1.00e+00h  1\n 213  2.4987815e-03 1.01e-05 6.49e+00  -4.1 4.87e-03   1.7 1.00e+00 1.00e+00h  1\n 214  4.2645033e-03 4.97e-07 1.84e-02  -4.0 1.19e-03   1.2 1.00e+00 1.00e+00h  1\n 215  3.5311606e-03 6.27e-07 1.54e-02  -4.0 1.56e-03   0.7 1.00e+00 1.00e+00h  1\n 216  3.0608754e-03 5.76e-07 1.06e-02  -4.0 1.56e-03   0.2 1.00e+00 1.00e+00h  1\n 217  2.8310981e-03 1.42e-06 1.01e-02  -4.0 1.84e-03  -0.2 1.00e+00 1.00e+00h  1\n 218  2.7512207e-03 2.44e-06 8.82e-03  -4.0 2.34e-03  -0.7 1.00e+00 1.00e+00h  1\n 219  2.5687894e-03 3.45e-06 3.51e-03  -4.1 4.24e-03  -1.2 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 220  2.5267716e-03 1.15e-05 6.07e-03  -4.1 9.57e-03  -1.7 1.00e+00 1.00e+00h  1\n 221  2.4379760e-03 4.54e-05 6.63e-03  -4.1 1.50e-02  -2.2 1.00e+00 1.00e+00h  1\n 222  2.4856677e-03 5.19e-04 2.10e-02  -4.0 4.60e-02  -2.6 1.00e+00 1.00e+00h  1\n 223  2.3674794e-03 2.65e-05 3.16e-03  -4.1 1.47e-02  -2.2 1.00e+00 1.00e+00h  1\n 224  2.2052633e-03 1.14e-03 1.99e+02  -4.0 1.03e-01  -2.7 1.00e+00 1.00e+00h  1\n 225  2.3357578e-03 2.57e-02 6.12e+01  -4.0 2.86e+00    -  2.56e-01 3.08e-01h  1\n 226  6.5569191e-03 5.10e-03 1.89e+02  -4.1 3.49e-01  -0.4 9.32e-01 8.39e-01h  1\n 227  4.3892409e-03 1.42e-04 1.99e+02  -4.1 6.32e-02  -0.9 1.00e+00 1.00e+00h  1\n 228  3.9615816e-03 2.30e-07 1.06e+00  -4.1 8.32e-04   2.2 1.00e+00 1.00e+00h  1\n 229  2.9060756e-03 5.29e-07 7.18e-02  -4.0 1.32e-03   1.7 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 230  1.8410384e-03 1.08e-06 3.59e-02  -4.0 1.99e-03   1.3 1.00e+00 1.00e+00h  1\n 231  1.8259199e-03 6.81e-07 9.85e-03  -4.0 1.63e-03   0.8 1.00e+00 1.00e+00h  1\n 232  2.1043589e-03 1.11e-07 8.39e-03  -4.0 9.29e-04   0.3 1.00e+00 1.00e+00h  1\n 233  2.1748298e-03 3.43e-07 5.09e-03  -4.0 2.23e-03  -0.2 1.00e+00 1.00e+00h  1\n 234  2.0951438e-03 1.04e-06 7.79e-03  -4.1 4.42e-03  -0.7 1.00e+00 1.00e+00h  1\n 235  2.0489546e-03 3.95e-06 9.75e-03  -4.1 1.01e-02  -1.1 1.00e+00 1.00e+00h  1\n 236  2.0018203e-03 5.95e-06 8.51e-03  -4.1 1.10e-02  -1.6 1.00e+00 1.00e+00h  1\n 237  1.9592311e-03 2.04e-05 5.82e-03  -4.1 1.38e-02  -2.1 1.00e+00 1.00e+00h  1\n 238  1.7434305e-03 2.61e-04 3.84e-02  -4.1 5.48e-02  -2.6 1.00e+00 1.00e+00h  1\n 239  1.7391552e-03 1.14e-04 1.99e+02  -4.0 5.11e-02  -2.1 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 240  2.4532545e-03 5.68e-02 8.96e+01  -4.0 3.22e+00    -  3.23e-01 4.51e-01h  1\n 241  5.0397693e-03 4.23e-02 1.33e+02  -4.1 7.40e-01   1.0 3.73e-02 2.67e-01h  1\n 242  2.8319527e-03 2.92e-02 9.17e+01  -4.1 6.05e-01   0.5 3.66e-01 3.10e-01h  1\n 243  1.6347319e-02 8.84e-03 1.70e+02  -4.1 4.57e-01   0.0 2.17e-01 6.92e-01h  1\n 244  2.0933722e-02 7.13e-03 1.37e+02  -4.1 1.26e-01   2.3 1.00e+00 1.93e-01h  1\n 245  3.1769505e-02 9.19e-04 1.75e+01  -4.1 1.03e-01   1.8 1.00e+00 8.73e-01h  1\n 246  1.6950756e-02 1.50e-05 1.91e+00  -4.1 1.42e-02   1.3 1.00e+00 1.00e+00f  1\n 247  2.5160207e-03 9.57e-06 1.99e+02  -4.1 6.54e-03   0.8 1.00e+00 1.00e+00h  1\n 248  1.2708361e-02 8.31e-06 1.99e+02  -4.1 5.35e-03   0.4 1.00e+00 1.00e+00h  1\n 249  1.0363521e-02 8.56e-07 1.65e+00  -4.1 2.22e-03   1.7 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 250  6.1557406e-03 2.65e-06 4.70e-02  -4.1 2.81e-03   1.2 1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 250\n\n                                   (scaled)                 (unscaled)\nObjective...............:   6.1557406030901948e-03    6.1557406030901948e-03\nDual infeasibility......:   4.7045423606571178e-02    4.7045423606571178e-02\nConstraint violation....:   2.6513034000474889e-06    2.6513034000474889e-06\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   7.9271489062693738e-05    7.9271489062693738e-05\nOverall NLP error.......:   4.7045423606571178e-02    4.7045423606571178e-02\n\n\nNumber of objective function evaluations             = 275\nNumber of objective gradient evaluations             = 251\nNumber of equality constraint evaluations            = 275\nNumber of inequality constraint evaluations          = 275\nNumber of equality constraint Jacobian evaluations   = 251\nNumber of inequality constraint Jacobian evaluations = 251\nNumber of Lagrangian Hessian evaluations             = 250\nTotal seconds in IPOPT                               = 2373.981\n\nEXIT: Maximum Number of Iterations Exceeded. Let's look at the fidelity in the subspace fid_leakage = unitary_rollout_fidelity(prob_leakage.trajectory, sys; subspace=op.subspace)\nprintln(\"Fidelity: \", fid_leakage)\n@assert fid_leakage > 0.99 Fidelity: 0.9999429222580105 and plot the result using the  plot_unitary_populations  function. plot_unitary_populations(prob_leakage.trajectory; fig_size=(900, 700)) Here we can see that the leakage populations have been driven substantially down. This page was generated using  Literate.jl ."},{"id":199,"pagetitle":"Two Qubit Gates","title":"Two Qubit Gates","ref":"/QuantumCollocation/dev/generated/examples/two_qubit_gates/#Two-Qubit-Gates","content":" Two Qubit Gates In this example we will solve for a selection of two-qubit gates using a simple two-qubit system. We will use the  UnitarySmoothPulseProblem  template to solve for the optimal control fields."},{"id":200,"pagetitle":"Two Qubit Gates","title":"Defining our Hamiltonian","ref":"/QuantumCollocation/dev/generated/examples/two_qubit_gates/#Defining-our-Hamiltonian","content":" Defining our Hamiltonian In quantum optimal control we work with Hamiltonians of the form \\[H(t) = H_{\\text{drift}} + \\sum_{j} u^j(t) H_{\\text{drive}}^j,\\] Specifically, for a simple two-qubit system in a rotating frame, we have \\[H = J_{12} \\sigma_1^x \\sigma_2^x + \\sum_{i \\in {1,2}} a_i^R(t) {\\sigma^x_i \\over 2} + a_i^I(t) {\\sigma^y_i \\over 2}.\\] where \\[\\begin{align*}\nJ_{12} &= 0.001 \\text{ GHz}, \\\\\n|a_i^R(t)| &\\leq 0.1 \\text{ GHz} \\\\\n\\end{align*}\\] And the duration of the gate will be capped at  $400 \\ \\mu s$ . Let's now set this up using some of the convenience functions available in QuantumCollocation.jl. using QuantumCollocation\nusing PiccoloQuantumObjects\nusing NamedTrajectories\nusing LinearAlgebra\n\nusing PiccoloPlots\nusing CairoMakie\n\n⊗(a, b) = kron(a, b)\n\n# Define our operators\nσx = GATES[:X]\nσy = GATES[:Y]\nId = GATES[:I]\n\n# Lift the operators to the two-qubit Hilbert space\nσx_1 = σx ⊗ Id\nσx_2 = Id ⊗ σx\n\nσy_1 = σy ⊗ Id\nσy_2 = Id ⊗ σy\n\n# Define the parameters of the Hamiltonian\nJ_12 = 0.001 # GHz\na_bound = 0.100 # GHz\n\n# Define the drift (coupling) Hamiltonian\nH_drift = J_12 * (σx ⊗ σx)\n\n# Define the control Hamiltonians\nH_drives = [σx_1 / 2, σy_1 / 2, σx_2 / 2, σy_2 / 2]\n\n# Define control (and higher derivative) bounds\na_bound = 0.1\nda_bound = 0.0005\ndda_bound = 0.0025\n\n# Scale the Hamiltonians by 2π\nH_drift *= 2π\nH_drives .*= 2π\n\n# Define the time parameters\nT = 100 # timesteps\nduration = 100 # μs\nΔt = duration / T\nΔt_max = 400 / T\n\n# Define the system\nsys = QuantumSystem(H_drift, H_drives) QuantumSystem: levels = 4, n_drives = 4"},{"id":201,"pagetitle":"Two Qubit Gates","title":"SWAP gate","ref":"/QuantumCollocation/dev/generated/examples/two_qubit_gates/#SWAP-gate","content":" SWAP gate # Define the goal operation\nU_goal = [\n    1 0 0 0;\n    0 0 1 0;\n    0 1 0 0;\n    0 0 0 1\n] |> Matrix{ComplexF64}\n\n# Set up the problem\nprob = UnitarySmoothPulseProblem(\n    sys,\n    U_goal,\n    T,\n    Δt;\n    a_bound=a_bound,\n    da_bound=da_bound,\n    dda_bound=dda_bound,\n    R_da=0.01,\n    R_dda=0.01,\n    Δt_max=Δt_max,\n    piccolo_options=PiccoloOptions(bound_state=true),\n)\nfid_init = unitary_rollout_fidelity(prob.trajectory, sys)\nprintln(fid_init)     constructing UnitarySmoothPulseProblem...\n\tusing integrator: typeof(UnitaryIntegrator)\n\tcontrol derivative names: [:da, :dda]\n\tapplying timesteps_all_equal constraint: Δt\n0.00039542607543285754 Solve the problem solve!(prob; max_iter=100)\n\n# Let's take a look at the final fidelity\nfid_final = unitary_rollout_fidelity(prob.trajectory, sys)\nprintln(fid_final)\n@assert fid_final > 0.99     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt\n        applying constraint: bounds on Ũ⃗\nThis is Ipopt version 3.14.17, running with linear solver MUMPS 5.8.0.\n\nNumber of nonzeros in equality constraint Jacobian...:   122590\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:    22843\n\nTotal number of variables............................:     4460\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:     4460\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     4059\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  1.9967959e+00 4.51e-01 1.67e+01   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.9988675e+00 4.50e-01 1.67e+01  -2.2 1.02e+00    -  2.21e-03 3.71e-03f  1\n   2  1.9660131e+00 4.48e-01 1.66e+01  -2.2 9.78e-01    -  4.62e-03 3.69e-03f  1\n   3  1.9912661e+00 4.44e-01 1.65e+01  -2.2 8.62e-01    -  4.63e-03 8.84e-03f  1\n   4  2.0795420e+00 4.41e-01 1.81e+01  -2.0 8.50e-01    -  1.73e-02 7.94e-03f  1\n   5  2.2058972e+00 4.37e-01 2.35e+01  -4.0 9.09e-01    -  1.22e-02 9.28e-03h  1\n   6  2.7673296e+00 4.30e-01 8.05e+01  -1.7 1.00e+00    -  3.50e-02 1.48e-02f  1\n   7  4.2160272e+00 4.17e-01 9.78e+01  -1.8 9.20e-01    -  3.97e-02 2.95e-02f  1\n   8  7.6303592e+00 4.02e-01 1.37e+02  -1.1 9.06e-01    -  7.03e-02 3.43e-02f  1\n   9  1.3480999e+01 3.73e-01 1.25e+02  -1.2 8.59e-01    -  6.26e-02 7.04e-02f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10  1.4271986e+01 3.66e-01 1.05e+02  -1.9 9.26e-01    -  6.87e-02 1.82e-02h  1\n  11  2.8657221e+01 3.28e-01 2.28e+02  -0.7 1.19e+00    -  3.24e-02 9.48e-02f  1\n  12  3.7983485e+01 3.10e-01 2.21e+02  -4.0 1.41e+00   0.0 3.92e-02 5.39e-02h  1\n  13  4.5293446e+01 2.87e-01 2.07e+02  -1.0 1.07e+00   0.4 1.34e-01 6.86e-02h  1\n  14  5.1134334e+01 2.64e-01 5.25e+02  -1.1 9.43e-01   0.9 1.90e-01 7.96e-02h  1\n  15  5.8488021e+01 2.44e-01 6.75e+02  -1.1 1.15e+00   0.4 1.83e-01 7.08e-02h  1\n  16  6.6457172e+01 2.02e-01 9.39e+02  -1.4 8.45e-01   0.8 2.68e-01 1.61e-01h  1\n  17  6.7486505e+01 1.77e-01 9.02e+03  -0.3 8.63e-01   1.2 7.25e-01 1.13e-01f  1\n  18  6.8655237e+01 1.38e-01 7.11e+03  -0.4 9.59e-01   0.7 3.63e-01 2.02e-01h  1\n  19  6.7319865e+01 1.24e-01 1.12e+04  -0.1 6.15e-01   1.2 2.99e-01 9.54e-02f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20  5.9982031e+01 1.08e-01 8.26e+03   0.3 1.45e+00   0.7 1.07e-01 1.27e-01f  1\n  21  6.0133208e+01 9.76e-02 1.29e+04   0.2 6.66e-01   1.1 1.93e-01 9.03e-02f  1\n  22  5.8272421e+01 8.08e-02 1.07e+04   0.2 9.60e-01   0.6 1.88e-01 1.70e-01f  1\n  23  6.1107349e+01 5.20e-02 5.59e+03   0.2 4.55e-01   1.1 3.17e-01 3.26e-01f  1\n  24  6.2122460e+01 4.46e-02 6.11e+03  -0.2 5.31e-01   0.6 3.83e-01 1.60e-01h  1\n  25  6.3921416e+01 4.30e-02 3.95e+04   1.0 1.69e+00   1.0 1.18e-01 3.56e-02f  1\n  26  7.3958560e+01 3.03e-02 1.51e+04   0.6 7.33e-01   0.5 4.17e-01 4.86e-01f  1\n  27  7.4850149e+01 1.77e-02 2.53e+04   0.0 2.10e-01   1.0 7.15e-01 4.28e-01h  1\n  28  7.5913314e+01 3.95e-03 1.46e+05  -0.3 1.01e-01   1.4 2.14e-01 1.00e+00f  1\n  29  7.2082474e+01 2.32e-03 9.30e+04  -4.0 3.59e-01    -  1.46e-01 6.98e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  30  6.8576970e+01 1.36e-03 4.05e+03  -0.3 1.38e-01    -  8.84e-01 1.00e+00f  1\n  31  6.6884330e+01 5.08e-04 1.47e+02  -1.1 7.05e-02   0.9 9.72e-01 1.00e+00f  1\n  32  6.1310742e+01 3.75e-03 1.35e+02  -1.7 1.60e-01   0.4 9.06e-01 1.00e+00f  1\n  33  5.2684146e+01 8.89e-03 1.75e+02  -1.3 3.27e-01  -0.0 1.00e+00 6.67e-01f  1\n  34  5.2978800e+01 6.18e-04 6.81e+00  -1.9 1.08e-01   0.4 1.00e+00 1.00e+00h  1\n  35  4.9271704e+01 2.68e-03 7.11e+00  -2.0 1.36e-01  -0.1 1.00e+00 8.98e-01f  1\n  36  4.6649822e+01 7.68e-04 4.25e+00  -2.1 7.23e-02   0.3 1.00e+00 1.00e+00f  1\n  37  4.4756267e+01 1.09e-03 1.71e+03  -1.3 7.92e-01  -0.1 1.00e+00 6.52e-02f  1\n  38  4.0403208e+01 1.33e-03 1.73e+01  -1.4 8.51e-02   0.3 1.00e+00 1.00e+00f  1\n  39  2.7720283e+01 9.24e-03 4.49e+03  -0.6 1.37e+00  -0.2 1.00e+00 1.89e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  40  3.8396213e+01 9.72e-03 5.70e+03   0.0 1.44e+00    -  2.36e-01 1.32e-01F  1\n  41  2.5199618e+01 1.14e-02 5.71e+03  -0.5 2.03e+01    -  1.58e-02 1.16e-02f  2\n  42  1.3742413e+01 7.15e-03 1.77e+03  -1.3 4.13e-01    -  5.98e-01 3.73e-01f  1\n  43  3.9179070e+00 1.03e-02 7.12e+03  -4.0 4.49e-01  -0.7 1.20e-01 8.93e-01f  1\n  44  2.7293862e+00 9.15e-03 6.00e+03  -4.0 1.03e+00    -  1.40e-01 1.83e-01f  1\n  45  4.4883154e+00 8.93e-03 2.71e+03  -1.1 3.05e-01    -  2.59e-01 1.00e+00f  1\n  46  6.3764597e+00 8.92e-03 6.91e+03  -0.1 2.17e+00    -  3.63e-01 1.18e-01F  1\n  47  4.1681236e+00 3.82e-03 1.17e+02  -0.5 1.61e-01    -  1.00e+00 1.00e+00f  1\n  48  3.6940471e+00 2.05e-04 6.74e+01  -1.4 3.25e-02   0.7 1.00e+00 1.00e+00h  1\n  49  2.9055911e+00 1.42e-04 7.42e+00  -2.2 5.60e-02   0.2 1.00e+00 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50  1.1433017e+00 4.03e-04 3.80e+00  -2.9 1.29e-01  -0.3 1.00e+00 1.00e+00f  1\n  51  1.3243103e-01 5.25e-04 7.12e+01  -3.6 1.74e-01  -0.8 1.00e+00 1.00e+00f  1\n  52  1.1698753e-01 4.85e-04 1.87e+01  -3.1 3.35e-01  -1.2 1.00e+00 1.07e-01f  2\n  53  1.6375407e-01 4.17e-04 7.10e+01  -3.3 1.05e-01  -0.8 1.00e+00 1.00e+00h  1\n  54  9.7620045e-02 1.98e-03 2.94e+02  -3.5 6.42e-02  -0.4 1.00e+00 1.00e+00H  1\n  55  9.1096711e-02 9.70e-06 2.60e+01  -4.0 4.91e-03   1.8 1.00e+00 1.00e+00h  1\n  56  9.3498028e-02 2.79e-07 5.27e-02  -4.0 7.10e-04   1.4 1.00e+00 1.00e+00h  1\n  57  8.5908360e-02 9.69e-07 2.94e-02  -4.0 2.07e-03   0.9 1.00e+00 1.00e+00f  1\n  58  6.8993343e-02 3.35e-06 4.41e-02  -4.0 5.66e-03   0.4 1.00e+00 1.00e+00f  1\n  59  3.9814802e-02 1.42e-05 5.69e-02  -4.0 1.34e-02  -0.1 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  60  7.3118833e-03 2.20e-05 5.80e-02  -4.0 2.24e-02  -0.5 1.00e+00 1.00e+00h  1\n  61  4.0909528e-03 2.67e-05 7.08e+01  -4.0 2.05e-02  -1.0 1.00e+00 1.00e+00h  1\n  62  1.9120931e-03 2.53e-03 1.98e+02  -4.0 3.14e-02  -1.5 2.54e-01 4.21e-01H  1\n  63  2.5833766e-02 6.02e-04 6.07e+01  -4.0 1.09e-02   0.7 1.00e+00 7.55e-01h  1\n  64  8.6656215e-03 2.14e-06 3.92e+00  -4.1 1.57e-03   2.1 1.00e+00 1.00e+00h  1\n  65  8.5909086e-03 1.25e-08 1.29e-02  -4.0 1.22e-04   1.6 1.00e+00 1.00e+00h  1\n  66  8.1890322e-03 1.76e-07 7.51e-03  -4.0 5.71e-04   1.1 1.00e+00 1.00e+00h  1\n  67  7.2067533e-03 3.54e-07 1.04e-02  -4.0 1.01e-03   0.6 1.00e+00 1.00e+00h  1\n  68  5.2159261e-03 1.40e-06 1.35e-02  -4.0 2.57e-03   0.2 1.00e+00 1.00e+00h  1\n  69  2.2719247e-03 4.95e-06 1.56e-02  -4.0 5.07e-03  -0.3 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  70  2.9081260e-04 1.45e-05 7.07e+01  -4.0 6.17e-03  -0.8 1.00e+00 1.00e+00h  1\n  71  7.9499251e-04 1.29e-05 1.77e+01  -4.0 1.36e-02  -1.3 1.00e+00 2.50e-01h  3\n  72  8.5282804e-04 6.36e-05 6.19e+01  -4.0 2.76e-02  -1.8 1.00e+00 5.00e-01h  2\n  73  1.3851088e-03 2.95e-05 7.07e+01  -4.1 7.05e-03  -0.4 1.00e+00 1.00e+00h  1\n  74  6.9805978e-04 1.93e-08 9.38e-01  -4.1 1.55e-04   1.8 1.00e+00 1.00e+00h  1\n  75  6.8223322e-04 6.32e-09 1.96e-03  -4.0 8.93e-05   1.3 1.00e+00 1.00e+00h  1\n  76  6.3966373e-04 5.15e-09 2.67e-03  -4.0 1.39e-04   0.9 1.00e+00 1.00e+00h  1\n  77  5.6146586e-04 1.88e-08 3.59e-03  -4.0 2.52e-04   0.4 1.00e+00 1.00e+00h  1\n  78  4.6289442e-04 1.26e-07 3.82e-03  -4.0 6.74e-04  -0.1 1.00e+00 1.00e+00h  1\n  79  3.6507766e-04 9.61e-07 3.06e-03  -4.0 1.85e-03  -0.6 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  80  3.1484051e-04 6.33e-06 4.12e-03  -4.0 4.84e-03  -1.1 1.00e+00 1.00e+00h  1\n  81  3.0679379e-04 3.60e-05 2.13e-02  -4.0 1.15e-02  -1.5 1.00e+00 1.00e+00h  1\n  82  2.7496131e-04 9.09e-05 5.23e-02  -4.1 1.81e-02  -2.0 1.00e+00 1.00e+00h  1\n  83  2.7888706e-04 4.12e-04 7.07e+01  -4.0 4.16e-02  -2.5 1.00e+00 1.00e+00h  1\n  84  5.1154949e-03 4.06e-04 1.64e+00  -4.1 5.30e-01  -2.1 1.61e-01 2.32e-02h  4\n  85  5.1360657e-03 4.02e-04 1.62e+00  -4.1 7.73e-01  -2.5 1.09e-01 1.09e-02h  5\n  86  7.3073495e-03 1.04e-04 7.07e+01  -4.1 1.71e-02  -2.1 1.00e+00 1.00e+00h  1\n  87  3.7267662e-03 2.20e-04 6.50e+01  -4.1 2.76e-01  -1.7 2.72e-01 8.02e-02h  2\n  88  7.7212376e-04 2.50e-04 1.22e+01  -4.1 2.95e-01  -1.3 1.22e-01 5.24e-02h  3\n  89  3.8236953e-03 5.93e-05 7.07e+01  -4.1 1.13e-02  -0.8 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  90  3.0579184e-03 1.74e-04 6.61e+01  -4.1 2.27e-01  -1.3 1.47e-01 6.54e-02h  2\n  91  1.1860791e-03 5.96e-04 1.10e+02  -4.1 2.84e-02  -0.9 1.00e+00 5.25e-01H  1\n  92  6.9082663e-04 5.49e-06 7.07e+01  -4.1 2.25e-03   1.3 1.00e+00 1.00e+00f  1\n  93  4.6529803e-04 1.86e-07 2.48e+00  -4.1 3.89e-04   1.8 1.00e+00 1.00e+00h  1\n  94  4.6375904e-04 1.06e-07 6.20e-03  -4.0 3.15e-04   1.3 1.00e+00 1.00e+00h  1\n  95  4.6352283e-04 3.78e-07 3.89e-03  -4.0 5.93e-04   0.8 1.00e+00 1.00e+00h  1\n  96  4.4001119e-04 1.09e-06 2.53e-03  -4.0 1.17e-03   0.3 1.00e+00 1.00e+00h  1\n  97  3.9176715e-04 4.05e-06 1.84e-03  -4.0 2.24e-03  -0.1 1.00e+00 1.00e+00h  1\n  98  3.1763905e-04 7.34e-06 3.91e-03  -4.1 3.15e-03  -0.6 1.00e+00 1.00e+00h  1\n  99  3.0056399e-04 3.07e-05 1.42e-02  -4.0 6.91e-03  -1.1 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 100  2.7085376e-04 2.46e-05 7.07e+01  -4.0 6.97e-03  -1.6 1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 100\n\n                                   (scaled)                 (unscaled)\nObjective...............:   2.7085375634531395e-04    2.7085375634531395e-04\nDual infeasibility......:   7.0711083648004916e+01    7.0711083648004916e+01\nConstraint violation....:   2.4579227554055727e-05    2.4579227554055727e-05\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   1.0000601504789006e-04    1.0000601504789006e-04\nOverall NLP error.......:   7.0711083648004916e+01    7.0711083648004916e+01\n\n\nNumber of objective function evaluations             = 136\nNumber of objective gradient evaluations             = 101\nNumber of equality constraint evaluations            = 136\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 101\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 100\nTotal seconds in IPOPT                               = 486.712\n\nEXIT: Maximum Number of Iterations Exceeded.\n0.9999995364706331 Looks good! Now let's plot the pulse and the population trajectories for the first two columns of the unitary, i.e. initial state of  $\\ket{00}$  and  $\\ket{01}$ . For this we provide the function  plot_unitary_populations . plot_unitary_populations(prob.trajectory) For fun, let's look at a minimum time pulse for this problem min_time_prob = UnitaryMinimumTimeProblem(prob, U_goal; final_fidelity=.995)\nsolve!(min_time_prob; max_iter=300)\nfid_final_min_time = unitary_rollout_fidelity(min_time_prob.trajectory, sys)\nprintln(fid_final_min_time)\n@assert fid_final_min_time > 0.99     constructing UnitaryMinimumTimeProblem...\n\tfinal fidelity: 0.995\n    initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt\n        applying constraint: bounds on Ũ⃗\nThis is Ipopt version 3.14.17, running with linear solver MUMPS 5.8.0.\n\nNumber of nonzeros in equality constraint Jacobian...:    47302\nNumber of nonzeros in inequality constraint Jacobian.:       32\nNumber of nonzeros in Lagrangian Hessian.............:    23371\n\nTotal number of variables............................:     4460\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:     4460\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     4059\nTotal number of inequality constraints...............:        1\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        1\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  3.7687911e+04 9.71e-03 1.00e+02   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  3.7671610e+04 9.71e-03 1.97e+04   1.7 7.67e+01    -  3.16e-02 3.10e-05f  2\n   2  2.5655617e+04 9.61e-03 3.09e+04  -0.4 4.34e+01    -  4.41e-02 2.80e-02f  1\n   3  2.3575411e+04 1.03e-02 3.99e+05   1.4 1.04e+01    -  1.00e+00 2.03e-02f  1\n   4  2.4161807e+04 8.04e-03 1.17e+05   1.5 3.00e-01    -  1.00e+00 6.88e-01h  1\n   5  2.7345348e+04 5.75e-03 1.37e+05   1.8 5.21e-01    -  4.62e-01 6.38e-01f  1\n   6  2.8795938e+04 2.97e-03 6.92e+04   1.7 3.24e-01   2.0 8.34e-01 6.87e-01h  1\n   7  3.1117249e+04 2.34e-03 2.45e+05   1.9 4.69e-01   1.5 1.00e+00 5.00e-01h  2\n   8  3.1411624e+04 2.08e-03 2.58e+05   1.9 3.41e-01    -  1.00e+00 2.50e-01h  3\n   9  3.1790896e+04 1.87e-03 2.01e+05   1.7 2.93e-01    -  1.00e+00 2.50e-01h  3\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10  3.2682690e+04 1.94e-03 2.88e+05   1.3 2.01e-01   1.9 1.00e+00 5.00e-01h  2\n  11  3.4102866e+04 1.47e-03 1.02e+05   0.6 1.83e-01   2.4 1.00e+00 7.84e-01h  1\n  12  3.5191966e+04 2.74e-04 8.80e+04   0.2 1.10e-01   2.8 1.00e+00 1.00e+00h  1\n  13  3.5494636e+04 4.68e-05 1.61e+04  -0.8 3.62e-02   3.2 1.00e+00 8.44e-01h  1\n  14  3.5582921e+04 6.28e-05 2.01e+04  -1.2 1.21e-02   2.7 1.00e+00 1.00e+00h  1\n  15  3.5568469e+04 3.64e-04 7.49e+03  -1.3 2.77e-02   2.3 1.00e+00 9.32e-01f  1\n  16  3.5560176e+04 5.39e-04 4.12e+02  -1.4 3.76e-02   1.8 9.71e-01 1.00e+00f  1\n  17  3.5557031e+04 4.57e-05 9.02e+01  -1.4 9.75e-03   2.2 1.00e+00 9.80e-01f  1\n  18  3.5552158e+04 1.62e-04 2.07e+02  -1.9 1.96e-02   1.7 1.00e+00 1.00e+00f  1\n  19  3.5550763e+04 1.35e-04 1.82e+02  -2.0 1.81e-02   1.3 1.00e+00 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20  3.5551007e+04 1.14e-04 1.50e+02  -2.0 3.39e-02   0.8 8.96e-01 5.00e-01h  2\n  21  3.5549864e+04 6.96e-05 7.05e+01  -2.7 1.09e-02   1.2 1.00e+00 9.78e-01f  1\n  22  3.5549952e+04 4.89e-04 2.25e+02  -2.2 2.96e-02   0.7 1.00e+00 1.00e+00f  1\n  23  3.5549517e+04 3.01e-06 5.07e+00  -2.3 1.78e-03   2.1 1.00e+00 1.00e+00f  1\n  24  3.5549389e+04 7.80e-06 9.95e+00  -3.1 3.44e-03   1.6 1.00e+00 1.00e+00f  1\n  25  3.5549281e+04 4.07e-05 2.88e+01  -3.8 6.18e-03   1.1 1.00e+00 1.00e+00f  1\n  26  3.5549225e+04 6.20e-05 2.94e+01  -3.9 9.64e-03   0.6 1.00e+00 1.00e+00h  1\n  27  3.5549212e+04 7.16e-05 4.95e+01  -4.0 1.80e-02   0.2 1.80e-01 4.62e-01h  1\n  28  3.5549214e+04 3.51e-05 3.21e+01  -4.0 1.22e-02   0.6 1.98e-01 5.07e-01h  1\n  29  3.5549198e+04 2.15e-05 1.67e+01  -4.0 6.27e-03   1.0 4.99e-01 3.91e-01h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  30  3.5549194e+04 1.48e-04 2.75e+01  -3.2 2.25e-02   0.5 1.00e+00 5.06e-01f  1\n  31  3.5549172e+04 8.87e-06 3.56e+01  -4.0 4.30e-03   1.0 3.06e-01 1.00e+00h  1\n  32  3.5549136e+04 2.57e-05 3.35e+01  -3.6 6.30e-03   0.5 1.00e+00 1.00e+00h  1\n  33  3.5549132e+04 3.91e-05 2.06e+01  -4.0 1.26e-02   0.0 5.27e-01 6.57e-01h  1\n  34  3.5549124e+04 1.09e-06 1.35e+00  -4.0 1.13e-03   1.3 1.00e+00 1.00e+00h  1\n  35  3.5549120e+04 5.78e-06 3.31e+00  -4.0 2.61e-03   0.9 1.00e+00 1.00e+00h  1\n  36  3.5549113e+04 1.16e-05 1.11e+01  -4.0 5.34e-03   0.4 1.00e+00 1.00e+00h  1\n  37  3.5549109e+04 2.30e-05 1.79e+01  -4.0 6.75e-03  -0.1 1.00e+00 1.00e+00h  1\n  38  3.5549106e+04 3.17e-05 1.19e+01  -4.0 5.71e-03   0.3 9.87e-01 9.67e-01h  1\n  39  3.5549105e+04 4.58e-06 3.95e+00  -4.0 2.10e-03   0.8 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  40  3.5549101e+04 8.35e-06 5.47e+00  -4.0 3.92e-03   0.3 1.00e+00 1.00e+00h  1\n  41  3.5549099e+04 1.81e-05 1.37e+01  -4.0 6.05e-03  -0.2 1.00e+00 1.00e+00h  1\n  42  3.5549088e+04 4.37e-05 1.63e+01  -4.0 6.68e-03   0.2 1.00e+00 1.00e+00h  1\n  43  3.5549089e+04 3.97e-05 1.56e+01  -4.0 8.57e-03   0.7 2.60e-01 3.00e-02H  1\n  44  3.5549097e+04 3.01e-07 2.14e-01  -4.0 5.96e-04   1.1 1.00e+00 1.00e+00h  1\n  45  3.5549096e+04 1.43e-05 3.91e+00  -4.0 5.36e-03   0.6 5.32e-01 7.36e-01h  1\n  46  3.5549095e+04 2.01e-05 7.09e+00  -4.0 8.02e-03   0.1 1.00e+00 5.94e-01h  1\n  47  3.5549085e+04 1.05e-03 3.18e+02  -4.0 3.92e-02  -0.4 2.21e-01 1.00e+00h  1\n  48  3.5549088e+04 1.07e-07 9.80e-01  -4.1 1.61e-03   2.8 1.00e+00 1.00e+00h  1\n  49  3.5549094e+04 4.31e-08 4.83e-02  -4.0 1.97e-04   2.3 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50  3.5549094e+04 2.39e-07 5.46e-02  -4.0 4.62e-04   1.8 1.00e+00 1.00e+00h  1\n  51  3.5549094e+04 9.83e-07 1.96e-01  -4.1 9.52e-04   1.4 1.00e+00 1.00e+00h  1\n  52  3.5549093e+04 3.12e-06 5.40e-01  -4.1 1.77e-03   0.9 1.00e+00 1.00e+00h  1\n  53  3.5549092e+04 4.20e-06 2.07e+00  -4.1 2.27e-03   0.4 1.00e+00 1.00e+00h  1\n  54  3.5549091e+04 8.56e-06 8.40e+00  -4.1 3.99e-03  -0.1 1.00e+00 1.00e+00h  1\n  55  3.5549091e+04 1.35e-06 9.73e-01  -4.1 1.33e-03   0.3 1.00e+00 1.00e+00h  1\n  56  3.5549090e+04 7.29e-06 4.39e+00  -4.1 4.12e-03  -0.1 1.00e+00 1.00e+00h  1\n  57  3.5549090e+04 5.77e-06 4.42e+00  -4.1 8.18e-03  -0.6 1.00e+00 2.50e-01h  3\n  58  3.5549089e+04 3.57e-06 4.06e+00  -4.1 2.81e-03  -0.2 1.00e+00 1.00e+00h  1\n  59  3.5549087e+04 2.91e-04 8.14e+01  -4.1 1.88e-02  -0.7 7.35e-01 9.47e-01h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  60  3.5549076e+04 5.37e-06 6.37e+00  -4.0 2.74e-03   2.5 1.00e+00 1.00e+00f  1\n  61  3.5549090e+04 2.38e-06 6.13e-01  -3.2 1.06e-03   2.0 9.99e-01 1.00e+00h  1\n  62  3.5549090e+04 5.00e-07 2.21e-01  -3.3 7.70e-04   1.5 1.00e+00 1.00e+00h  1\n  63  3.5549089e+04 1.18e-06 4.39e+00  -5.0 7.90e-04   1.0 8.94e-01 1.00e+00h  1\n  64  3.5549087e+04 4.07e-06 1.08e+00  -5.0 1.41e-03   0.6 1.00e+00 1.00e+00h  1\n  65  3.5549089e+04 8.47e-06 7.53e+00  -4.0 3.22e-03   0.1 1.00e+00 1.00e+00h  1\n  66  3.5549089e+04 1.04e-06 2.70e-01  -4.1 8.42e-04   0.5 1.00e+00 1.00e+00h  1\n  67  3.5549088e+04 1.62e-06 8.73e-01  -4.1 1.60e-03   0.0 1.00e+00 1.00e+00h  1\n  68  3.5549087e+04 4.73e-06 5.01e+00  -4.1 3.62e-03  -0.4 1.00e+00 1.00e+00h  1\n  69  3.5549087e+04 8.61e-07 6.19e-01  -4.1 1.24e-03  -0.0 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  70  3.5549087e+04 1.04e-05 7.41e+00  -4.0 4.35e-03  -0.5 1.00e+00 1.00e+00h  1\n  71  3.5549088e+04 1.94e-06 7.78e-01  -4.1 1.82e-03  -0.1 1.00e+00 1.00e+00h  1\n  72  3.5549086e+04 2.09e-05 5.14e+00  -4.1 5.67e-03  -0.5 1.00e+00 1.00e+00h  1\n  73  3.5549086e+04 1.24e-07 2.67e-02  -4.1 3.42e-04   0.8 1.00e+00 1.00e+00h  1\n  74  3.5549086e+04 4.73e-07 2.28e-01  -4.0 7.31e-04   0.3 1.00e+00 1.00e+00h  1\n  75  3.5549086e+04 1.49e-06 1.07e+00  -4.0 1.67e-03  -0.2 1.00e+00 1.00e+00h  1\n  76  3.5549086e+04 3.95e-06 3.50e+00  -4.1 3.18e-03  -0.6 1.00e+00 1.00e+00h  1\n  77  3.5549086e+04 1.21e-06 6.34e-01  -4.1 1.36e-03  -0.2 1.00e+00 1.00e+00h  1\n  78  3.5549086e+04 8.81e-06 6.63e+00  -4.0 4.02e-03  -0.7 1.00e+00 1.00e+00h  1\n  79  3.5549088e+04 5.64e-06 3.23e+00  -4.1 2.17e-03  -0.3 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  80  3.5549086e+04 1.43e-06 2.76e-01  -4.1 1.08e-03   0.2 1.00e+00 1.00e+00h  1\n  81  3.5549086e+04 3.15e-06 1.17e+00  -4.0 2.04e-03  -0.3 1.00e+00 1.00e+00h  1\n  82  3.5549086e+04 1.10e-05 4.49e+00  -4.1 3.63e-03  -0.8 1.00e+00 1.00e+00h  1\n  83  3.5549085e+04 1.21e-06 2.58e-01  -4.1 1.03e-03   0.5 1.00e+00 1.00e+00h  1\n  84  3.5549085e+04 6.87e-07 2.11e-01  -4.0 7.30e-04   0.1 1.00e+00 1.00e+00h  1\n  85  3.5549085e+04 1.77e-06 1.27e+00  -4.0 1.66e-03  -0.4 1.00e+00 1.00e+00h  1\n  86  3.5549085e+04 3.43e-06 3.47e+00  -4.1 2.80e-03  -0.9 1.00e+00 1.00e+00h  1\n  87  3.5549085e+04 2.20e-06 9.65e-01  -4.1 1.61e-03  -0.5 1.00e+00 1.00e+00h  1\n  88  3.5549085e+04 1.93e-06 9.84e-01  -4.0 5.17e-03  -0.9 1.00e+00 1.25e-01h  4\n  89  3.5549085e+04 1.87e-06 9.95e-01  -4.0 1.38e-02  -1.4 1.00e+00 3.12e-02h  6\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  90  3.5549085e+04 6.87e-06 7.29e+00  -4.0 3.84e-03  -1.0 1.00e+00 1.00e+00h  1\n  91  3.5549085e+04 1.94e-07 4.73e-02  -4.1 4.55e-04   0.3 1.00e+00 1.00e+00h  1\n  92  3.5549085e+04 7.32e-07 2.10e-01  -4.0 8.94e-04  -0.1 1.00e+00 1.00e+00h  1\n  93  3.5549085e+04 1.46e-06 1.53e+00  -4.0 1.79e-03  -0.6 1.00e+00 1.00e+00h  1\n  94  3.5549085e+04 1.27e-06 1.30e+00  -4.1 3.88e-03  -1.1 1.00e+00 2.50e-01h  3\n  95  3.5549084e+04 2.91e-05 3.63e+01  -4.1 7.88e-03  -1.6 1.00e+00 1.00e+00h  1\n  96  3.5549085e+04 2.16e-08 3.68e-02  -4.1 1.60e-04   0.7 1.00e+00 1.00e+00h  1\n  97  3.5549085e+04 1.86e-07 1.25e-01  -4.0 5.21e-04   0.2 1.00e+00 1.00e+00h  1\n  98  3.5549085e+04 7.53e-07 5.90e-01  -4.0 1.12e-03  -0.3 1.00e+00 1.00e+00h  1\n  99  3.5549085e+04 1.23e-06 1.47e+00  -4.1 1.68e-03  -0.8 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 100  3.5549085e+04 5.79e-06 6.06e+00  -4.1 3.52e-03  -1.3 1.00e+00 1.00e+00h  1\n 101  3.5549085e+04 2.21e-07 6.30e-02  -4.1 4.81e-04   0.1 1.00e+00 1.00e+00h  1\n 102  3.5549085e+04 9.91e-07 5.72e-01  -4.0 1.21e-03  -0.4 1.00e+00 1.00e+00h  1\n 103  3.5549085e+04 5.86e-07 6.28e-01  -4.1 1.85e-03  -0.9 1.00e+00 5.00e-01h  2\n 104  3.5549085e+04 6.03e-06 7.49e+00  -4.1 3.47e-03  -1.4 1.00e+00 1.00e+00h  1\n 105  3.5549085e+04 6.28e-08 3.98e-02  -4.1 2.88e-04  -0.0 1.00e+00 1.00e+00h  1\n 106  3.5549085e+04 9.55e-07 5.38e-01  -4.0 1.24e-03  -0.5 1.00e+00 1.00e+00h  1\n 107  3.5549085e+04 5.36e-07 5.64e-01  -4.1 1.79e-03  -1.0 1.00e+00 5.00e-01h  2\n 108  3.5549085e+04 5.39e-06 6.96e+00  -4.1 3.46e-03  -1.5 1.00e+00 1.00e+00h  1\n 109  3.5549085e+04 6.48e-08 3.79e-02  -4.1 2.70e-04  -0.1 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 110  3.5549085e+04 1.13e-06 5.72e-01  -4.0 1.29e-03  -0.6 1.00e+00 1.00e+00h  1\n 111  3.5549085e+04 5.57e-07 6.11e-01  -4.1 2.07e-03  -1.1 1.00e+00 5.00e-01h  2\n 112  3.5549084e+04 6.62e-06 7.27e+00  -4.1 3.82e-03  -1.6 1.00e+00 1.00e+00h  1\n 113  3.5549085e+04 1.29e-06 3.35e-01  -4.1 1.19e-03  -0.2 1.00e+00 1.00e+00h  1\n 114  3.5549085e+04 3.40e-06 1.56e+00  -4.1 1.94e-03  -0.7 1.00e+00 1.00e+00h  1\n 115  3.5549085e+04 5.01e-06 7.57e-01  -4.1 2.20e-03  -0.3 1.00e+00 1.00e+00h  1\n 116  3.5549085e+04 5.63e-07 1.37e-01  -4.0 7.35e-04   0.1 1.00e+00 1.00e+00h  1\n 117  3.5549085e+04 2.94e-07 1.38e-01  -4.1 5.73e-04  -0.3 1.00e+00 1.00e+00h  1\n 118  3.5549085e+04 1.02e-06 7.70e-01  -4.0 1.43e-03  -0.8 1.00e+00 1.00e+00h  1\n 119  3.5549085e+04 8.75e-07 6.89e-01  -4.1 8.30e-03  -1.3 1.00e+00 1.25e-01h  4\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 120  3.5549077e+04 9.73e-04 4.34e+02  -4.1 3.16e-02  -1.8 2.72e-04 1.97e-04H  1\n 121  3.5549074e+04 7.86e-06 2.66e+01  -4.1 2.29e-03   2.3 1.00e+00 1.00e+00f  1\n 122  3.5549087e+04 7.25e-07 2.71e-01  -4.0 6.02e-04   1.8 1.00e+00 1.00e+00h  1\n 123  3.5549085e+04 1.91e-06 7.11e-01  -4.1 1.03e-03   1.3 1.00e+00 1.00e+00h  1\n 124  3.5549085e+04 2.96e-06 9.10e-01  -4.1 1.48e-03   0.8 1.00e+00 1.00e+00h  1\n 125  3.5549084e+04 3.37e-06 9.62e-01  -4.1 1.65e-03   0.4 1.00e+00 1.00e+00h  1\n 126  3.5549085e+04 3.63e-06 1.23e+00  -4.0 2.13e-03  -0.1 1.00e+00 1.00e+00h  1\n 127  3.5549084e+04 2.53e-06 1.64e+00  -4.1 1.98e-03  -0.6 1.00e+00 1.00e+00h  1\n 128  3.5549085e+04 1.21e-06 4.14e-01  -4.1 1.25e-03  -0.2 1.00e+00 1.00e+00h  1\n 129  3.5549085e+04 6.54e-06 2.56e+00  -4.0 3.15e-03  -0.6 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 130  3.5549085e+04 2.71e-08 8.34e-03  -4.1 1.84e-04   0.7 1.00e+00 1.00e+00h  1\n 131  3.5549085e+04 2.47e-07 6.10e-02  -4.0 5.95e-04   0.2 1.00e+00 1.00e+00h  1\n 132  3.5549084e+04 4.96e-07 2.17e-01  -4.1 9.60e-04  -0.3 1.00e+00 1.00e+00h  1\n 133  3.5549085e+04 2.39e-06 1.67e+00  -4.0 2.44e-03  -0.7 1.00e+00 1.00e+00h  1\n 134  3.5549085e+04 1.20e-07 1.18e-01  -4.1 5.49e-04  -0.3 1.00e+00 1.00e+00h  1\n 135  3.5549084e+04 2.07e-06 1.01e+00  -4.1 2.11e-03  -0.8 1.00e+00 1.00e+00h  1\n 136  3.5549084e+04 1.49e-07 1.22e-01  -4.1 5.42e-04  -0.4 1.00e+00 1.00e+00h  1\n 137  3.5549085e+04 3.08e-06 1.35e+00  -4.0 2.72e-03  -0.8 1.00e+00 1.00e+00h  1\n 138  3.5549085e+04 1.95e-07 1.31e-01  -4.1 7.09e-04  -0.4 1.00e+00 1.00e+00h  1\n 139  3.5549084e+04 2.60e-06 1.13e+00  -4.1 2.39e-03  -0.9 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 140  3.5549084e+04 3.37e-07 1.43e-01  -4.1 8.75e-04  -0.5 1.00e+00 1.00e+00h  1\n 141  3.5549084e+04 3.29e-06 1.45e+00  -4.1 2.66e-03  -1.0 1.00e+00 1.00e+00h  1\n 142  3.5549084e+04 1.36e-06 6.28e-01  -4.1 2.43e-03  -0.5 1.00e+00 5.00e-01h  2\n 143  3.5549085e+04 2.16e-06 7.11e-01  -4.1 1.87e-03  -1.0 1.00e+00 1.00e+00h  1\n 144  3.5549084e+04 2.84e-06 7.30e-01  -4.1 2.05e-03  -0.6 1.00e+00 1.00e+00h  1\n 145  3.5549084e+04 3.78e-07 9.28e-02  -4.0 6.88e-04  -0.1 1.00e+00 1.00e+00h  1\n 146  3.5549084e+04 3.85e-07 1.64e-01  -4.1 9.17e-04  -0.6 1.00e+00 1.00e+00h  1\n 147  3.5549085e+04 1.88e-06 1.59e+00  -4.0 2.40e-03  -1.1 1.00e+00 1.00e+00h  1\n 148  3.5549084e+04 6.76e-07 3.32e-01  -4.1 9.77e-04  -0.7 1.00e+00 1.00e+00h  1\n 149  3.5549084e+04 5.60e-06 2.01e+00  -4.0 3.26e-03  -1.2 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 150  3.5549084e+04 2.34e-07 4.60e-02  -4.1 5.36e-04   0.2 1.00e+00 1.00e+00h  1\n 151  3.5549084e+04 1.74e-07 8.35e-02  -4.0 4.95e-04  -0.3 1.00e+00 1.00e+00h  1\n 152  3.5549084e+04 2.65e-07 2.25e-01  -4.1 9.10e-04  -0.8 1.00e+00 1.00e+00h  1\n 153  3.5549084e+04 2.77e-06 2.62e+00  -4.0 2.35e-03  -1.3 1.00e+00 1.00e+00h  1\n 154  3.5549084e+04 3.28e-07 3.97e-01  -4.1 6.48e-04  -0.8 1.00e+00 1.00e+00h  1\n 155  3.5549084e+04 3.87e-06 3.46e+00  -4.1 2.48e-03  -1.3 1.00e+00 1.00e+00h  1\n 156  3.5549084e+04 1.93e-08 1.60e-02  -4.1 1.72e-04   0.0 1.00e+00 1.00e+00h  1\n 157  3.5549084e+04 2.17e-07 1.02e-01  -4.0 5.68e-04  -0.5 1.00e+00 1.00e+00h  1\n 158  3.5549084e+04 3.43e-07 3.43e-01  -4.1 1.02e-03  -0.9 1.00e+00 1.00e+00h  1\n 159  3.5549084e+04 2.19e-06 2.52e+00  -4.1 1.89e-03  -1.4 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 160  3.5549084e+04 5.59e-07 4.12e-01  -4.1 1.06e-03  -1.0 1.00e+00 1.00e+00h  1\n 161  3.5549084e+04 3.77e-07 4.14e-01  -4.0 5.93e-03  -1.5 1.00e+00 1.25e-01h  4\n 162  3.5549084e+04 3.67e-07 4.10e-01  -4.0 6.10e-03  -1.9 1.00e+00 1.56e-02h  7\n 163  3.5549084e+04 3.60e-07 4.09e-01  -4.0 1.92e-02  -2.4 1.00e+00 7.81e-03h  8\n 164  3.5549084e+04 3.51e-07 4.05e-01  -4.0 6.47e-03  -2.0 1.00e+00 1.56e-02h  7\n 165  3.5549084e+04 3.44e-07 4.05e-01  -4.0 2.02e-02  -2.5 1.00e+00 7.81e-03h  8\n 166  3.5549084e+04 3.36e-07 4.02e-01  -4.0 6.79e-03  -2.0 1.00e+00 1.56e-02h  7\n 167  3.5549084e+04 3.30e-07 4.01e-01  -4.0 1.89e-02  -2.5 1.00e+00 7.81e-03h  8\n 168  3.5549084e+04 3.21e-07 3.99e-01  -4.0 7.16e-03  -2.1 1.00e+00 1.56e-02h  7\n 169  3.5549084e+04 3.17e-07 3.99e-01  -4.0 1.96e-02  -2.6 1.00e+00 7.81e-03h  8\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 170  3.5549084e+04 3.09e-07 3.97e-01  -4.0 7.53e-03  -2.1 1.00e+00 1.56e-02h  7\n 171  3.5549084e+04 3.04e-07 3.95e-01  -4.1 1.44e-02  -2.6 1.00e+00 7.81e-03h  8\n 172  3.5549084e+04 3.03e-07 3.93e-01  -4.0 8.42e-03  -2.2 1.00e+00 7.81e-03h  8\n 173  3.5549084e+04 2.97e-07 3.87e-01  -4.0 4.45e-03  -1.8 1.00e+00 3.12e-02h  6\n 174  3.5549084e+04 2.95e-07 3.85e-01  -4.0 8.30e-03  -2.2 1.00e+00 7.81e-03h  8\n 175  3.5549084e+04 2.91e-07 3.80e-01  -4.0 4.78e-03  -1.8 1.00e+00 3.12e-02h  6\n 176  3.5549084e+04 2.89e-07 3.78e-01  -4.0 8.67e-03  -2.3 1.00e+00 7.81e-03h  8\n 177  3.5549084e+04 2.86e-07 3.74e-01  -4.0 5.10e-03  -1.9 1.00e+00 1.56e-02h  7\n 178  3.5549084e+04 2.84e-07 3.73e-01  -4.0 9.14e-03  -2.3 1.00e+00 7.81e-03h  8\n 179  3.5549084e+04 2.81e-07 3.70e-01  -4.0 5.47e-03  -1.9 1.00e+00 1.56e-02h  7\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 180  3.5549084e+04 2.79e-07 3.69e-01  -4.0 9.61e-03  -2.4 1.00e+00 7.81e-03h  8\n 181  3.5549084e+04 2.77e-07 3.66e-01  -4.0 5.85e-03  -2.0 1.00e+00 1.56e-02h  7\n 182  3.5549084e+04 2.75e-07 3.65e-01  -4.1 7.97e-03  -2.5 1.00e+00 7.81e-03h  8\n 183  3.5549084e+04 2.72e-07 3.61e-01  -4.1 5.20e-03  -2.0 1.00e+00 1.56e-02h  7\n 184  3.5549084e+04 2.72e-07 3.60e-01  -4.1 9.40e-03  -2.5 1.00e+00 7.81e-03h  8\n 185  3.5549084e+04 2.70e-07 3.56e-01  -4.1 5.54e-03  -2.1 1.00e+00 1.56e-02h  7\n 186  3.5549084e+04 2.70e-07 3.55e-01  -4.1 9.22e-03  -2.6 1.00e+00 7.81e-03h  8\n 187  3.5549084e+04 2.69e-07 3.53e-01  -4.1 5.87e-03  -2.1 1.00e+00 1.56e-02h  7\n 188  3.5549084e+04 5.26e-06 6.16e+00  -4.1 3.17e-03  -1.7 1.00e+00 1.00e+00h  1\n 189  3.5549084e+04 5.71e-08 4.41e-02  -4.1 2.66e-04  -0.4 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 190  3.5549084e+04 5.47e-08 4.48e-01  -4.0 1.17e-03  -0.8 1.00e+00 6.25e-02h  5\n 191  3.5549084e+04 2.24e-03 3.99e+03  -4.0 3.23e-01    -  7.31e-01 4.92e-01h  2\n 192  3.5552053e+04 2.21e-05 1.79e+02  -4.1 2.14e-02   3.2 1.00e+00 1.00e+00h  1\n 193  3.5548840e+04 4.44e-07 3.80e+01  -4.1 1.64e-03   2.7 1.00e+00 1.00e+00f  1\n 194  3.5549051e+04 2.59e-07 5.86e+00  -4.0 7.19e-04   2.2 1.00e+00 1.00e+00h  1\n 195  3.5549084e+04 2.57e-07 2.96e-01  -4.0 5.20e-04   1.8 1.00e+00 1.00e+00h  1\n 196  3.5549085e+04 2.03e-07 2.01e-01  -4.1 9.47e-04   1.3 1.00e+00 1.00e+00H  1\n 197  3.5549085e+04 1.61e-07 1.74e-01  -4.1 1.46e-03   0.8 1.00e+00 2.50e-01h  3\n 198  3.5549084e+04 5.35e-06 1.07e+00  -4.1 2.30e-03   0.3 1.00e+00 1.00e+00h  1\n 199  3.5549084e+04 6.06e-06 6.19e-01  -4.1 4.45e-03  -0.2 1.00e+00 5.00e-01h  2\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 200  3.5549084e+04 1.54e-06 2.60e-01  -4.1 1.21e-03   0.3 1.00e+00 1.00e+00h  1\n 201  3.5549084e+04 1.30e-06 4.65e-01  -4.1 1.16e-03  -0.2 1.00e+00 1.00e+00h  1\n 202  3.5549084e+04 1.81e-06 5.36e-01  -4.1 1.38e-03  -0.7 1.00e+00 1.00e+00h  1\n 203  3.5549084e+04 3.07e-06 1.67e+00  -4.1 1.92e-03  -1.2 1.00e+00 1.00e+00h  1\n 204  3.5549084e+04 8.91e-08 3.20e-02  -4.1 3.18e-04   0.2 1.00e+00 1.00e+00h  1\n 205  3.5549084e+04 2.59e-07 1.80e-01  -4.0 5.23e-04  -0.3 1.00e+00 1.00e+00h  1\n 206  3.5549084e+04 4.83e-07 3.11e-01  -4.1 7.86e-04  -0.8 1.00e+00 1.00e+00h  1\n 207  3.5549084e+04 9.91e-07 1.26e+00  -4.1 1.43e-03  -1.3 1.00e+00 1.00e+00h  1\n 208  3.5549084e+04 2.01e-07 1.58e-01  -4.1 5.32e-04  -0.8 1.00e+00 1.00e+00h  1\n 209  3.5549084e+04 1.61e-06 2.11e+00  -4.0 1.95e-03  -1.3 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 210  3.5549084e+04 2.64e-07 9.35e-02  -4.1 4.41e-04  -0.9 1.00e+00 1.00e+00h  1\n 211  3.5549084e+04 1.53e-06 2.03e+00  -4.0 1.98e-03  -1.4 1.00e+00 1.00e+00h  1\n 212  3.5549084e+04 2.86e-07 1.26e-01  -4.1 4.79e-04  -0.9 1.00e+00 1.00e+00h  1\n 213  3.5549084e+04 2.17e-07 1.60e-01  -4.1 1.69e-03  -1.4 1.00e+00 2.50e-01h  3\n 214  3.5549084e+04 4.60e-06 6.15e+00  -4.1 3.18e-03  -1.9 1.00e+00 1.00e+00h  1\n 215  3.5549084e+04 6.77e-08 3.53e-02  -4.1 2.60e-04  -0.6 1.00e+00 1.00e+00h  1\n 216  3.5549084e+04 5.94e-08 4.25e-01  -4.0 6.98e-04  -1.0 1.00e+00 1.25e-01h  4\n 217  3.5549083e+04 1.69e-03 2.76e+03  -3.4 1.13e+00    -  1.00e+00 1.31e-01f  2\n 218  3.5549892e+04 5.79e-05 1.68e+02  -3.5 1.72e-02   2.1 1.00e+00 1.00e+00h  1\n 219  3.5549094e+04 1.21e-07 3.48e+00  -3.5 6.00e-04   1.6 1.00e+00 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 220  3.5549084e+04 1.97e-07 4.12e-01  -3.5 5.65e-04   1.1 1.00e+00 1.00e+00f  1\n 221  3.5549084e+04 5.54e-07 5.62e-01  -3.5 7.20e-04   0.7 1.00e+00 1.00e+00h  1\n 222  3.5549084e+04 1.03e-06 4.82e-01  -3.5 8.43e-04   0.2 1.00e+00 1.00e+00h  1\n 223  3.5549085e+04 9.47e-07 2.95e-01  -3.5 1.10e-03  -0.3 1.00e+00 1.00e+00h  1\n 224  3.5549085e+04 5.81e-07 1.79e-01  -3.5 1.11e-03  -0.8 1.00e+00 5.00e-01h  2\n 225  3.5549084e+04 6.94e-06 1.88e+00  -5.3 2.42e-03  -1.2 8.87e-01 1.00e+00h  1\n 226  3.5549084e+04 7.46e-07 3.65e-01  -5.3 7.49e-04   0.1 1.00e+00 1.00e+00h  1\n 227  3.5549084e+04 6.67e-07 3.31e-01  -5.3 1.28e-03  -0.4 1.00e+00 2.50e-01h  3\n 228  3.5549084e+04 3.60e-06 1.81e+00  -4.0 5.81e-03  -0.9 1.00e+00 3.25e-01h  2\n 229  3.5549084e+04 1.71e-06 1.91e-01  -4.1 1.29e-03  -0.4 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 230  3.5549084e+04 6.30e-07 1.81e-01  -4.1 8.97e-04  -0.9 1.00e+00 1.00e+00h  1\n 231  3.5549084e+04 3.32e-07 1.39e-01  -4.1 1.16e-03  -1.4 1.00e+00 5.00e-01h  2\n 232  3.5549084e+04 2.07e-06 2.37e+00  -4.1 2.47e-03  -1.9 1.00e+00 1.00e+00h  1\n 233  3.5549084e+04 2.86e-08 1.92e-02  -4.1 1.64e-04  -0.5 1.00e+00 1.00e+00h  1\n 234  3.5549084e+04 6.59e-04 6.11e+02  -4.0 7.07e-01    -  5.54e-01 1.14e-01h  4\n 235  3.5550785e+04 4.00e-06 1.85e+01  -4.1 6.31e-03   1.7 1.00e+00 1.00e+00h  1\n 236  3.5549084e+04 2.48e-08 8.29e-01  -4.1 1.75e-04   1.2 1.00e+00 1.00e+00f  1\n 237  3.5549084e+04 3.19e-08 8.63e-02  -4.0 2.12e-04   0.7 1.00e+00 1.00e+00H  1\n 238  3.5549084e+04 6.99e-08 7.33e-02  -4.0 2.46e-04   0.3 1.00e+00 1.00e+00h  1\n 239  3.5549084e+04 3.41e-08 2.91e-02  -4.1 1.81e-04  -0.2 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 240  3.5549084e+04 9.78e-05 1.32e+02  -6.1 2.86e-02    -  8.44e-01 1.00e+00h  1\n 241  3.5549063e+04 4.09e-08 1.31e-01  -6.1 9.18e-04   1.1 1.00e+00 1.00e+00h  1\n 242  3.5549084e+04 3.50e-07 1.58e-01  -4.0 4.83e-04   0.6 1.00e+00 1.00e+00h  1\n 243  3.5549084e+04 1.98e-07 5.93e-02  -4.1 3.91e-04   0.2 1.00e+00 1.00e+00h  1\n 244  3.5549084e+04 4.00e-07 1.04e-01  -4.1 5.45e-04  -0.3 1.00e+00 1.00e+00h  1\n 245  3.5549084e+04 3.21e-07 1.46e-01  -4.1 6.58e-04  -0.8 1.00e+00 1.00e+00h  1\n 246  3.5549084e+04 3.91e-07 1.79e-01  -4.1 8.67e-04  -1.3 1.00e+00 1.00e+00h  1\n 247  3.5549084e+04 2.88e-07 2.82e-01  -4.1 1.51e-03  -1.8 1.00e+00 5.00e-01h  2\n 248  3.5549084e+04 2.29e-07 1.35e-01  -4.1 8.05e-04  -1.3 1.00e+00 1.00e+00h  1\n 249  3.5549084e+04 1.73e-07 1.40e-01  -4.1 1.69e-03  -1.8 1.00e+00 2.50e-01h  3\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 250  3.5549084e+04 3.56e-06 3.88e+00  -4.1 3.88e-03  -2.3 1.00e+00 1.00e+00h  1\n 251  3.5549084e+04 5.93e-09 3.81e-03  -4.1 9.14e-05  -0.0 1.00e+00 1.00e+00h  1\n 252  3.5549084e+04 3.80e-09 7.79e-04  -4.0 3.70e-05   1.3 1.00e+00 1.00e+00h  1\n 253  3.5549083e+04 2.24e-03 2.73e+03  -4.0 3.21e-01    -  1.00e+00 5.00e-01f  2\n 254  3.5574792e+04 3.92e-05 7.51e+02  -4.1 2.35e-02   2.6 1.00e+00 1.00e+00h  1\n 255  3.5549024e+04 4.47e-07 1.33e+02  -4.1 2.60e-03   2.1 1.00e+00 1.00e+00f  1\n 256  3.5549083e+04 2.06e-07 1.37e+01  -4.0 6.66e-04   1.7 1.00e+00 1.00e+00h  1\n 257  3.5549084e+04 1.92e-07 6.86e+00  -4.0 7.31e-04   1.2 1.00e+00 5.00e-01h  2\n 258  3.5549084e+04 1.79e-07 6.00e+00  -4.1 1.17e-03   0.7 1.00e+00 1.25e-01h  4\n 259  3.5549084e+04 1.98e-06 2.64e+00  -4.1 1.59e-03   0.2 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 260  3.5549084e+04 8.65e-07 9.88e-01  -4.1 9.98e-04  -0.3 1.00e+00 1.00e+00h  1\n 261  3.5549084e+04 5.39e-07 4.25e-01  -4.1 8.41e-04  -0.7 1.00e+00 1.00e+00h  1\n 262  3.5549084e+04 2.72e-07 2.63e-01  -4.1 7.61e-04  -1.2 1.00e+00 5.00e-01h  2\n 263  3.5549084e+04 2.06e-07 2.11e-01  -4.1 1.47e-03  -1.7 1.00e+00 2.50e-01h  3\n 264  3.5549084e+04 1.95e-07 1.99e-01  -4.1 2.86e-03  -2.2 1.00e+00 6.25e-02h  5\n 265  3.5549084e+04 1.90e-07 1.93e-01  -4.1 6.01e-03  -2.6 1.00e+00 3.12e-02h  6\n 266  3.5549084e+04 1.89e-07 1.90e-01  -4.1 2.29e-02  -3.1 1.00e+00 1.56e-02h  7\n 267  3.5549084e+04 1.81e-07 1.79e-01  -4.1 5.60e-03  -2.7 1.00e+00 6.25e-02h  5\n 268  3.5549084e+04 7.63e-06 1.87e+01  -4.1 9.11e-03  -3.2 1.00e+00 1.00e+00h  1\n 269  3.5549084e+04 7.99e-09 1.07e-02  -4.1 1.10e-04  -0.0 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 270  3.5549084e+04 1.47e-05 6.71e+00  -6.1 6.20e-03    -  9.02e-01 1.00e+00h  1\n 271  3.5549084e+04 1.38e-07 2.55e-02  -6.1 2.50e-04   0.4 1.00e+00 1.00e+00h  1\n 272  3.5549084e+04 4.21e-07 8.98e-02  -6.1 4.70e-04  -0.1 1.00e+00 1.00e+00h  1\n 273  3.5549084e+04 8.71e-07 1.81e-01  -6.1 6.55e-04  -0.6 1.00e+00 1.00e+00h  1\n 274  3.5549084e+04 5.81e-07 9.47e-02  -6.1 7.83e-04  -1.0 1.00e+00 1.00e+00h  1\n 275  3.5549084e+04 1.45e-07 2.49e-02  -6.1 2.76e-04  -0.6 1.00e+00 1.00e+00h  1\n 276  3.5549084e+04 4.68e-07 1.32e-01  -6.1 7.17e-04  -1.1 1.00e+00 1.00e+00h  1\n 277  3.5549084e+04 2.94e-08 1.06e-02  -6.1 1.57e-04  -0.7 1.00e+00 1.00e+00h  1\n 278  3.5549084e+04 2.19e-07 7.67e-02  -6.1 4.54e-04  -1.1 1.00e+00 1.00e+00h  1\n 279  3.5549084e+04 1.59e-08 5.68e-03  -6.1 1.24e-04  -0.7 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 280  3.5549084e+04 1.29e-07 4.21e-02  -6.1 3.63e-04  -1.2 1.00e+00 1.00e+00h  1\n 281  3.5549084e+04 1.02e-07 5.43e-02  -6.1 1.10e-03  -1.7 1.00e+00 2.50e-01h  3\n 282  3.5549084e+04 7.11e-08 2.45e-02  -6.1 2.87e-04  -1.2 1.00e+00 1.00e+00h  1\n 283  3.5549084e+04 6.17e-08 3.19e-02  -6.1 6.11e-04  -1.7 1.00e+00 2.50e-01h  3\n 284  3.5549084e+04 1.00e-06 5.42e-01  -6.1 1.01e-03  -2.2 1.00e+00 1.00e+00h  1\n 285  3.5549084e+04 3.15e-10 9.79e-05  -6.1 1.72e-05   0.0 1.00e+00 1.00e+00h  1\n 286  3.5549084e+04 6.36e-06 3.25e+00  -4.0 2.44e-02  -0.4 1.00e+00 8.94e-02f  2\n 287  3.5549083e+04 3.24e-05 5.63e+00  -4.1 5.32e-03  -0.9 1.00e+00 1.00e+00h  1\n 288  3.5549084e+04 9.54e-09 2.16e-02  -4.1 1.15e-04   1.3 1.00e+00 1.00e+00h  1\n 289  3.5549084e+04 1.39e-08 1.42e-02  -6.1 9.10e-05   0.8 9.94e-01 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 290  3.5549084e+04 9.10e-08 4.25e-02  -6.1 2.46e-04   0.4 1.00e+00 1.00e+00h  1\n 291  3.5549084e+04 4.03e-07 1.62e-01  -6.1 5.07e-04  -0.1 1.00e+00 1.00e+00h  1\n 292  3.5549084e+04 9.22e-07 2.24e-01  -6.1 6.74e-04  -0.6 1.00e+00 1.00e+00h  1\n 293  3.5549084e+04 6.24e-07 1.46e-01  -6.1 9.06e-04  -1.1 1.00e+00 5.00e-01h  2\n 294  3.5549084e+04 5.37e-07 1.20e-01  -6.1 1.40e-03  -1.5 1.00e+00 2.50e-01h  3\n 295  3.5549084e+04 6.13e-07 8.44e-02  -6.1 6.40e-04  -1.1 1.00e+00 1.00e+00h  1\n 296  3.5549084e+04 7.31e-06 7.28e-01  -6.1 2.29e-02  -1.6 2.59e-01 1.34e-01h  2\n 297  3.5549084e+04 1.94e-09 5.46e-04  -6.1 4.20e-05   0.6 1.00e+00 1.00e+00h  1\n 298  3.5549084e+04 5.11e-10 8.24e-04  -6.1 7.83e-05   0.2 1.00e+00 1.00e+00H  1\n 299  3.5549084e+04 7.05e-10 7.99e-04  -6.1 2.03e-04  -0.3 1.00e+00 1.25e-01h  4\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 300  3.5549084e+04 1.42e-09 1.66e-03  -6.1 5.12e-04  -0.8 1.00e+00 6.25e-02h  5\n\nNumber of Iterations....: 300\n\n                                   (scaled)                 (unscaled)\nObjective...............:   3.5549082958155610e+04    3.5549083903698498e+04\nDual infeasibility......:   1.6582513012297750e-03    1.6582513453363341e-03\nConstraint violation....:   1.4172073514728822e-09    1.4172073514728822e-09\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   8.6874925033843538e-07    8.6874927344563277e-07\nOverall NLP error.......:   9.9397440889016929e-05    1.6582513453363341e-03\n\n\nNumber of objective function evaluations             = 649\nNumber of objective gradient evaluations             = 301\nNumber of equality constraint evaluations            = 649\nNumber of inequality constraint evaluations          = 649\nNumber of equality constraint Jacobian evaluations   = 301\nNumber of inequality constraint Jacobian evaluations = 301\nNumber of Lagrangian Hessian evaluations             = 300\nTotal seconds in IPOPT                               = 1350.214\n\nEXIT: Maximum Number of Iterations Exceeded.\n0.994999990003653 And let's plot this solution plot_unitary_populations(min_time_prob.trajectory) It looks like our pulse derivative bounds are holding back the solution, but regardless, the duration has decreased: duration = get_duration(prob.trajectory)\nmin_time_duration = get_duration(min_time_prob.trajectory)\nprintln(duration, \" - \", min_time_duration, \" = \", duration - min_time_duration) 376.8791029719334 - 355.48583699866776 = 21.393265973265613"},{"id":202,"pagetitle":"Two Qubit Gates","title":"Mølmer–Sørensen gate","ref":"/QuantumCollocation/dev/generated/examples/two_qubit_gates/#Mølmer–Sørensen-gate","content":" Mølmer–Sørensen gate Here we will solve for a  Mølmer–Sørensen gate  between two. The gate is generally described, for N qubits, by the unitary matrix \\[U_{\\text{MS}}(\\vec\\theta) = \\exp\\left(i\\sum_{j=1}^{N-1}\\sum_{k=j+1}^{N}\\theta_{jk}\\sigma_j^x\\sigma_k^x\\right),\\] where  $\\sigma_j^x$  is the Pauli-X operator acting on the  $j$ -th qubit, and  $\\vec\\theta$  is a vector of real parameters. The Mølmer–Sørensen gate is a two-qubit gate that is particularly well-suited for trapped-ion qubits, where the interaction between qubits is mediated. Here we will focus on the simplest case of a Mølmer–Sørensen gate between two qubits. The gate is described by the unitary matrix \\[U_{\\text{MS}}\\left({\\pi \\over 4}\\right) = \\exp\\left(i\\frac{\\pi}{4}\\sigma_1^x\\sigma_2^x\\right).\\] Let's set up the problem. # Define the goal operation\nU_goal = exp(im * π/4 * σx_1 * σx_2)\n\n# Set up and solve the problem\n\nprob = UnitarySmoothPulseProblem(\n    sys,\n    U_goal,\n    T,\n    Δt;\n    a_bound=a_bound,\n    da_bound=da_bound,\n    dda_bound=dda_bound,\n    R_da=0.01,\n    R_dda=0.01,\n    Δt_max=Δt_max,\n    piccolo_options=PiccoloOptions(bound_state=true),\n)\nfid_init = unitary_rollout_fidelity(prob.trajectory, sys)\nprintln(fid_init)\n\nsolve!(prob; max_iter=100)\n\n# Let's take a look at the final fidelity\nfid_final = unitary_rollout_fidelity(prob.trajectory, sys)\nprintln(fid_final)\n@assert fid_final > 0.999     constructing UnitarySmoothPulseProblem...\n\tusing integrator: typeof(UnitaryIntegrator)\n\tcontrol derivative names: [:da, :dda]\n\tapplying timesteps_all_equal constraint: Δt\n0.12249963901581312\n    initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt\n        applying constraint: bounds on Ũ⃗\nThis is Ipopt version 3.14.17, running with linear solver MUMPS 5.8.0.\n\nNumber of nonzeros in equality constraint Jacobian...:   122590\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:    22843\n\nTotal number of variables............................:     4460\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:     4460\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     4059\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  6.5551353e-03 3.93e-01 1.15e+01   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  3.9853177e-01 3.91e-01 6.25e+01  -2.2 1.11e+00    -  3.33e-03 6.19e-03f  1\n   2  3.3701006e-01 3.90e-01 6.25e+01  -2.0 6.43e-01   2.0 1.39e-03 9.63e-04f  1\n   3  1.2521287e-01 3.89e-01 6.23e+01  -1.7 8.11e-01   1.5 3.11e-03 2.31e-03f  1\n   4  1.6534365e+00 3.87e-01 1.29e+01  -1.5 1.81e+00   1.0 4.52e-03 6.77e-03f  1\n   5  9.6768927e-01 3.80e-01 1.65e+01  -1.6 8.61e-01   0.6 3.19e-02 1.65e-02f  1\n   6  6.7886677e-01 3.77e-01 2.35e+02  -1.1 8.20e-01   1.0 6.22e-02 8.54e-03f  1\n   7  1.6085080e+00 3.67e-01 1.97e+02  -0.8 1.36e+00    -  6.14e-02 2.51e-02f  1\n   8  1.1676968e+01 3.45e-01 5.14e+02  -0.4 1.15e+00   0.5 1.71e-01 5.78e-02f  1\n   9  5.5433840e+00 3.18e-01 4.92e+02  -0.5 9.89e-01   0.0 9.48e-02 7.43e-02f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10  3.0213336e+00 2.95e-01 7.60e+02  -0.6 1.11e+00   0.5 1.74e-01 6.89e-02f  1\n  11  2.4771969e+01 2.38e-01 9.53e+02  -0.0 1.43e+00    -  8.72e-02 1.59e-01f  1\n  12  6.6330607e+01 1.32e-01 7.36e+02  -0.3 1.12e+00  -0.0 6.10e-01 4.19e-01f  1\n  13  7.1570805e+01 1.13e-01 2.12e+04   0.3 7.55e-01   1.3 1.00e+00 1.56e-01h  1\n  14  4.7741113e+01 9.96e-02 1.98e+04  -4.0 4.61e+00    -  8.63e-02 1.50e-01h  1\n  15  3.9409563e+01 9.93e-02 1.92e+04  -4.0 1.21e+01    -  5.32e-02 3.82e-02f  1\n  16  3.1762521e+00 7.41e-02 1.18e+04   0.3 1.06e+00    -  3.94e-01 4.12e-01h  1\n  17  2.5010380e+01 6.17e-02 8.45e+04   1.0 1.27e+00   0.8 8.62e-01 1.72e-01f  1\n  18  4.7940418e+01 3.94e-02 6.68e+04   1.2 8.60e-01    -  6.87e-01 4.17e-01f  1\n  19  4.4864153e+01 3.82e-02 5.91e+03   0.8 5.15e-01    -  1.00e+00 8.32e-01h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20  4.6230998e+01 2.65e-03 1.69e+03   0.7 1.38e-01   1.3 1.00e+00 1.00e+00f  1\n  21  3.9972204e+01 1.47e-03 9.56e+03   0.5 1.78e-01   0.8 1.00e+00 7.32e-01f  1\n  22  3.1873298e+01 7.58e-04 3.66e+02  -0.4 8.18e-02   1.2 1.00e+00 1.00e+00f  1\n  23  1.4873981e+01 4.52e-03 6.73e+01  -1.2 2.01e-01   0.7 1.00e+00 1.00e+00f  1\n  24  6.3144129e+00 3.90e-03 2.38e+01  -1.0 1.77e-01   0.3 1.00e+00 1.00e+00f  1\n  25  2.3993619e+00 3.54e-03 7.36e+01  -1.3 2.24e-01  -0.2 9.99e-01 1.00e+00f  1\n  26  1.7540421e+00 7.08e-03 4.15e+02  -1.1 4.21e-01  -0.7 1.00e+00 4.45e-01f  2\n  27  1.2344492e+00 2.78e-04 5.65e+01  -1.7 5.95e-02   0.6 1.00e+00 1.00e+00h  1\n  28  5.8145050e-01 1.90e-04 1.82e+00  -2.7 4.05e-02   0.2 1.00e+00 1.00e+00f  1\n  29  9.5786897e-02 2.35e-03 7.10e+01  -2.8 9.95e-02  -0.3 1.00e+00 9.47e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  30  5.3442397e-02 2.47e-03 7.08e+01  -1.8 3.16e-01  -0.8 3.93e-01 1.18e-01F  1\n  31  8.4109374e-02 3.14e-04 7.00e+01  -2.8 3.94e-02  -0.4 1.00e+00 8.92e-01h  1\n  32  1.0195568e-01 1.08e-03 1.91e+02  -2.6 4.93e-02  -0.8 1.00e+00 1.00e+00f  1\n  33  1.1236283e-01 5.68e-06 1.68e+01  -2.7 5.89e-03   2.3 1.00e+00 1.00e+00h  1\n  34  1.0986622e-01 5.80e-07 1.08e-01  -3.9 1.01e-03   1.8 1.00e+00 1.00e+00h  1\n  35  1.0274369e-01 1.43e-06 3.54e-02  -4.0 1.64e-03   1.3 1.00e+00 1.00e+00f  1\n  36  8.6059279e-02 5.58e-06 3.07e-02  -4.0 3.95e-03   0.9 1.00e+00 1.00e+00f  1\n  37  5.3080859e-02 2.70e-05 3.32e-02  -4.0 8.36e-03   0.4 1.00e+00 1.00e+00f  1\n  38  1.2417213e-02 4.81e-05 3.94e-02  -4.0 1.25e-02  -0.1 1.00e+00 1.00e+00h  1\n  39  5.6492615e-03 3.93e-05 7.07e+01  -4.0 1.21e-02  -0.6 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  40  8.7410342e-03 5.05e-05 7.07e+01  -4.0 9.61e-03  -1.1 1.00e+00 1.00e+00h  1\n  41  1.0831104e-02 3.17e-08 7.67e-01  -4.0 2.02e-04   2.1 1.00e+00 1.00e+00h  1\n  42  1.0566805e-02 9.95e-09 6.46e-03  -4.0 1.59e-04   1.6 1.00e+00 1.00e+00h  1\n  43  9.8083976e-03 6.56e-08 6.13e-03  -4.0 4.54e-04   1.1 1.00e+00 1.00e+00h  1\n  44  7.8873302e-03 3.74e-07 7.15e-03  -4.0 1.18e-03   0.7 1.00e+00 1.00e+00h  1\n  45  4.2034678e-03 1.83e-06 1.10e-02  -4.0 2.57e-03   0.2 1.00e+00 1.00e+00h  1\n  46  4.7320567e-04 3.42e-06 1.34e-02  -4.0 3.92e-03  -0.3 1.00e+00 1.00e+00h  1\n  47  7.1430109e-04 4.58e-06 7.07e+01  -4.0 3.75e-03  -0.8 1.00e+00 1.00e+00h  1\n  48  5.8162765e-04 8.30e-06 7.07e+01  -4.0 4.73e-03  -1.3 1.00e+00 1.00e+00h  1\n  49  6.8081828e-04 3.84e-08 9.22e-01  -4.0 2.25e-04   1.9 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50  6.6993582e-04 4.70e-09 2.31e-03  -4.0 9.12e-05   1.4 1.00e+00 1.00e+00h  1\n  51  6.2323350e-04 5.39e-09 1.35e-03  -4.0 1.28e-04   0.9 1.00e+00 1.00e+00h  1\n  52  5.1175086e-04 2.37e-08 1.89e-03  -4.0 3.26e-04   0.4 1.00e+00 1.00e+00h  1\n  53  3.3461159e-04 7.76e-08 2.59e-03  -4.0 6.46e-04  -0.0 1.00e+00 1.00e+00h  1\n  54  2.4159990e-04 2.06e-07 7.07e+01  -4.0 9.21e-04  -0.5 1.00e+00 1.00e+00h  1\n  55  3.4302308e-04 7.76e-08 7.07e+01  -4.0 2.16e-03  -1.0 1.00e+00 1.00e+00H  1\n  56  3.4015794e-04 2.22e-09 2.01e-01  -4.0 5.36e-05   2.2 1.00e+00 1.00e+00h  1\n  57  3.3782137e-04 5.08e-10 1.37e-03  -4.0 2.90e-05   1.7 1.00e+00 1.00e+00h  1\n  58  3.3140272e-04 8.24e-10 6.16e-04  -4.0 3.90e-05   1.2 1.00e+00 1.00e+00h  1\n  59  3.1517172e-04 4.27e-09 6.89e-04  -4.0 9.23e-05   0.7 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  60  2.8167888e-04 1.21e-08 9.73e-04  -4.0 2.12e-04   0.2 1.00e+00 1.00e+00h  1\n  61  2.4154664e-04 4.61e-08 1.21e-03  -4.0 3.95e-04  -0.2 1.00e+00 1.00e+00h  1\n  62  2.3172028e-04 1.73e-07 7.07e+01  -4.0 8.06e-04  -0.7 1.00e+00 1.00e+00h  1\n  63  2.4446761e-04 7.87e-07 7.07e+01  -4.1 1.63e-03  -1.2 1.00e+00 1.00e+00h  1\n  64  2.4855264e-04 8.12e-09 3.49e-01  -4.1 9.77e-05   1.9 1.00e+00 1.00e+00h  1\n  65  2.4924212e-04 2.84e-10 6.88e-04  -4.0 2.33e-05   1.5 1.00e+00 1.00e+00h  1\n  66  2.4762177e-04 4.20e-10 2.53e-04  -4.0 2.54e-05   1.0 1.00e+00 1.00e+00h  1\n  67  2.4359272e-04 1.50e-09 3.08e-04  -4.0 6.61e-05   0.5 1.00e+00 1.00e+00h  1\n  68  2.3686751e-04 6.74e-09 3.92e-04  -4.0 1.46e-04   0.0 1.00e+00 1.00e+00h  1\n  69  2.3135323e-04 3.62e-08 3.99e-04  -4.0 3.47e-04  -0.4 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  70  2.3016062e-04 2.10e-07 2.33e-04  -4.0 8.56e-04  -0.9 1.00e+00 1.00e+00h  1\n  71  2.2989818e-04 1.30e-06 1.04e-03  -4.0 2.27e-03  -1.4 1.00e+00 1.00e+00h  1\n  72  2.3019328e-04 6.58e-06 6.29e-03  -4.0 5.57e-03  -1.9 1.00e+00 1.00e+00h  1\n  73  2.4810546e-04 2.25e-05 1.75e-02  -4.1 1.03e-02  -2.3 1.00e+00 1.00e+00h  1\n  74  3.6370441e-04 9.41e-05 6.20e-02  -4.1 2.80e-02  -2.8 1.00e+00 1.00e+00h  1\n  75  6.9443899e-04 1.72e-04 1.30e-01  -4.1 4.98e-02  -3.3 1.00e+00 1.00e+00h  1\n  76  2.3870604e-04 9.60e-05 3.48e-02  -4.1 2.18e-02  -2.9 1.00e+00 1.00e+00h  1\n  77  6.5182554e-04 7.10e-05 1.05e-01  -4.1 9.96e-02  -3.4 1.00e+00 1.25e-01h  4\n  78  9.0430436e-04 6.47e-05 2.12e-01  -4.1 1.59e-01  -3.8 1.00e+00 6.25e-02h  5\n  79  1.1327546e-03 5.48e-05 2.15e-01  -4.1 1.68e-01  -4.3 1.00e+00 6.25e-02h  5\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  80  1.2038145e-03 5.17e-05 1.23e-01  -4.1 8.08e-02  -3.9 1.00e+00 6.25e-02h  5\n  81  1.2784639e-03 4.80e-05 2.03e-01  -4.1 1.12e-01  -4.4 1.00e+00 6.25e-02h  5\n  82  1.3133777e-03 4.55e-05 1.21e-01  -4.1 7.68e-02  -3.9 1.00e+00 6.25e-02h  5\n  83  1.3467428e-03 4.27e-05 1.93e-01  -4.1 1.00e-01  -4.4 1.00e+00 6.25e-02h  5\n  84  1.3771788e-03 4.03e-05 1.12e-01  -4.1 7.40e-02  -4.0 1.00e+00 1.25e-01h  4\n  85  6.3489636e-04 7.34e-04 6.05e-01  -4.1 9.10e-02  -4.5 1.00e+00 1.00e+00h  1\n  86  1.6996670e-03 3.26e-05 7.07e+01  -4.1 1.02e-02  -2.2 1.00e+00 1.00e+00h  1\n  87  4.7484927e-04 1.39e-04 7.00e+01  -4.1 4.18e+00    -  1.40e-01 9.75e-03h  5\n  88  4.1954639e-04 1.38e-04 1.53e+00  -4.1 2.23e-01  -1.8 3.50e-01 7.17e-03h  7\n  89  2.3804131e-04 1.37e-04 6.95e+01  -4.1 3.65e+00  -2.3 2.24e-02 1.15e-03h  4\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  90  5.6243076e-04 1.37e-04 1.53e+00  -4.1 2.88e-01  -1.9 3.75e-01 4.85e-03h  6\n  91  7.9913172e-04 2.06e-06 7.07e+01  -4.1 2.37e-03  -1.4 1.00e+00 1.00e+00h  1\n  92  2.1573373e-04 3.99e-06 7.07e+01  -4.1 3.69e-03  -1.9 1.00e+00 1.00e+00h  1\n  93  2.0240183e-04 8.21e-11 4.68e-02  -4.0 1.84e-05   2.1 1.00e+00 1.00e+00h  1\n  94  2.0238466e-04 8.38e-12 1.57e-04  -4.0 3.45e-06   1.7 1.00e+00 1.00e+00h  1\n  95  2.0234024e-04 2.54e-11 1.07e-04  -4.0 7.08e-06   1.2 1.00e+00 1.00e+00h  1\n  96  2.0326731e-04 1.52e-04 3.25e-01  -4.0 6.51e+01    -  4.30e-03 6.14e-04f  4\n  97  2.2294164e-04 2.49e-07 1.24e-02  -4.1 1.38e-03   0.7 1.00e+00 1.00e+00h  1\n  98  2.0884845e-04 2.01e-09 6.24e-04  -4.1 7.07e-05   0.2 1.00e+00 1.00e+00h  1\n  99  2.0529230e-04 4.50e-09 4.00e-04  -6.1 1.34e-04  -0.3 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 100  2.0258741e-04 1.03e-08 4.58e-04  -6.1 2.05e-04  -0.7 1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 100\n\n                                   (scaled)                 (unscaled)\nObjective...............:   2.0258740825686823e-04    2.0258740825686823e-04\nDual infeasibility......:   4.5845084330733792e-04    4.5845084330733792e-04\nConstraint violation....:   1.0251083537582417e-08    1.0251083537582417e-08\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   7.1665900387821498e-07    7.1665900387821498e-07\nOverall NLP error.......:   4.5845084330733792e-04    4.5845084330733792e-04\n\n\nNumber of objective function evaluations             = 174\nNumber of objective gradient evaluations             = 101\nNumber of equality constraint evaluations            = 174\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 101\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 100\nTotal seconds in IPOPT                               = 470.124\n\nEXIT: Maximum Number of Iterations Exceeded.\n0.9999999910296882 Again, looks good! Now let's plot the pulse and the population trajectories for the first two columns of the unitary, i.e. initial state of  $\\ket{00}$  and  $\\ket{01}$ . plot_unitary_populations(prob.trajectory) For fun, let's look at a minimum time pulse for this problem min_time_prob = UnitaryMinimumTimeProblem(prob, U_goal; final_fidelity=.9995)\nsolve!(min_time_prob; max_iter=300)\nfid_final_min_time = unitary_rollout_fidelity(min_time_prob.trajectory, sys)\nprintln(fid_final_min_time)\n@assert fid_final_min_time > 0.999     constructing UnitaryMinimumTimeProblem...\n\tfinal fidelity: 0.9995\n    initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt\n        applying constraint: bounds on Ũ⃗\nThis is Ipopt version 3.14.17, running with linear solver MUMPS 5.8.0.\n\nNumber of nonzeros in equality constraint Jacobian...:    47302\nNumber of nonzeros in inequality constraint Jacobian.:       32\nNumber of nonzeros in Lagrangian Hessian.............:    23371\n\nTotal number of variables............................:     4460\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:     4460\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:     4059\nTotal number of inequality constraints...............:        1\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        1\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  3.0353338e+04 9.81e-03 9.29e+01   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  3.0237292e+04 9.69e-03 2.51e+04   0.1 9.04e-01   2.0 1.00e+00 1.30e-02f  1\n   2  2.5199222e+04 7.75e-03 1.27e+05   0.4 2.56e+00   1.5 1.00e+00 1.99e-01f  1\n   3  2.1022774e+04 7.46e-03 8.33e+05   1.4 7.69e+00    -  1.00e+00 5.49e-02f  1\n   4  1.8463284e+04 5.37e-03 8.44e+04   1.3 2.77e-01    -  1.00e+00 9.86e-01f  1\n   5  1.7116100e+04 3.32e-03 1.99e+05   0.9 2.96e-01   1.9 1.00e+00 4.60e-01f  1\n   6  1.5313319e+04 1.19e-03 2.59e+04   0.4 1.82e-01   2.4 1.00e+00 1.00e+00f  1\n   7  1.4261876e+04 2.90e-03 3.79e+05   1.3 6.01e-01   1.9 1.00e+00 2.62e-01f  1\n   8  1.4295571e+04 2.92e-03 1.23e+06   1.9 1.33e+00    -  1.00e+00 3.53e-01F  1\n   9  1.3148942e+04 1.15e-03 3.04e+04   1.5 1.22e-01    -  1.00e+00 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10  1.2452916e+04 1.74e-04 4.81e+04   0.5 7.03e-02   2.3 1.00e+00 1.00e+00f  1\n  11  1.2373382e+04 7.09e-05 7.06e+04  -0.2 1.34e-02   3.7 1.00e+00 5.98e-01f  1\n  12  1.2087646e+04 1.23e-04 1.57e+04  -0.6 3.55e-02   3.2 1.00e+00 8.12e-01f  1\n  13  1.2068620e+04 1.01e-04 2.97e+04   0.2 2.80e-02   2.7 1.00e+00 9.03e-01f  1\n  14  1.1998575e+04 1.13e-04 1.51e+04  -0.1 3.71e-02   2.2 1.00e+00 1.00e+00f  1\n  15  1.2040931e+04 7.68e-05 2.69e+04  -0.4 3.69e-02   1.7 1.00e+00 5.00e-01h  2\n  16  1.2059835e+04 6.41e-05 3.73e+04  -0.1 5.57e-02   1.3 1.00e+00 2.81e-01h  1\n  17  1.2066513e+04 6.25e-05 3.75e+04  -0.4 1.23e-01    -  1.00e+00 1.25e-01h  4\n  18  1.2080802e+04 5.84e-05 5.48e+04  -1.1 3.03e-02   0.8 5.29e-01 1.22e-01H  1\n  19  1.2128607e+04 3.56e-05 8.75e+03  -1.2 1.73e-02   1.2 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20  1.2124540e+04 3.68e-04 7.67e+03  -0.9 6.36e-02   0.7 1.53e-01 1.16e-01H  1\n  21  1.2132781e+04 8.35e-05 1.34e+03  -1.2 2.07e-02   1.2 1.00e+00 1.00e+00h  1\n  22  1.2133090e+04 7.93e-05 2.11e+03  -1.2 3.98e+00    -  3.59e-02 3.20e-03h  5\n  23  1.2133942e+04 6.78e-05 5.96e+03  -1.2 1.40e-01    -  1.00e+00 1.25e-01h  4\n  24  1.2135623e+04 6.00e-05 1.22e+04  -1.2 9.62e-02    -  1.00e+00 1.25e-01h  4\n  25  1.2137354e+04 4.78e-05 4.23e+03  -1.2 8.25e-02    -  1.00e+00 2.50e-01h  3\n  26  1.2138037e+04 4.75e-05 1.06e+04  -1.2 3.34e-01    -  4.96e-01 4.14e-02h  5\n  27  1.2140391e+04 4.58e-05 6.47e+03  -1.2 5.87e-02    -  1.00e+00 2.50e-01h  3\n  28  1.2141797e+04 3.66e-05 2.98e+03  -1.2 6.12e-02    -  1.00e+00 2.50e-01h  3\n  29  1.2143195e+04 1.63e-05 2.55e+02  -2.3 1.53e-02    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  30  1.2144134e+04 2.80e-08 2.58e+00  -3.9 3.28e-04   0.7 1.00e+00 1.00e+00h  1\n  31  1.2144134e+04 2.81e-08 5.73e+00  -4.0 8.01e-02    -  1.00e+00 4.88e-04h 12\n  32  1.2144134e+04 2.81e-08 9.91e+00  -4.1 1.68e-01    -  1.00e+00 1.22e-04h 14\n  33r 1.2144134e+04 2.81e-08 1.00e+03  -4.1 0.00e+00    -  0.00e+00 3.34e-07R 21\n  34r 1.2144182e+04 1.34e-05 1.15e+01  -4.0 1.03e-02    -  9.88e-01 1.00e+00f  1\n  35r 1.2150639e+04 9.94e-06 2.04e-01  -4.1 4.92e-03   0.0 1.00e+00 1.00e+00h  1\n  36r 1.2221750e+04 7.68e-06 7.40e-01  -4.0 7.18e-03    -  7.60e-01 1.00e+00f  1\n  37r 1.2232040e+04 4.87e-06 8.68e-02  -4.1 3.83e-03  -0.5 1.00e+00 1.00e+00h  1\n  38r 1.2336508e+04 9.65e-06 4.28e-01  -4.0 1.06e-02    -  7.74e-01 1.00e+00f  1\n  39r 1.2342397e+04 6.73e-08 3.53e-03  -4.1 5.95e-04  -1.0 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  40r 1.2499498e+04 5.42e-06 5.87e-03  -4.0 1.59e-02    -  1.00e+00 1.00e+00f  1\n  41r 1.2413984e+04 1.61e-06 3.13e-03  -4.1 8.64e-03    -  1.00e+00 1.00e+00h  1\n  42r 1.2438839e+04 1.27e-07 3.52e-05  -4.1 2.51e-03    -  1.00e+00 1.00e+00h  1\n  43r 1.2201433e+04 1.24e-05 1.10e-01  -6.1 2.40e-02    -  9.68e-01 1.00e+00f  1\n  44r 1.4692124e+04 2.54e-03 4.03e+00  -4.0 2.52e-01    -  1.25e-01 1.00e+00f  1\n  45r 1.4676944e+04 2.03e-03 2.83e+00  -4.3 2.68e-02  -0.5 1.00e+00 2.01e-01h  1\n  46r 1.4639920e+04 1.69e-03 2.39e+00  -4.3 8.02e-02  -1.0 3.26e-01 1.69e-01h  1\n  47r 1.4379092e+04 8.32e-04 1.11e+00  -4.3 4.97e-02  -1.5 1.00e+00 5.30e-01h  1\n  48r 1.3175500e+04 9.71e-04 4.32e-01  -4.3 1.22e-01    -  6.74e-01 1.00e+00h  1\n  49r 1.3159746e+04 7.72e-04 7.16e-01  -4.3 8.76e-03  -1.1 1.00e+00 2.05e-01h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  50r 1.3007514e+04 2.09e-05 2.45e-02  -4.3 1.54e-02  -1.5 1.00e+00 1.00e+00f  1\n  51r 1.2580785e+04 1.35e-04 4.03e-01  -4.3 4.31e-02    -  2.38e-01 1.00e+00h  1\n  52r 1.2565594e+04 7.50e-06 2.92e-02  -4.3 5.81e-03  -1.1 1.00e+00 1.00e+00h  1\n  53r 1.2586111e+04 3.66e-05 2.32e-02  -4.0 1.31e-02    -  1.00e+00 1.00e+00f  1\n  54r 1.2420107e+04 1.53e-05 5.47e-03  -4.1 1.68e-02    -  1.00e+00 1.00e+00h  1\n  55r 1.2438684e+04 3.91e-07 1.30e-04  -4.1 1.88e-03    -  1.00e+00 1.00e+00h  1\n  56r 1.2200683e+04 1.24e-05 1.10e-01  -6.1 2.40e-02    -  9.68e-01 1.00e+00f  1\n  57r 1.2217616e+04 2.83e-07 1.69e-04  -6.1 1.71e-03    -  1.00e+00 1.00e+00h  1\n  58r 1.3547283e+04 9.11e-04 1.60e+00  -4.0 3.13e-01    -  1.01e-01 4.29e-01f  1\n  59r 1.3345503e+04 3.64e-04 4.57e-01  -4.7 3.17e-02  -1.6 1.00e+00 6.42e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  60r 1.2318014e+04 4.39e-04 1.49e-01  -4.7 1.04e-01    -  1.14e-01 1.00e+00f  1\n  61r 1.2312147e+04 2.90e-04 1.13e-01  -4.7 1.17e-01    -  6.46e-01 3.40e-01h  1\n  62r 1.2290455e+04 1.29e-04 2.76e-02  -4.7 3.33e-02    -  8.99e-01 1.00e+00h  1\n  63r 1.2296258e+04 8.17e-05 1.27e-01  -4.7 1.82e-02    -  1.00e+00 3.74e-01h  1\n  64r 1.2306038e+04 1.36e-05 1.06e-02  -4.7 1.05e-02    -  7.84e-01 1.00e+00f  1\n  65r 1.2309482e+04 1.74e-05 1.65e-03  -4.7 7.19e-03    -  1.00e+00 1.00e+00h  1\n  66r 1.2312781e+04 8.28e-07 3.33e-04  -4.7 2.41e-03    -  1.00e+00 1.00e+00h  1\n  67r 1.2846840e+04 7.33e-05 8.18e-02  -4.0 5.39e-02    -  1.00e+00 1.00e+00f  1\n  68r 1.2436655e+04 4.18e-05 1.50e-02  -4.1 4.14e-02    -  1.00e+00 1.00e+00h  1\n  69r 1.2436623e+04 6.73e-07 1.11e-03  -4.1 2.34e-03    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  70r 1.2192352e+04 1.30e-05 1.14e-01  -6.1 2.47e-02    -  9.68e-01 1.00e+00f  1\n  71r 1.2211464e+04 3.17e-07 1.55e-04  -6.1 1.93e-03    -  1.00e+00 1.00e+00h  1\n  72r 1.2194798e+04 1.95e-07 4.90e-05  -6.1 1.68e-03    -  1.00e+00 1.00e+00h  1\n  73r 1.3452915e+04 8.55e-04 3.30e+00  -4.0 4.18e-01    -  1.00e+00 3.04e-01f  1\n  74r 1.2414281e+04 4.51e-04 3.46e-01  -4.3 1.05e-01    -  8.14e-01 1.00e+00f  1\n  75r 1.2388067e+04 2.94e-05 7.22e-03  -4.3 1.46e-02    -  1.00e+00 1.00e+00h  1\n  76r 1.2387857e+04 1.63e-06 1.56e-03  -4.3 3.78e-03    -  1.00e+00 1.00e+00h  1\n  77r 1.2174754e+04 1.21e-05 7.27e-02  -6.4 2.15e-02    -  9.70e-01 1.00e+00f  1\n  78r 1.5502507e+04 4.85e-03 3.51e+00  -4.0 3.98e-01    -  9.09e-02 8.44e-01f  1\n  79r 1.5490449e+04 4.06e-03 2.93e+00  -4.4 4.77e-02  -0.3 1.00e+00 1.64e-01h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  80r 1.5469392e+04 3.68e-03 2.69e+00  -4.4 1.06e-01  -0.7 1.87e-01 9.30e-02h  1\n  81r 1.5362017e+04 2.81e-03 2.02e+00  -4.4 7.13e-02  -1.2 4.41e-01 2.40e-01h  1\n  82r 1.4784669e+04 1.26e-03 7.22e-01  -4.4 9.61e-02  -1.7 8.65e-01 6.07e-01h  1\n  83r 1.3190823e+04 1.75e-03 5.07e-01  -4.4 1.61e-01    -  8.86e-01 1.00e+00h  1\n  84r 1.2642169e+04 2.90e-04 5.96e-01  -4.4 5.54e-02    -  1.74e-01 1.00e+00h  1\n  85r 1.2641429e+04 2.21e-04 4.85e-01  -4.4 4.06e-03  -0.4 1.00e+00 2.37e-01h  1\n  86r 1.2635826e+04 1.18e-04 4.34e-01  -4.4 1.94e-02  -0.8 1.00e+00 4.66e-01f  1\n  87r 1.2353115e+04 1.59e-04 7.99e-02  -4.4 3.27e-02    -  8.23e-01 1.00e+00f  1\n  88r 1.2361333e+04 3.35e-04 6.76e-02  -4.4 5.54e-02    -  1.00e+00 8.03e-01h  1\n  89r 1.2346654e+04 1.41e-04 5.51e-03  -4.4 2.97e-02    -  1.00e+00 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  90r 1.2348463e+04 2.41e-05 8.18e-04  -4.4 9.37e-03    -  1.00e+00 1.00e+00h  1\n  91r 1.2165334e+04 1.07e-05 5.02e-02  -6.6 1.85e-02    -  9.70e-01 1.00e+00f  1\n  92r 1.4648057e+04 3.23e-03 2.15e+00  -4.0 4.98e-01    -  5.19e-02 5.04e-01f  1\n  93r 1.4637167e+04 2.66e-03 1.63e+00  -4.7 2.77e-02  -0.4 1.00e+00 1.77e-01h  1\n  94r 1.4632450e+04 2.50e-03 1.44e+00  -4.7 2.11e-02  -0.9 9.34e-01 5.81e-02h  1\n  95r 1.4556470e+04 1.85e-03 1.12e+00  -4.7 5.60e-02  -1.4 1.00e+00 2.65e-01h  1\n  96r 1.3905072e+04 3.10e-04 1.28e-01  -4.7 6.58e-02  -1.8 1.00e+00 1.00e+00h  1\n  97r 1.3145187e+04 5.82e-04 4.22e-01  -4.7 7.68e-02    -  5.66e-01 1.00e+00h  1\n  98r 1.3049483e+04 3.99e-05 7.94e-02  -4.7 1.29e-02  -1.4 7.67e-01 1.00e+00h  1\n  99r 1.2711309e+04 1.26e-04 4.89e-01  -4.7 3.42e-02    -  1.70e-01 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 100r 1.2699328e+04 6.77e-05 1.01e-01  -4.7 1.63e-02  -1.0 3.13e-01 7.58e-01h  1\n 101r 1.2657796e+04 1.98e-05 8.24e-03  -4.7 6.02e-03  -1.5 1.00e+00 1.00e+00f  1\n 102r 1.2311911e+04 7.92e-05 1.62e-03  -4.7 3.49e-02    -  1.00e+00 1.00e+00h  1\n 103r 1.2311029e+04 3.14e-07 3.15e-04  -4.7 1.46e-03    -  1.00e+00 1.00e+00h  1\n 104r 1.2854935e+04 7.56e-05 8.20e-02  -4.0 5.49e-02    -  1.00e+00 1.00e+00f  1\n 105r 1.2445073e+04 4.04e-05 1.51e-02  -4.1 4.14e-02    -  1.00e+00 1.00e+00h  1\n 106r 1.2436485e+04 5.82e-07 9.67e-04  -4.1 2.11e-03    -  1.00e+00 1.00e+00h  1\n 107r 1.2192713e+04 1.30e-05 1.13e-01  -6.1 2.46e-02    -  9.68e-01 1.00e+00f  1\n 108r 1.2211599e+04 3.16e-07 1.53e-04  -6.1 1.91e-03    -  1.00e+00 1.00e+00h  1\n 109r 1.2194847e+04 1.96e-07 4.92e-05  -6.1 1.69e-03    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 110r 1.2189361e+04 6.86e-09 5.86e-07  -6.1 5.54e-04    -  1.00e+00 1.00e+00h  1\n 111  1.1746695e+04 2.54e-03 1.00e+02  -4.1 4.07e+03    -  2.41e-04 5.15e-05f  1\n 112  1.1015886e+04 2.48e-03 1.00e+02  -2.1 4.19e+03    -  7.20e-05 4.93e-05f  1\n 113  1.0885346e+04 2.48e-03 5.71e+02  -2.1 3.76e+01   0.2 4.14e-02 3.51e-04f  1\n 114  1.0526182e+04 2.46e-03 5.76e+02  -1.4 7.37e+02    -  1.02e-04 4.93e-05f  1\n 115  1.0494464e+04 2.46e-03 5.83e+02  -1.4 6.75e+02    -  8.91e-05 4.75e-06f  1\n 116  9.9763612e+03 2.43e-03 5.95e+02  -1.4 6.32e+02    -  2.16e-04 8.28e-05f  1\n 117  9.1075653e+03 2.57e-03 6.00e+02  -1.3 5.60e+02    -  2.01e-04 1.57e-04f  1\n 118  8.5937241e+03 2.70e-03 6.03e+02  -1.3 4.71e+02    -  1.57e-04 1.10e-04f  1\n 119  8.1889124e+03 2.79e-03 6.06e+02  -1.3 4.11e+02    -  1.49e-04 9.95e-05f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 120  7.8301715e+03 2.88e-03 6.07e+02  -1.3 3.60e+02    -  1.37e-04 1.01e-04f  1\n 121  7.5531146e+03 2.93e-03 6.10e+02  -1.3 3.19e+02    -  1.35e-04 9.17e-05f  1\n 122  7.2890847e+03 2.99e-03 6.12e+02  -1.3 2.82e+02    -  1.46e-04 1.03e-04f  1\n 123  7.1833107e+03 2.99e-03 6.30e+02  -1.3 4.92e+01  -0.3 4.01e-04 2.17e-04f  1\n 124  7.0557825e+03 3.00e-03 6.39e+02  -1.3 7.94e+01  -0.7 2.47e-04 1.62e-04f  1\n 125  6.9438109e+03 3.01e-03 6.44e+02  -1.3 1.28e+02  -1.2 1.56e-04 1.08e-04f  1\n 126  6.8517031e+03 3.02e-03 6.50e+02  -1.3 7.74e+01  -0.8 2.01e-04 1.45e-04f  1\n 127  6.7561679e+03 3.03e-03 6.53e+02  -1.3 1.07e+02  -1.3 1.63e-04 1.29e-04f  1\n 128  6.6786721e+03 3.04e-03 6.59e+02  -1.2 6.46e+01  -0.8 2.26e-04 1.71e-04f  1\n 129  6.6147916e+03 3.04e-03 6.70e+02  -1.2 3.40e+01  -0.4 3.54e-04 2.59e-04f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 130  6.5535990e+03 3.04e-03 6.79e+02  -1.2 3.74e+01  -0.9 3.53e-04 2.66e-04f  1\n 131  6.5069046e+03 3.05e-03 6.94e+02  -1.2 1.72e+01  -0.5 5.63e-04 4.18e-04f  1\n 132  6.4644278e+03 3.05e-03 7.01e+02  -1.2 7.01e+00  -0.0 9.12e-04 8.46e-04f  1\n 133  6.4231574e+03 3.04e-03 6.62e+02  -1.1 2.22e+00   0.4 1.76e-03 2.17e-03f  1\n 134  6.4198591e+03 3.04e-03 6.67e+02  -1.1 9.65e+01  -0.1 3.36e-04 2.59e-04f  1\n 135  6.4065241e+03 3.04e-03 1.25e+03  -4.0 3.62e+00   0.3 9.77e-03 1.43e-03f  1\n 136  6.3748365e+03 3.00e-03 7.08e+04  -1.1 1.13e+00   0.8 1.00e+00 1.36e-02f  1\n 137  6.2329958e+03 2.79e-03 1.28e+05   0.0 9.87e-01   0.3 1.00e+00 9.91e-02f  1\n 138  6.1654245e+03 2.24e-03 9.66e+04  -0.3 6.44e-01   0.7 2.41e-01 2.53e-01f  1\n 139  6.4797081e+03 2.32e-03 1.02e+05   0.8 6.04e-01    -  2.92e-01 2.45e-01f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 140  6.5076341e+03 2.12e-03 5.91e+04  -4.0 7.75e-01   1.1 2.85e-01 2.23e-01h  1\n 141  6.7657700e+03 2.04e-03 6.00e+04   0.6 1.97e+00    -  2.46e-01 1.68e-01f  1\n 142  6.7803141e+03 2.01e-03 5.81e+04   0.2 9.98e-01   1.6 2.07e-02 1.24e-02h  1\n 143  7.0684736e+03 1.50e-03 4.71e+04   0.2 4.62e-01   2.0 3.09e-01 4.64e-01h  1\n 144  7.0694211e+03 1.49e-03 4.63e+04  -4.0 3.23e+00    -  1.48e-02 1.40e-02h  2\n 145  7.1157402e+03 1.52e-03 3.89e+04   0.0 1.68e+00    -  1.03e-01 7.49e-02h  2\n 146  7.2256942e+03 1.40e-03 5.08e+04  -4.0 5.47e-01   2.4 3.47e-02 9.49e-02h  1\n 147  7.3461143e+03 1.35e-03 8.24e+04   1.3 2.77e-01   2.8 6.80e-02 4.40e-02f  1\n 148  7.5180865e+03 1.30e-03 3.71e+05   1.4 3.49e-01    -  2.37e-01 5.29e-02f  1\n 149  7.5203124e+03 1.30e-03 2.13e+05  -0.6 2.15e-01    -  2.10e-01 3.22e-03h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 150  1.0015940e+04 4.65e-03 2.53e+04   1.0 2.52e-01    -  1.00e+00 1.00e+00f  1\n 151  9.9374172e+03 4.66e-04 1.75e+03   0.9 4.47e-02   2.4 1.00e+00 1.00e+00f  1\n 152  1.0883791e+04 1.86e-04 6.72e+03   0.8 1.00e-01    -  7.29e-01 7.08e-01H  1\n 153  1.1535439e+04 1.47e-04 1.55e+04   0.7 6.58e-02   2.8 1.00e+00 1.00e+00h  1\n 154  1.1755673e+04 3.59e-05 3.23e+04  -0.0 2.94e-02   2.3 1.00e+00 7.58e-01h  1\n 155  1.1983545e+04 6.48e-05 2.05e+04  -0.2 2.87e-02   2.7 1.00e+00 8.03e-01h  1\n 156  1.1990878e+04 5.67e-05 2.14e+04  -0.6 1.35e-01    -  1.00e+00 1.25e-01h  4\n 157  1.2098872e+04 9.15e-06 8.43e+03  -4.0 1.30e-02   2.3 5.96e-01 8.41e-01h  1\n 158  1.2139045e+04 1.47e-06 4.12e+03  -3.1 4.28e-03   1.8 8.73e-01 9.49e-01h  1\n 159  1.2139597e+04 1.29e-06 6.70e+03  -2.8 2.40e-02    -  1.00e+00 1.25e-01h  4\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 160  1.2144100e+04 8.53e-07 1.01e+02  -3.1 1.75e-03   1.3 1.00e+00 1.00e+00h  1\n 161  1.2143959e+04 5.18e-03 8.65e+03  -3.7 1.26e-02    -  2.52e-01 7.47e-01H  1\n 162  1.2143506e+04 3.65e-03 6.15e+03  -3.3 7.31e-02   2.6 1.00e+00 2.95e-01h  1\n 163  1.2141907e+04 6.35e-05 6.48e+02  -3.3 5.24e-02   3.1 1.00e+00 1.00e+00f  1\n 164  1.2143363e+04 4.86e-06 2.06e+02  -3.3 5.38e-03    -  1.00e+00 1.00e+00h  1\n 165  1.2144135e+04 6.23e-09 4.72e-01  -3.3 7.80e-05   2.6 1.00e+00 1.00e+00h  1\n 166  1.2144136e+04 4.78e-10 4.63e-02  -4.0 3.49e-05   2.1 1.00e+00 1.00e+00h  1\n 167  1.2144136e+04 1.31e-09 2.27e-03  -4.0 5.39e-05   1.6 1.00e+00 1.00e+00h  1\n 168  1.2144136e+04 4.17e-09 1.37e-03  -4.0 9.70e-05   1.1 1.00e+00 1.00e+00h  1\n 169  1.2144136e+04 1.10e-08 1.92e-03  -4.1 1.66e-04   0.7 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 170  1.2144136e+04 4.53e-12 4.61e-05  -6.1 3.52e-06   0.2 1.00e+00 1.00e+00h  1\n 171  1.2144136e+04 1.58e-06 2.79e-01  -4.0 1.96e-03  -0.3 1.00e+00 1.00e+00f  1\n 172  1.2144136e+04 8.92e-07 1.57e-01  -4.1 1.90e-03  -0.8 1.00e+00 1.00e+00h  1\n 173  1.2144136e+04 1.27e-06 2.23e-01  -4.1 2.69e-03  -1.2 1.00e+00 1.00e+00h  1\n 174  1.2144136e+04 4.13e-07 7.26e-02  -4.1 1.33e-03  -0.8 1.00e+00 1.00e+00h  1\n 175  1.2144136e+04 1.28e-10 4.31e-04  -6.1 3.06e-05  -1.3 1.00e+00 1.00e+00h  1\n 176  1.2144136e+04 4.58e-05 8.04e+00  -4.0 1.53e-02  -1.8 1.00e+00 1.00e+00f  1\n 177  1.2144136e+04 5.91e-08 2.15e-01  -4.1 2.65e-04   1.4 1.00e+00 1.00e+00h  1\n 178  1.2144136e+04 5.85e-04 3.50e+02  -4.1 2.29e-01    -  1.00e+00 5.00e-01h  2\n 179  1.2144054e+04 1.19e-06 8.71e+00  -4.1 1.19e-02   1.8 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 180  1.2144064e+04 1.04e-06 5.21e+01  -4.0 9.36e-03    -  1.00e+00 1.25e-01h  4\n 181  1.2144082e+04 7.94e-07 3.91e+01  -4.0 5.97e-03    -  1.00e+00 2.50e-01h  3\n 182  1.2144095e+04 6.16e-07 2.95e+01  -4.0 4.61e-03    -  1.00e+00 2.50e-01h  3\n 183  1.2144105e+04 5.32e-07 2.22e+01  -4.0 4.72e-03    -  1.00e+00 2.50e-01h  3\n 184  1.2144113e+04 4.44e-07 1.70e+01  -4.1 4.06e-03    -  1.00e+00 2.50e-01h  3\n 185  1.2144136e+04 3.41e-10 3.28e-03  -4.1 2.05e-05   1.3 1.00e+00 1.00e+00h  1\n 186  1.2144136e+04 3.91e-06 6.87e-01  -6.1 1.10e-02    -  9.74e-01 1.00e+00h  1\n 187  1.2144136e+04 2.34e-11 5.62e-04  -6.1 8.12e-05   0.8 1.00e+00 1.00e+00h  1\n 188  1.2144136e+04 3.73e-08 6.57e-03  -4.0 2.16e-04   0.4 1.00e+00 1.00e+00f  1\n 189  1.2144135e+04 5.95e-09 1.78e-03  -4.1 3.59e-05   1.7 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 190  1.2144136e+04 9.12e-14 4.69e-06  -6.1 2.74e-07   1.2 1.00e+00 1.00e+00h  1\n 191  1.2144136e+04 4.79e-08 8.45e-03  -4.0 1.98e-04   0.7 1.00e+00 1.00e+00f  1\n 192  1.2144136e+04 2.04e-08 3.59e-03  -4.1 1.49e-04   0.3 1.00e+00 1.00e+00h  1\n 193  1.2144136e+04 1.88e-12 2.60e-05  -6.1 2.24e-06  -0.2 1.00e+00 1.00e+00h  1\n 194  1.2144136e+04 1.68e-12 4.78e-07  -9.0 2.39e-06  -0.7 1.00e+00 1.00e+00h  1\n 195  1.2144136e+04 3.64e-09 3.36e+00  -4.0 1.12e-01  -1.2 1.00e+00 1.50e-03f  2\n 196  1.2144136e+04 4.79e-04 2.35e+02  -4.1 8.51e-02    -  1.00e+00 1.00e+00f  1\n 197  1.2144087e+04 3.97e-07 3.86e+00  -4.1 7.02e-03   2.0 1.00e+00 1.00e+00h  1\n 198  1.2144135e+04 1.32e-07 3.58e-01  -4.0 7.86e-04    -  1.00e+00 1.00e+00h  1\n 199  1.2144136e+04 5.03e-12 1.03e-04  -4.1 3.36e-06   1.5 1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 200  1.2144136e+04 1.79e-05 3.14e+00  -6.1 2.28e-02    -  9.33e-01 1.00e+00f  1\n 201  1.2144136e+04 1.67e-10 3.61e-03  -6.1 3.53e-04   1.0 1.00e+00 1.00e+00h  1\n 202  1.2144136e+04 6.86e-10 5.47e-04  -4.0 3.83e-05   0.5 1.00e+00 1.00e+00f  1\n 203  1.2144135e+04 9.14e-10 1.17e-03  -4.1 1.60e-05   1.9 1.00e+00 1.00e+00h  1\n 204  1.2144136e+04 9.61e-10 1.13e-03  -4.0 5.82e-06   2.3 1.00e+00 1.00e+00h  1\n 205  1.2144136e+04 1.94e-12 1.16e-04  -4.1 1.79e-06   1.8 1.00e+00 1.00e+00h  1\n 206  1.2144135e+04 9.81e-05 1.99e+01  -6.1 5.24e-02    -  8.52e-01 1.00e+00f  1\n 207  1.2144135e+04 9.88e-09 7.79e-02  -6.1 1.95e-03   1.3 1.00e+00 1.00e+00h  1\n 208  1.2144135e+04 4.95e-09 1.67e+00  -4.0 2.01e-05   0.9 1.00e+00 5.00e-01f  2\n 209  1.2144135e+04 4.94e-09 9.97e-01  -4.1 8.98e-03    -  1.00e+00 9.77e-04h 11\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 210  1.2144135e+04 4.94e-09 9.96e-01  -4.1 9.71e-03    -  1.00e+00 9.77e-04h 11\n 211  1.2144135e+04 4.94e-09 9.95e-01  -4.1 9.69e-03    -  1.00e+00 9.77e-04h 11\n 212  1.2144135e+04 4.94e-09 9.94e-01  -4.1 9.69e-03    -  1.00e+00 9.77e-04h 11\n 213  1.2144135e+04 4.94e-09 9.93e-01  -4.1 9.70e-03    -  1.00e+00 9.77e-04h 11\n 214  1.2144135e+04 4.94e-09 9.92e-01  -4.1 9.70e-03    -  1.00e+00 9.77e-04h 11\n 215  1.2144135e+04 4.93e-09 9.91e-01  -4.1 9.71e-03    -  1.00e+00 9.77e-04h 11\n 216  1.2144135e+04 4.93e-09 9.90e-01  -4.1 9.71e-03    -  1.00e+00 9.77e-04h 11\n 217  1.2144135e+04 4.93e-09 9.89e-01  -4.1 9.71e-03    -  1.00e+00 9.77e-04h 11\n 218  1.2144135e+04 4.93e-09 9.88e-01  -4.1 9.72e-03    -  1.00e+00 9.77e-04h 11\n 219  1.2144135e+04 4.93e-09 9.87e-01  -4.1 9.72e-03    -  1.00e+00 9.77e-04h 11\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 220  1.2144135e+04 4.93e-09 9.86e-01  -4.1 9.73e-03    -  1.00e+00 4.88e-04h 12\n 221  1.2144135e+04 4.92e-09 9.86e-01  -4.1 9.73e-03    -  1.00e+00 4.88e-04h 12\n 222  1.2144135e+04 4.92e-09 9.85e-01  -4.1 9.73e-03    -  1.00e+00 4.88e-04h 12\n 223  1.2144135e+04 4.92e-09 9.85e-01  -4.1 9.73e-03    -  1.00e+00 4.88e-04h 12\n 224  1.2144135e+04 4.92e-09 9.84e-01  -4.1 9.74e-03    -  1.00e+00 4.88e-04h 12\n 225  1.2144135e+04 4.92e-09 9.84e-01  -4.1 9.74e-03    -  1.00e+00 4.88e-04h 12\n 226  1.2144135e+04 4.92e-09 9.83e-01  -4.1 9.74e-03    -  1.00e+00 4.88e-04h 12\n 227  1.2144135e+04 4.91e-09 9.83e-01  -4.1 9.74e-03    -  1.00e+00 4.88e-04h 12\n 228  1.2144135e+04 4.91e-09 9.82e-01  -4.1 9.74e-03    -  1.00e+00 4.88e-04h 12\n 229  1.2144135e+04 4.91e-09 9.82e-01  -4.1 9.75e-03    -  1.00e+00 4.88e-04h 12\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 230  1.2144135e+04 4.91e-09 9.82e-01  -4.1 9.75e-03    -  1.00e+00 4.88e-04h 12\n 231  1.2144135e+04 4.91e-09 9.81e-01  -4.1 9.75e-03    -  1.00e+00 4.88e-04h 12\n 232  1.2144135e+04 4.91e-09 9.81e-01  -4.1 9.75e-03    -  1.00e+00 4.88e-04h 12\n 233  1.2144135e+04 4.90e-09 9.80e-01  -4.1 9.75e-03    -  1.00e+00 4.88e-04h 12\n 234  1.2144135e+04 4.90e-09 9.80e-01  -4.1 9.76e-03    -  1.00e+00 4.88e-04h 12\n 235  1.2144135e+04 4.90e-09 9.79e-01  -4.1 9.76e-03    -  1.00e+00 4.88e-04h 12\n 236  1.2144135e+04 4.90e-09 9.79e-01  -4.1 9.76e-03    -  1.00e+00 4.88e-04h 12\n 237  1.2144135e+04 4.90e-09 9.78e-01  -4.1 9.76e-03    -  1.00e+00 4.88e-04h 12\n 238  1.2144135e+04 4.90e-09 9.78e-01  -4.1 9.77e-03    -  1.00e+00 4.88e-04h 12\n 239  1.2144135e+04 4.90e-09 9.77e-01  -4.1 9.77e-03    -  1.00e+00 4.88e-04h 12\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 240  1.2144135e+04 4.89e-09 9.77e-01  -4.1 9.77e-03    -  1.00e+00 4.88e-04h 12\n 241  1.2144135e+04 4.89e-09 9.76e-01  -4.1 9.77e-03    -  1.00e+00 4.88e-04h 12\n 242  1.2144135e+04 4.89e-09 9.76e-01  -4.1 9.77e-03    -  1.00e+00 4.88e-04h 12\n 243  1.2144135e+04 4.89e-09 9.75e-01  -4.1 9.78e-03    -  1.00e+00 4.88e-04h 12\n 244  1.2144135e+04 4.89e-09 9.75e-01  -4.1 9.78e-03    -  1.00e+00 4.88e-04h 12\n 245  1.2144135e+04 4.89e-09 9.74e-01  -4.1 9.78e-03    -  1.00e+00 4.88e-04h 12\n 246  1.2144135e+04 4.88e-09 9.74e-01  -4.1 9.78e-03    -  1.00e+00 4.88e-04h 12\n 247  1.2144135e+04 4.88e-09 9.73e-01  -4.1 9.79e-03    -  1.00e+00 4.88e-04h 12\n 248  1.2144135e+04 4.88e-09 9.73e-01  -4.1 9.79e-03    -  1.00e+00 4.88e-04h 12\n 249  1.2144135e+04 4.88e-09 9.72e-01  -4.1 9.79e-03    -  1.00e+00 4.88e-04h 12\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 250  1.2144135e+04 4.88e-09 9.72e-01  -4.1 9.79e-03    -  1.00e+00 4.88e-04h 12\n 251  1.2144135e+04 4.88e-09 9.72e-01  -4.1 9.79e-03    -  1.00e+00 4.88e-04h 12\n 252  1.2144135e+04 4.87e-09 9.71e-01  -4.1 9.80e-03    -  1.00e+00 4.88e-04h 12\n 253  1.2144135e+04 4.87e-09 9.71e-01  -4.1 9.80e-03    -  1.00e+00 4.88e-04h 12\n 254  1.2144135e+04 4.87e-09 9.70e-01  -4.1 9.80e-03    -  1.00e+00 4.88e-04h 12\n 255  1.2144135e+04 4.87e-09 9.70e-01  -4.1 9.80e-03    -  1.00e+00 4.88e-04h 12\n 256  1.2144135e+04 4.87e-09 9.69e-01  -4.1 9.81e-03    -  1.00e+00 4.88e-04h 12\n 257  1.2144135e+04 4.87e-09 9.69e-01  -4.1 9.81e-03    -  1.00e+00 4.88e-04h 12\n 258  1.2144135e+04 4.87e-09 9.68e-01  -4.1 9.81e-03    -  1.00e+00 4.88e-04h 12\n 259  1.2144135e+04 4.86e-09 9.68e-01  -4.1 9.81e-03    -  1.00e+00 4.88e-04h 12\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 260  1.2144135e+04 4.86e-09 9.67e-01  -4.1 9.81e-03    -  1.00e+00 4.88e-04h 12\n 261  1.2144135e+04 4.86e-09 9.67e-01  -4.1 9.82e-03    -  1.00e+00 4.88e-04h 12\n 262  1.2144135e+04 4.86e-09 9.66e-01  -4.1 9.82e-03    -  1.00e+00 4.88e-04h 12\n 263  1.2144135e+04 4.86e-09 9.66e-01  -4.1 9.82e-03    -  1.00e+00 4.88e-04h 12\n 264  1.2144135e+04 4.86e-09 9.65e-01  -4.1 9.82e-03    -  1.00e+00 4.88e-04h 12\n 265  1.2144135e+04 4.85e-09 9.65e-01  -4.1 9.83e-03    -  1.00e+00 4.88e-04h 12\n 266  1.2144135e+04 4.85e-09 9.64e-01  -4.1 9.83e-03    -  1.00e+00 4.88e-04h 12\n 267  1.2144135e+04 4.85e-09 9.64e-01  -4.1 9.83e-03    -  1.00e+00 4.88e-04h 12\n 268  1.2144135e+04 4.85e-09 9.63e-01  -4.1 9.83e-03    -  1.00e+00 4.88e-04h 12\n 269  1.2144135e+04 4.85e-09 9.63e-01  -4.1 9.83e-03    -  1.00e+00 4.88e-04h 12\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 270  1.2144135e+04 4.85e-09 9.63e-01  -4.1 9.84e-03    -  1.00e+00 4.88e-04h 12\n 271  1.2144135e+04 4.84e-09 9.62e-01  -4.1 9.84e-03    -  1.00e+00 4.88e-04h 12\n 272  1.2144135e+04 4.84e-09 9.62e-01  -4.1 9.84e-03    -  1.00e+00 4.88e-04h 12\n 273  1.2144135e+04 4.84e-09 9.61e-01  -4.1 9.84e-03    -  1.00e+00 4.88e-04h 12\n 274  1.2144135e+04 4.84e-09 9.61e-01  -4.1 9.85e-03    -  1.00e+00 4.88e-04h 12\n 275  1.2144135e+04 4.84e-09 9.60e-01  -4.1 9.85e-03    -  1.00e+00 4.88e-04h 12\n 276  1.2144135e+04 4.84e-09 9.60e-01  -4.1 9.85e-03    -  1.00e+00 4.88e-04h 12\n 277  1.2144135e+04 4.84e-09 9.59e-01  -4.1 9.85e-03    -  1.00e+00 4.88e-04h 12\n 278  1.2144135e+04 4.83e-09 9.59e-01  -4.1 9.85e-03    -  1.00e+00 4.88e-04h 12\n 279  1.2144135e+04 4.83e-09 9.58e-01  -4.1 9.86e-03    -  1.00e+00 4.88e-04h 12\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 280  1.2144135e+04 4.83e-09 9.58e-01  -4.1 9.86e-03    -  1.00e+00 4.88e-04h 12\n 281  1.2144135e+04 4.83e-09 9.57e-01  -4.1 9.86e-03    -  1.00e+00 4.88e-04h 12\n 282  1.2144135e+04 4.83e-09 9.57e-01  -4.1 9.86e-03    -  1.00e+00 4.88e-04h 12\n 283  1.2144135e+04 4.83e-09 9.56e-01  -4.1 9.87e-03    -  1.00e+00 4.88e-04h 12\n 284  1.2144135e+04 4.82e-09 9.56e-01  -4.1 9.87e-03    -  1.00e+00 4.88e-04h 12\n 285  1.2144135e+04 4.82e-09 9.56e-01  -4.1 9.87e-03    -  1.00e+00 4.88e-04h 12\n 286  1.2144135e+04 4.82e-09 9.55e-01  -4.1 9.87e-03    -  1.00e+00 4.88e-04h 12\n 287  1.2144135e+04 4.82e-09 9.55e-01  -4.1 9.87e-03    -  1.00e+00 4.88e-04h 12\n 288  1.2144135e+04 4.82e-09 9.54e-01  -4.1 9.88e-03    -  1.00e+00 4.88e-04h 12\n 289  1.2144135e+04 4.82e-09 9.54e-01  -4.1 9.88e-03    -  1.00e+00 4.88e-04h 12\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 290  1.2144135e+04 4.82e-09 9.53e-01  -4.1 9.88e-03    -  1.00e+00 4.88e-04h 12\n 291  1.2144135e+04 4.81e-09 9.53e-01  -4.1 9.88e-03    -  1.00e+00 4.88e-04h 12\n 292  1.2144135e+04 4.81e-09 9.52e-01  -4.1 9.89e-03    -  1.00e+00 4.88e-04h 12\n 293  1.2144135e+04 4.81e-09 9.52e-01  -4.1 9.89e-03    -  1.00e+00 4.88e-04h 12\n 294  1.2144135e+04 4.81e-09 9.51e-01  -4.1 9.89e-03    -  1.00e+00 4.88e-04h 12\n 295  1.2144135e+04 4.81e-09 9.51e-01  -4.1 9.89e-03    -  1.00e+00 4.88e-04h 12\n 296  1.2144135e+04 4.81e-09 9.50e-01  -4.1 9.89e-03    -  1.00e+00 4.88e-04h 12\n 297  1.2144135e+04 4.80e-09 9.50e-01  -4.1 9.90e-03    -  1.00e+00 4.88e-04h 12\n 298  1.2144135e+04 4.80e-09 9.49e-01  -4.1 9.90e-03    -  1.00e+00 4.88e-04h 12\n 299  1.2144135e+04 4.80e-09 9.49e-01  -4.1 9.90e-03    -  1.00e+00 4.88e-04h 12\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n 300  1.2144135e+04 4.80e-09 9.49e-01  -4.1 9.90e-03    -  1.00e+00 4.88e-04h 12\n\nNumber of Iterations....: 300\n\n                                   (scaled)                 (unscaled)\nObjective...............:   1.2144134922416484e+04    1.2144135231462720e+04\nDual infeasibility......:   9.4854465918564723e-01    9.4854468332439068e-01\nConstraint violation....:   4.7996074198364269e-09    4.7996074198364269e-09\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   9.0327691330231130e-05    9.0327693628907259e-05\nOverall NLP error.......:   8.9922045538981081e-03    9.4854468332439068e-01\n\n\nNumber of objective function evaluations             = 1522\nNumber of objective gradient evaluations             = 225\nNumber of equality constraint evaluations            = 1522\nNumber of inequality constraint evaluations          = 1522\nNumber of equality constraint Jacobian evaluations   = 302\nNumber of inequality constraint Jacobian evaluations = 302\nNumber of Lagrangian Hessian evaluations             = 300\nTotal seconds in IPOPT                               = 1140.993\n\nEXIT: Maximum Number of Iterations Exceeded.\n0.9994999891424442 And let's plot this solution plot_unitary_populations(min_time_prob.trajectory) It looks like our pulse derivative bounds are holding back the solution, but regardless, the duration has decreased: duration = get_duration(prob.trajectory)\nmin_time_duration = get_duration(min_time_prob.trajectory)\nprintln(duration, \" - \", min_time_duration, \" = \", duration - min_time_duration) 303.5333816974719 - 121.44085199897336 = 182.09252969849854 This page was generated using  Literate.jl ."},{"id":205,"pagetitle":"Ket Problem Templates","title":"Quantum State Smooth Pulse Problem","ref":"/QuantumCollocation/dev/generated/man/ket_problem_templates/#Quantum-State-Smooth-Pulse-Problem","content":" Quantum State Smooth Pulse Problem"},{"id":206,"pagetitle":"Ket Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","ref":"/QuantumCollocation/dev/generated/man/ket_problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem-generated-man-ket_problem_templates","content":" QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem  —  Function QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...) Create a quantum state smooth pulse problem. The goal is to find a control pulse  a(t)   that drives all of the initial states  ψ_inits  to the corresponding target states   ψ_goals  using  T  timesteps of size  Δt . This problem also controls the  first and  second derivatives of the control pulse,  da(t)  and  dda(t) , to ensure smoothness. Arguments system::AbstractQuantumSystem : The quantum system. or H_drift::AbstractMatrix{<:Number} : The drift Hamiltonian. H_drives::Vector{<:AbstractMatrix{<:Number}} : The control Hamiltonians. with ψ_inits::Vector{<:AbstractVector{<:ComplexF64}} : The initial states. ψ_goals::Vector{<:AbstractVector{<:ComplexF64}} : The target states. or ψ_init::AbstractVector{<:ComplexF64} : The initial state. ψ_goal::AbstractVector{<:ComplexF64} : The target state. with T::Int : The number of timesteps. Δt::Float64 : The timestep size. Keyword Arguments state_name::Symbol=:ψ̃ : The name of the state variable. control_name::Symbol=:a : The name of the control variable. timestep_name::Symbol=:Δt : The name of the timestep variable. init_trajectory::Union{NamedTrajectory, Nothing}=nothing : The initial trajectory. a_bound::Float64=1.0 : The bound on the control pulse. a_bounds=fill(a_bound, length(system.G_drives)) : The bounds on the control pulse. a_guess::Union{Matrix{Float64}, Nothing}=nothing : The initial guess for the control pulse. da_bound::Float64=Inf : The bound on the first derivative of the control pulse. da_bounds=fill(da_bound, length(system.G_drives)) : The bounds on the first derivative of the control pulse. dda_bound::Float64=1.0 : The bound on the second derivative of the control pulse. dda_bounds=fill(dda_bound, length(system.G_drives)) : The bounds on the second derivative of the control pulse. Δt_min::Float64=0.5 * Δt : The minimum timestep size. Δt_max::Float64=1.5 * Δt : The maximum timestep size. drive_derivative_σ::Float64=0.01 : The standard deviation of the drive derivative random initialization. Q::Float64=100.0 : The weight on the state objective. R=1e-2 : The weight on the control pulse and its derivatives. R_a::Union{Float64, Vector{Float64}}=R : The weight on the control pulse. R_da::Union{Float64, Vector{Float64}}=R : The weight on the first derivative of the control pulse. R_dda::Union{Float64, Vector{Float64}}=R : The weight on the second derivative of the control pulse. constraints::Vector{<:AbstractConstraint}=AbstractConstraint[] : The constraints. piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. source Each problem starts with a  QuantumSystem  object, which is used to define the system's Hamiltonian and control operators. The goal is to find a control pulse that drives the intial state,  ψ_init , to a target state,  ψ_goal . define the quantum system system = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y])\nψ_init = Vector{ComplexF64}([1.0, 0.0])\nψ_goal = Vector{ComplexF64}([0.0, 1.0])\nT = 51\nΔt = 0.2 0.2 create the smooth pulse problem state_prob = QuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt);     constructing QuantumStateSmoothPulseProblem...\n\tusing integrator: typeof(KetIntegrator)\n\tusing 1 initial state(s)\n\tapplying timesteps_all_equal constraint: Δt check the fidelity before solving println(\"Before: \", rollout_fidelity(state_prob.trajectory, system)) Before: 0.5161226073103974 solve the problem solve!(state_prob, max_iter=100, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of ψ̃\n        applying constraint: initial value of a\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt check the fidelity after solving println(\"After: \", rollout_fidelity(state_prob.trajectory, system)) After: 0.9999999993681593 extract the control pulses state_prob.trajectory.a |> size (2, 51)"},{"id":207,"pagetitle":"Ket Problem Templates","title":"Quantum State Minimum Time Problem","ref":"/QuantumCollocation/dev/generated/man/ket_problem_templates/#Quantum-State-Minimum-Time-Problem","content":" Quantum State Minimum Time Problem"},{"id":208,"pagetitle":"Ket Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","ref":"/QuantumCollocation/dev/generated/man/ket_problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem-generated-man-ket_problem_templates","content":" QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem  —  Function QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)\nQuantumStateMinimumTimeProblem(prob; kwargs...) Construct a  DirectTrajOptProblem  for the minimum time problem of reaching a target state. Keyword Arguments state_name::Symbol=:ψ̃ : The symbol for the state variables. final_fidelity::Union{Real, Nothing}=nothing : The final fidelity. D=1.0 : The cost weight on the time. piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. source create the minimum time problem min_state_prob = QuantumStateMinimumTimeProblem(state_prob, ψ_goal);     constructing QuantumStateMinimumTimeProblem...\n\tfinal fidelity: 1.0 check the previous duration println(\"Duration before: \", get_duration(state_prob.trajectory)) Duration before: 16.14558656401188 solve the minimum time problem solve!(min_state_prob, max_iter=100, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of ψ̃\n        applying constraint: initial value of a\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt check the new duration println(\"Duration after: \", get_duration(min_state_prob.trajectory)) Duration after: 5.000081100839626 the fidelity is preserved by a constraint println(\"Fidelity after: \", rollout_fidelity(min_state_prob.trajectory, system)) Fidelity after: 0.9999999999998666"},{"id":209,"pagetitle":"Ket Problem Templates","title":"Quantum State Sampling Problem","ref":"/QuantumCollocation/dev/generated/man/ket_problem_templates/#Quantum-State-Sampling-Problem","content":" Quantum State Sampling Problem"},{"id":210,"pagetitle":"Ket Problem Templates","title":"QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","ref":"/QuantumCollocation/dev/generated/man/ket_problem_templates/#QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem-generated-man-ket_problem_templates","content":" QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem  —  Function source create a sampling problem driftless_system = QuantumSystem([PAULIS.X, PAULIS.Y])\nsampling_state_prob = QuantumStateSamplingProblem([system, driftless_system], ψ_init, ψ_goal, T, Δt);     constructing QuantumStateSamplingProblem...\n\tusing integrator: typeof(KetIntegrator)\n\tusing 2 initial state(s)\n\tapplying timesteps_all_equal constraint: Δt new keys are added to the trajectory for the new states println(sampling_state_prob.trajectory.state_names) (:ψ̃1_system_1, :a, :da, :ψ̃1_system_2) solve the sampling problem for a few iterations solve!(sampling_state_prob, max_iter=25, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of ψ̃1_system_1\n        applying constraint: initial value of a\n        applying constraint: initial value of ψ̃1_system_2\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt check the fidelity of the sampling problem (use the updated key to get the initial and goal) println(\"After (original system): \", rollout_fidelity(sampling_state_prob.trajectory, system, state_name=:ψ̃1_system_1))\nprintln(\"After (new system): \", rollout_fidelity(sampling_state_prob.trajectory, driftless_system, state_name=:ψ̃1_system_1)) After (original system): 0.9860366011302286\nAfter (new system): 0.9872533871413639 compare this to using the original problem on the new system println(\"After (new system, original `prob`): \", rollout_fidelity(state_prob.trajectory, driftless_system)) After (new system, original `prob`): 0.9504227599183703 This page was generated using  Literate.jl ."},{"id":213,"pagetitle":"Unitary Problem Templates","title":"Unitary Smooth Pulse Problem","ref":"/QuantumCollocation/dev/generated/man/unitary_problem_templates/#Unitary-Smooth-Pulse-Problem","content":" Unitary Smooth Pulse Problem"},{"id":214,"pagetitle":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","ref":"/QuantumCollocation/dev/generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-generated-man-unitary_problem_templates","content":" QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem  —  Function UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator::AbstractPiccoloOperator, T::Int, Δt::Float64; kwargs...)\nUnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...) Construct a  DirectTrajOptProblem  for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e., \\[\\begin{aligned}\n\\underset{\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}, \\Delta t}{\\text{minimize}} & \\quad\nQ \\cdot \\ell\\qty(\\vec{\\tilde{U}}_T, \\vec{\\tilde{U}}_{\\text{goal}}) + \\frac{1}{2} \\sum_t \\qty(R_a a_t^2 + R_{\\dot{a}} \\dot{a}_t^2 + R_{\\ddot{a}} \\ddot{a}_t^2) \\\\\n\\text{ subject to } & \\quad \\vb{P}^{(n)}\\qty(\\vec{\\tilde{U}}_{t+1}, \\vec{\\tilde{U}}_t, a_t, \\Delta t_t) = 0 \\\\\n& \\quad a_{t+1} - a_t - \\dot{a}_t \\Delta t_t = 0 \\\\\n& \\quad \\dot{a}_{t+1} - \\dot{a}_t - \\ddot{a}_t \\Delta t_t = 0 \\\\\n& \\quad |a_t| \\leq a_{\\text{bound}} \\\\\n& \\quad |\\ddot{a}_t| \\leq \\ddot{a}_{\\text{bound}} \\\\\n& \\quad \\Delta t_{\\text{min}} \\leq \\Delta t_t \\leq \\Delta t_{\\text{max}} \\\\\n\\end{aligned}\\] where, for  $U \\in SU(N)$ , \\[\\ell\\qty(\\vec{\\tilde{U}}_T, \\vec{\\tilde{U}}_{\\text{goal}}) =\n\\abs{1 - \\frac{1}{N} \\abs{ \\tr \\qty(U_{\\text{goal}}, U_T)} }\\] is the  infidelity  objective function,  $Q$  is a weight,  $R_a$ ,  $R_{\\dot{a}}$ , and  $R_{\\ddot{a}}$  are weights on the regularization terms, and  $\\vb{P}^{(n)}$  is the  $n$ th-order Pade integrator. Arguments system::AbstractQuantumSystem : the system to be controlled or H_drift::AbstractMatrix{<:Number} : the drift hamiltonian H_drives::Vector{<:AbstractMatrix{<:Number}} : the control hamiltonians with goal::AbstractPiccoloOperator : the target unitary, either in the form of an  EmbeddedOperator  or a `Matrix{ComplexF64} T::Int : the number of timesteps Δt::Float64 : the (initial) time step size Keyword Arguments piccolo_options::PiccoloOptions=PiccoloOptions() : the options for the Piccolo solver state_name::Symbol = :Ũ⃗ : the name of the state control_name::Symbol = :a : the name of the control timestep_name::Symbol = :Δt : the name of the timestep init_trajectory::Union{NamedTrajectory, Nothing}=nothing : an initial trajectory to use a_guess::Union{Matrix{Float64}, Nothing}=nothing : an initial guess for the control pulses a_bound::Float64=1.0 : the bound on the control pulse a_bounds=fill(a_bound, length(system.G_drives)) : the bounds on the control pulses, one for each drive da_bound::Float64=Inf : the bound on the control pulse derivative da_bounds=fill(da_bound, length(system.G_drives)) : the bounds on the control pulse derivatives, one for each drive dda_bound::Float64=1.0 : the bound on the control pulse second derivative dda_bounds=fill(dda_bound, length(system.G_drives)) : the bounds on the control pulse second derivatives, one for each drive Δt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt) : the minimum time step size Δt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt) : the maximum time step size Q::Float64=100.0 : the weight on the infidelity objective R=1e-2 : the weight on the regularization terms R_a::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulses R_da::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulse derivatives R_dda::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulse second derivatives constraints::Vector{<:AbstractConstraint}=AbstractConstraint[] : the constraints to enforce source The  UnitarySmoothPulseProblem  is similar to the  QuantumStateSmoothPulseProblem , but instead of driving the system to a target state, the goal is to drive the system to a target unitary operator,  U_goal . system = QuantumSystem(0.1 * PAULIS.Z, [PAULIS.X, PAULIS.Y])\nU_goal = GATES.H\nT = 51\nΔt = 0.2\n\nprob = UnitarySmoothPulseProblem(system, U_goal, T, Δt);     constructing UnitarySmoothPulseProblem...\n\tusing integrator: typeof(UnitaryIntegrator)\n\tcontrol derivative names: [:da, :dda]\n\tapplying timesteps_all_equal constraint: Δt check the fidelity before solving println(\"Before: \", unitary_rollout_fidelity(prob.trajectory, system)) Before: 0.10875486189665566 finding an optimal control is as simple as calling  solve! solve!(prob, max_iter=100, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt check the fidelity after solving println(\"After: \", unitary_rollout_fidelity(prob.trajectory, system)) After: 0.9999999980012491 The  NamedTrajectory  object stores the control pulse, state variables, and the time grid. extract the control pulses prob.trajectory.a |> size (2, 51)"},{"id":215,"pagetitle":"Unitary Problem Templates","title":"Unitary Minimum Time Problem","ref":"/QuantumCollocation/dev/generated/man/unitary_problem_templates/#Unitary-Minimum-Time-Problem","content":" Unitary Minimum Time Problem"},{"id":216,"pagetitle":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","ref":"/QuantumCollocation/dev/generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem-generated-man-unitary_problem_templates","content":" QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem  —  Function UnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    trajectory::NamedTrajectory,\n    objective::Objective,\n    dynamics::TrajectoryDynamics,\n    constraints::AbstractVector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    prob::DirectTrajOptProblem;\n    kwargs...\n) Create a minimum-time problem for unitary control. \\[\\begin{aligned}\n\\underset{\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}, \\Delta t}{\\text{minimize}} & \\quad\nJ(\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}) + D \\sum_t \\Delta t_t \\\\\n\\text{ subject to } & \\quad \\vb{P}^{(n)}\\qty(\\vec{\\tilde{U}}_{t+1}, \\vec{\\tilde{U}}_t, a_t, \\Delta t_t) = 0 \\\\\n& c(\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}) = 0 \\\\\n& \\quad \\Delta t_{\\text{min}} \\leq \\Delta t_t \\leq \\Delta t_{\\text{max}} \\\\\n\\end{aligned}\\] Keyword Arguments piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. unitary_name::Symbol=:Ũ⃗ : The name of the unitary for the goal. final_fidelity::Float64=1.0 : The final fidelity constraint. D::Float64=1.0 : The scaling factor for the minimum-time objective. source The goal of this problem is to find the shortest time it takes to drive the system to a target unitary operator,  U_goal . The problem is solved by minimizing the sum of all of the time steps. It is constructed from  prob  in the previous example. min_prob = UnitaryMinimumTimeProblem(prob, U_goal);     constructing UnitaryMinimumTimeProblem...\n\tfinal fidelity: 1.0 check the previous duration println(\"Duration before: \", get_duration(prob.trajectory)) Duration before: 14.615058523313166 solve the minimum time problem solve!(min_prob, max_iter=100, verbose=true, print_level=1);     initializing optimizer...\n        applying constraint: timesteps all equal constraint\n        applying constraint: initial value of Ũ⃗\n        applying constraint: initial value of a\n        applying constraint: final value of a\n        applying constraint: bounds on a\n        applying constraint: bounds on da\n        applying constraint: bounds on dda\n        applying constraint: bounds on Δt check the new duration println(\"Duration after: \", get_duration(min_prob.trajectory)) Duration after: 5.0000403057272695 the fidelity is preserved by a constraint println(\"Fidelity after: \", unitary_rollout_fidelity(min_prob.trajectory, system)) Fidelity after: 0.9999999991345043"},{"id":217,"pagetitle":"Unitary Problem Templates","title":"Unitary Sampling Problem","ref":"/QuantumCollocation/dev/generated/man/unitary_problem_templates/#Unitary-Sampling-Problem","content":" Unitary Sampling Problem"},{"id":218,"pagetitle":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySamplingProblem","ref":"/QuantumCollocation/dev/generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-generated-man-unitary_problem_templates","content":" QuantumCollocation.ProblemTemplates.UnitarySamplingProblem  —  Function UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...) A  UnitarySamplingProblem  is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control  pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty. Arguments systems::AbstractVector{<:AbstractQuantumSystem} : A vector of quantum systems. operators::AbstractVector{<:AbstractPiccoloOperator} : A vector of target operators. T::Int : The number of time steps. Δt::Union{Float64, Vector{Float64}} : The time step value or vector of time steps. Keyword Arguments system_labels::Vector{String} = string.(1:length(systems)) : The labels for each system. system_weights::Vector{Float64} = fill(1.0, length(systems)) : The weights for each system. init_trajectory::Union{NamedTrajectory, Nothing} = nothing : The initial trajectory. state_name::Symbol = :Ũ⃗ : The name of the state variable. control_name::Symbol = :a : The name of the control variable. timestep_name::Symbol = :Δt : The name of the timestep variable. constraints::Vector{<:AbstractConstraint} = AbstractConstraint[] : The constraints. a_bound::Float64 = 1.0 : The bound for the control amplitudes. a_bounds = fill(a_bound, length(systems[1].G_drives)) : The bounds for the control amplitudes. a_guess::Union{Matrix{Float64}, Nothing} = nothing : The initial guess for the control amplitudes. da_bound::Float64 = Inf : The bound for the control first derivatives. da_bounds = fill(da_bound, length(systems[1].G_drives)) : The bounds for the control first derivatives. dda_bound::Float64 = 1.0 : The bound for the control second derivatives. dda_bounds = fill(dda_bound, length(systems[1].G_drives)) : The bounds for the control second derivatives. Δt_min::Float64 = 0.5 * Δt : The minimum time step size. Δt_max::Float64 = 1.5 * Δt : The maximum time step size. Q::Float64 = 100.0 : The fidelity weight. R::Float64 = 1e-2 : The regularization weight. R_a::Union{Float64, Vector{Float64}} = R : The regularization weight for the control amplitudes. R_da::Union{Float64, Vector{Float64}} = R : The regularization weight for the control first derivatives. R_dda::Union{Float64, Vector{Float64}} = R : The regularization weight for the control second derivatives. piccolo_options::PiccoloOptions = PiccoloOptions() : The Piccolo options. source A sampling problem is used to solve over multiple quantum systems with the same control. This can be useful for exploring robustness, for example. create a sampling problem driftless_system = QuantumSystem([PAULIS.X, PAULIS.Y])\nsampling_prob = UnitarySamplingProblem([system, driftless_system], U_goal, T, Δt);     constructing UnitarySamplingProblem...\n\tusing integrator: typeof(UnitaryIntegrator)\n\tusing 2 systems\n\tapplying timesteps_all_equal constraint: Δt new keys are addded to the trajectory for the new states println(sampling_prob.trajectory.state_names) (:Ũ⃗_system_1, :a, :da, :Ũ⃗_system_2) the  solve!  proceeds as in the  Quantum State Sampling Problem ]"},{"id":219,"pagetitle":"Unitary Problem Templates","title":"Unitary Variational Problem","ref":"/QuantumCollocation/dev/generated/man/unitary_problem_templates/#Unitary-Variational-Problem","content":" Unitary Variational Problem"},{"id":220,"pagetitle":"Unitary Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem","ref":"/QuantumCollocation/dev/generated/man/unitary_problem_templates/#QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem-generated-man-unitary_problem_templates","content":" QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem  —  Function UnitaryVariationalProblem(\n    system::VariationalQuantumSystem,\n    goal::AbstractPiccoloOperator,\n    T::Int,\n    Δt::Union{Float64, <:AbstractVector{Float64}};\n    robust_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    sensitive_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    kwargs...\n) Constructs a unitary variational problem for optimizing quantum control trajectories. Arguments system::VariationalQuantumSystem : The quantum system to be controlled, containing variational parameters. goal::AbstractPiccoloOperator : The target operator or state to achieve at the end of the trajectory. T::Int : The total number of timesteps in the trajectory. Δt::Union{Float64, <:AbstractVector{Float64}} : The timestep duration or a vector of timestep durations. Keyword Arguments robust_times::AbstractVector : Times at which robustness to variations in the trajectory is enforced. sensitive_times::AbstractVector : Times at which sensitivity to variations in the trajectory is enhanced. unitary_integrator : The integrator used for unitary evolution (default:  VariationalUnitaryIntegrator ). state_name::Symbol : The name of the state variable in the trajectory (default:  :Ũ⃗ ). variational_state_name::Symbol : The name of the variational state variable (default:  :Ũ⃗ₐ ). variational_scales::AbstractVector : Scaling factors for the variational state variables (default:  1.0 ). control_name::Symbol : The name of the control variable (default:  :a ). timestep_name::Symbol : The name of the timestep variable (default:  :Δt ). init_trajectory::Union{NamedTrajectory, Nothing} : An optional initial trajectory to start optimization. a_bound::Float64 : The bound for the control variable  a  (default:  1.0 ). a_bounds : Bounds for each control variable (default: filled with  a_bound ). da_bound::Float64 : The bound for the derivative of the control variable (default:  Inf ). da_bounds : Bounds for each derivative of the control variable. dda_bound::Float64 : The bound for the second derivative of the control variable (default:  1.0 ). dda_bounds : Bounds for each second derivative of the control variable. Δt_min::Float64 : Minimum allowed timestep duration. Δt_max::Float64 : Maximum allowed timestep duration. Q::Float64 : Weight for the unitary infidelity objective (default:  100.0 ). Q_v::Float64 : Weight for sensitivity objectives (default:  1.0 ). R : Regularization weight for control variables (default:  1e-2 ). R_a ,  R_da ,  R_dda : Regularization weights for control, its derivative, and second derivative. constraints::Vector : Additional constraints for the optimization problem. piccolo_options::PiccoloOptions : Options for configuring the Piccolo optimization framework. Returns A  DirectTrajOptProblem  object representing the optimization problem, including the  trajectory, objective, integrators, and constraints. Notes This function constructs a trajectory optimization problem for quantum control using  variational principles. It supports robust and sensitive trajectory design, regularization,  and optional constraints. The problem is solved using the Piccolo optimization framework. source The  UnitaryVariationalProblem  uses a  VariationalQuantumSystem  to find a control that is sensitive or robust to terms in the Hamiltonian. See the documentation for the  VariationalQuantumSystem  in  PiccoloQuantumObjects.jl  for more details. create a variational system, with a variational Hamiltonian,  PAULIS.X H_var = PAULIS.X\nvarsys = VariationalQuantumSystem([PAULIS.X, PAULIS.Y], [H_var]); create a variational problem that is robust to  PAULIS.X  at the end robprob = UnitaryVariationalProblem(varsys, U_goal, T, Δt, robust_times=[[T]]);     constructing UnitaryVariationalProblem...\n\tusing integrator: typeof(VariationalUnitaryIntegrator)\n\ttotal variational parameters: 1\n\trobust knot points: [[51]]\n\tsensitive knot points: [Int64[]]\n\tcontrol derivative names: [:da, :dda]\n\tapplying timesteps_all_equal constraint: Δt This page was generated using  Literate.jl ."},{"id":223,"pagetitle":"Library","title":"Library","ref":"/QuantumCollocation/dev/lib/#Library","content":" Library"},{"id":224,"pagetitle":"Library","title":"Problem Templates","ref":"/QuantumCollocation/dev/lib/#Problem-Templates","content":" Problem Templates"},{"id":225,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem","content":" QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem  —  Function QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)\nQuantumStateMinimumTimeProblem(prob; kwargs...) Construct a  DirectTrajOptProblem  for the minimum time problem of reaching a target state. Keyword Arguments state_name::Symbol=:ψ̃ : The symbol for the state variables. final_fidelity::Union{Real, Nothing}=nothing : The final fidelity. D=1.0 : The cost weight on the time. piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. source"},{"id":226,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem","content":" QuantumCollocation.ProblemTemplates.QuantumStateSamplingProblem  —  Function source"},{"id":227,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem","content":" QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem  —  Function QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)\nQuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...) Create a quantum state smooth pulse problem. The goal is to find a control pulse  a(t)   that drives all of the initial states  ψ_inits  to the corresponding target states   ψ_goals  using  T  timesteps of size  Δt . This problem also controls the  first and  second derivatives of the control pulse,  da(t)  and  dda(t) , to ensure smoothness. Arguments system::AbstractQuantumSystem : The quantum system. or H_drift::AbstractMatrix{<:Number} : The drift Hamiltonian. H_drives::Vector{<:AbstractMatrix{<:Number}} : The control Hamiltonians. with ψ_inits::Vector{<:AbstractVector{<:ComplexF64}} : The initial states. ψ_goals::Vector{<:AbstractVector{<:ComplexF64}} : The target states. or ψ_init::AbstractVector{<:ComplexF64} : The initial state. ψ_goal::AbstractVector{<:ComplexF64} : The target state. with T::Int : The number of timesteps. Δt::Float64 : The timestep size. Keyword Arguments state_name::Symbol=:ψ̃ : The name of the state variable. control_name::Symbol=:a : The name of the control variable. timestep_name::Symbol=:Δt : The name of the timestep variable. init_trajectory::Union{NamedTrajectory, Nothing}=nothing : The initial trajectory. a_bound::Float64=1.0 : The bound on the control pulse. a_bounds=fill(a_bound, length(system.G_drives)) : The bounds on the control pulse. a_guess::Union{Matrix{Float64}, Nothing}=nothing : The initial guess for the control pulse. da_bound::Float64=Inf : The bound on the first derivative of the control pulse. da_bounds=fill(da_bound, length(system.G_drives)) : The bounds on the first derivative of the control pulse. dda_bound::Float64=1.0 : The bound on the second derivative of the control pulse. dda_bounds=fill(dda_bound, length(system.G_drives)) : The bounds on the second derivative of the control pulse. Δt_min::Float64=0.5 * Δt : The minimum timestep size. Δt_max::Float64=1.5 * Δt : The maximum timestep size. drive_derivative_σ::Float64=0.01 : The standard deviation of the drive derivative random initialization. Q::Float64=100.0 : The weight on the state objective. R=1e-2 : The weight on the control pulse and its derivatives. R_a::Union{Float64, Vector{Float64}}=R : The weight on the control pulse. R_da::Union{Float64, Vector{Float64}}=R : The weight on the first derivative of the control pulse. R_dda::Union{Float64, Vector{Float64}}=R : The weight on the second derivative of the control pulse. constraints::Vector{<:AbstractConstraint}=AbstractConstraint[] : The constraints. piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. source"},{"id":228,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryFreePhaseProblem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.ProblemTemplates.UnitaryFreePhaseProblem-Tuple{PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem, Function, Int64, Union{Float64, AbstractVector{Float64}}}","content":" QuantumCollocation.ProblemTemplates.UnitaryFreePhaseProblem  —  Method UnitaryFreePhaseProblem(system::AbstractQuantumSystem, goal::Function, T, Δt; kwargs...) Construct a  DirectTrajOptProblem  for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory. The problem follows the same structure as  UnitarySmoothPulseProblem , but allows for free global phases on the goal unitary, via cosines and sines parameterizing phase variables. The  goal  function should accept a vector of global phases  [cos(θ); sin(θ)]  and return an  AbstractPiccoloOperator . source"},{"id":229,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","content":" QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem  —  Function UnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    trajectory::NamedTrajectory,\n    objective::Objective,\n    dynamics::TrajectoryDynamics,\n    constraints::AbstractVector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    goal::AbstractPiccoloOperator,\n    prob::DirectTrajOptProblem;\n    kwargs...\n) Create a minimum-time problem for unitary control. \\[\\begin{aligned}\n\\underset{\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}, \\Delta t}{\\text{minimize}} & \\quad\nJ(\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}) + D \\sum_t \\Delta t_t \\\\\n\\text{ subject to } & \\quad \\vb{P}^{(n)}\\qty(\\vec{\\tilde{U}}_{t+1}, \\vec{\\tilde{U}}_t, a_t, \\Delta t_t) = 0 \\\\\n& c(\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}) = 0 \\\\\n& \\quad \\Delta t_{\\text{min}} \\leq \\Delta t_t \\leq \\Delta t_{\\text{max}} \\\\\n\\end{aligned}\\] Keyword Arguments piccolo_options::PiccoloOptions=PiccoloOptions() : The Piccolo options. unitary_name::Symbol=:Ũ⃗ : The name of the unitary for the goal. final_fidelity::Float64=1.0 : The final fidelity constraint. D::Float64=1.0 : The scaling factor for the minimum-time objective. source"},{"id":230,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySamplingProblem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-Tuple{AbstractVector{<:PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem}, AbstractVector{<:PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator}, Int64, Union{Float64, Vector{Float64}}}","content":" QuantumCollocation.ProblemTemplates.UnitarySamplingProblem  —  Method UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...) A  UnitarySamplingProblem  is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control  pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty. Arguments systems::AbstractVector{<:AbstractQuantumSystem} : A vector of quantum systems. operators::AbstractVector{<:AbstractPiccoloOperator} : A vector of target operators. T::Int : The number of time steps. Δt::Union{Float64, Vector{Float64}} : The time step value or vector of time steps. Keyword Arguments system_labels::Vector{String} = string.(1:length(systems)) : The labels for each system. system_weights::Vector{Float64} = fill(1.0, length(systems)) : The weights for each system. init_trajectory::Union{NamedTrajectory, Nothing} = nothing : The initial trajectory. state_name::Symbol = :Ũ⃗ : The name of the state variable. control_name::Symbol = :a : The name of the control variable. timestep_name::Symbol = :Δt : The name of the timestep variable. constraints::Vector{<:AbstractConstraint} = AbstractConstraint[] : The constraints. a_bound::Float64 = 1.0 : The bound for the control amplitudes. a_bounds = fill(a_bound, length(systems[1].G_drives)) : The bounds for the control amplitudes. a_guess::Union{Matrix{Float64}, Nothing} = nothing : The initial guess for the control amplitudes. da_bound::Float64 = Inf : The bound for the control first derivatives. da_bounds = fill(da_bound, length(systems[1].G_drives)) : The bounds for the control first derivatives. dda_bound::Float64 = 1.0 : The bound for the control second derivatives. dda_bounds = fill(dda_bound, length(systems[1].G_drives)) : The bounds for the control second derivatives. Δt_min::Float64 = 0.5 * Δt : The minimum time step size. Δt_max::Float64 = 1.5 * Δt : The maximum time step size. Q::Float64 = 100.0 : The fidelity weight. R::Float64 = 1e-2 : The regularization weight. R_a::Union{Float64, Vector{Float64}} = R : The regularization weight for the control amplitudes. R_da::Union{Float64, Vector{Float64}} = R : The regularization weight for the control first derivatives. R_dda::Union{Float64, Vector{Float64}} = R : The regularization weight for the control second derivatives. piccolo_options::PiccoloOptions = PiccoloOptions() : The Piccolo options. source"},{"id":231,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","content":" QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem  —  Function UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator::AbstractPiccoloOperator, T::Int, Δt::Float64; kwargs...)\nUnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...) Construct a  DirectTrajOptProblem  for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e., \\[\\begin{aligned}\n\\underset{\\vec{\\tilde{U}}, a, \\dot{a}, \\ddot{a}, \\Delta t}{\\text{minimize}} & \\quad\nQ \\cdot \\ell\\qty(\\vec{\\tilde{U}}_T, \\vec{\\tilde{U}}_{\\text{goal}}) + \\frac{1}{2} \\sum_t \\qty(R_a a_t^2 + R_{\\dot{a}} \\dot{a}_t^2 + R_{\\ddot{a}} \\ddot{a}_t^2) \\\\\n\\text{ subject to } & \\quad \\vb{P}^{(n)}\\qty(\\vec{\\tilde{U}}_{t+1}, \\vec{\\tilde{U}}_t, a_t, \\Delta t_t) = 0 \\\\\n& \\quad a_{t+1} - a_t - \\dot{a}_t \\Delta t_t = 0 \\\\\n& \\quad \\dot{a}_{t+1} - \\dot{a}_t - \\ddot{a}_t \\Delta t_t = 0 \\\\\n& \\quad |a_t| \\leq a_{\\text{bound}} \\\\\n& \\quad |\\ddot{a}_t| \\leq \\ddot{a}_{\\text{bound}} \\\\\n& \\quad \\Delta t_{\\text{min}} \\leq \\Delta t_t \\leq \\Delta t_{\\text{max}} \\\\\n\\end{aligned}\\] where, for  $U \\in SU(N)$ , \\[\\ell\\qty(\\vec{\\tilde{U}}_T, \\vec{\\tilde{U}}_{\\text{goal}}) =\n\\abs{1 - \\frac{1}{N} \\abs{ \\tr \\qty(U_{\\text{goal}}, U_T)} }\\] is the  infidelity  objective function,  $Q$  is a weight,  $R_a$ ,  $R_{\\dot{a}}$ , and  $R_{\\ddot{a}}$  are weights on the regularization terms, and  $\\vb{P}^{(n)}$  is the  $n$ th-order Pade integrator. Arguments system::AbstractQuantumSystem : the system to be controlled or H_drift::AbstractMatrix{<:Number} : the drift hamiltonian H_drives::Vector{<:AbstractMatrix{<:Number}} : the control hamiltonians with goal::AbstractPiccoloOperator : the target unitary, either in the form of an  EmbeddedOperator  or a `Matrix{ComplexF64} T::Int : the number of timesteps Δt::Float64 : the (initial) time step size Keyword Arguments piccolo_options::PiccoloOptions=PiccoloOptions() : the options for the Piccolo solver state_name::Symbol = :Ũ⃗ : the name of the state control_name::Symbol = :a : the name of the control timestep_name::Symbol = :Δt : the name of the timestep init_trajectory::Union{NamedTrajectory, Nothing}=nothing : an initial trajectory to use a_guess::Union{Matrix{Float64}, Nothing}=nothing : an initial guess for the control pulses a_bound::Float64=1.0 : the bound on the control pulse a_bounds=fill(a_bound, length(system.G_drives)) : the bounds on the control pulses, one for each drive da_bound::Float64=Inf : the bound on the control pulse derivative da_bounds=fill(da_bound, length(system.G_drives)) : the bounds on the control pulse derivatives, one for each drive dda_bound::Float64=1.0 : the bound on the control pulse second derivative dda_bounds=fill(dda_bound, length(system.G_drives)) : the bounds on the control pulse second derivatives, one for each drive Δt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt) : the minimum time step size Δt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt) : the maximum time step size Q::Float64=100.0 : the weight on the infidelity objective R=1e-2 : the weight on the regularization terms R_a::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulses R_da::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulse derivatives R_dda::Union{Float64, Vector{Float64}}=R : the weight on the regularization term for the control pulse second derivatives constraints::Vector{<:AbstractConstraint}=AbstractConstraint[] : the constraints to enforce source"},{"id":232,"pagetitle":"Library","title":"QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem","content":" QuantumCollocation.ProblemTemplates.UnitaryVariationalProblem  —  Function UnitaryVariationalProblem(\n    system::VariationalQuantumSystem,\n    goal::AbstractPiccoloOperator,\n    T::Int,\n    Δt::Union{Float64, <:AbstractVector{Float64}};\n    robust_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    sensitive_times::AbstractVector{<:Union{AbstractVector{Int}, Nothing}}=[nothing for s ∈ system.G_vars],\n    kwargs...\n) Constructs a unitary variational problem for optimizing quantum control trajectories. Arguments system::VariationalQuantumSystem : The quantum system to be controlled, containing variational parameters. goal::AbstractPiccoloOperator : The target operator or state to achieve at the end of the trajectory. T::Int : The total number of timesteps in the trajectory. Δt::Union{Float64, <:AbstractVector{Float64}} : The timestep duration or a vector of timestep durations. Keyword Arguments robust_times::AbstractVector : Times at which robustness to variations in the trajectory is enforced. sensitive_times::AbstractVector : Times at which sensitivity to variations in the trajectory is enhanced. unitary_integrator : The integrator used for unitary evolution (default:  VariationalUnitaryIntegrator ). state_name::Symbol : The name of the state variable in the trajectory (default:  :Ũ⃗ ). variational_state_name::Symbol : The name of the variational state variable (default:  :Ũ⃗ₐ ). variational_scales::AbstractVector : Scaling factors for the variational state variables (default:  1.0 ). control_name::Symbol : The name of the control variable (default:  :a ). timestep_name::Symbol : The name of the timestep variable (default:  :Δt ). init_trajectory::Union{NamedTrajectory, Nothing} : An optional initial trajectory to start optimization. a_bound::Float64 : The bound for the control variable  a  (default:  1.0 ). a_bounds : Bounds for each control variable (default: filled with  a_bound ). da_bound::Float64 : The bound for the derivative of the control variable (default:  Inf ). da_bounds : Bounds for each derivative of the control variable. dda_bound::Float64 : The bound for the second derivative of the control variable (default:  1.0 ). dda_bounds : Bounds for each second derivative of the control variable. Δt_min::Float64 : Minimum allowed timestep duration. Δt_max::Float64 : Maximum allowed timestep duration. Q::Float64 : Weight for the unitary infidelity objective (default:  100.0 ). Q_v::Float64 : Weight for sensitivity objectives (default:  1.0 ). R : Regularization weight for control variables (default:  1e-2 ). R_a ,  R_da ,  R_dda : Regularization weights for control, its derivative, and second derivative. constraints::Vector : Additional constraints for the optimization problem. piccolo_options::PiccoloOptions : Options for configuring the Piccolo optimization framework. Returns A  DirectTrajOptProblem  object representing the optimization problem, including the  trajectory, objective, integrators, and constraints. Notes This function constructs a trajectory optimization problem for quantum control using  variational principles. It supports robust and sensitive trajectory design, regularization,  and optional constraints. The problem is solved using the Piccolo optimization framework. source"},{"id":233,"pagetitle":"Library","title":"Options","ref":"/QuantumCollocation/dev/lib/#Options","content":" Options"},{"id":234,"pagetitle":"Library","title":"QuantumCollocation.Options.PiccoloOptions","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.Options.PiccoloOptions","content":" QuantumCollocation.Options.PiccoloOptions  —  Type PiccoloOptions Options for the Piccolo quantum optimal control library. Fields verbose::Bool = true : Print verbose output timesteps_all_equal::Bool = true : Use equal timesteps rollout_integrator::Function = expv : Integrator to use for rollout geodesic = true : Use the geodesic to initialize the optimization. zero_initial_and_final_derivative::Bool=false : Zero the initial and final control pulse derivatives. complex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing : Name of the complex control norm constraint. complex_control_norm_constraint_radius::Float64 = 1.0 : Radius of the complex control norm constraint. bound_state::Bool = false : Bound the state variables <= 1.0. leakage_constraint::Bool = false : Suppress leakage with constraint and cost. leakage_constraint_value::Float64 = 1e-2 : Value for the leakage constraint. leakage_cost::Float64 = 1e-2 : Leakage suppression parameter. source"},{"id":235,"pagetitle":"Library","title":"Trajectory Initialization","ref":"/QuantumCollocation/dev/lib/#Trajectory-Initialization","content":" Trajectory Initialization"},{"id":236,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractVector{<:AbstractVector{ComplexF64}}, AbstractVector{<:AbstractVector{ComplexF64}}, Int64, Union{Real, AbstractVector{<:Real}}, Vararg{Any}}","content":" QuantumCollocation.TrajectoryInitialization.initialize_trajectory  —  Method initialize_trajectory Trajectory initialization of quantum states. source"},{"id":237,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Any, Any, Int64, Union{Real, AbstractVecOrMat{<:Real}}, Vararg{Any}}","content":" QuantumCollocation.TrajectoryInitialization.initialize_trajectory  —  Method initialize_trajectory Trajectory initialization of density matrices. source"},{"id":238,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator, Int64, Union{Real, AbstractVecOrMat{<:Real}}, Vararg{Any}}","content":" QuantumCollocation.TrajectoryInitialization.initialize_trajectory  —  Method initialize_trajectory Trajectory initialization of unitaries. source"},{"id":239,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.initialize_trajectory","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Vector{<:AbstractMatrix{Float64}}, Vector{<:AbstractVector{Float64}}, Vector{<:AbstractVector{Float64}}, AbstractVector{Symbol}, Int64, Union{Float64, AbstractVecOrMat{<:Float64}}, Int64, Tuple{Vararg{Union{Tuple{R⃗, R⃗}, R⃗} where R⃗<:(AbstractVector{<:Real})}}}","content":" QuantumCollocation.TrajectoryInitialization.initialize_trajectory  —  Method initialize_trajectory Initialize a trajectory for a control problem. The trajectory is initialized with data that should be consistently the same type (in this case, Float64). source"},{"id":240,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_geodesic","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.TrajectoryInitialization.unitary_geodesic","content":" QuantumCollocation.TrajectoryInitialization.unitary_geodesic  —  Function unitary_geodesic(U_init, U_goal, times; kwargs...) Compute the geodesic connecting U init and U goal at the specified times. Arguments U_init::AbstractMatrix{<:Number} : The initial unitary operator. U_goal::AbstractMatrix{<:Number} : The goal unitary operator. times::AbstractVector{<:Number} : The times at which to evaluate the geodesic. Keyword Arguments return_unitary_isos::Bool=true : If true returns a matrix where each column is a unitary    isovec, i.e. vec(vcat(real(U), imag(U))). If false, returns a vector of unitary matrices. return_generator::Bool=false : If true, returns the effective Hamiltonian generating    the geodesic. source"},{"id":241,"pagetitle":"Library","title":"QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation","ref":"/QuantumCollocation/dev/lib/#QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Int64}","content":" QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation  —  Method unitary_linear_interpolation(\n    U_init::AbstractMatrix,\n    U_goal::AbstractMatrix,\n    samples::Int\n) Compute a linear interpolation of unitary operators with  samples  samples. source"},{"id":244,"pagetitle":"Home","title":"DirectTrajOpt.jl","ref":"/DirectTrajOpt/dev/#DirectTrajOpt.jl","content":" DirectTrajOpt.jl Documentation Build Status License DirectTrajOpt.jl  provides abstractions and utilities for setting up and solving direct trajectory optimization problems of the form: \\[\\begin{align*}\n\\underset{x_{1:N}, u_{1:N-1}}{\\text{minimize}} \\quad & J(x_{1:N}, u_{1:N-1}) \\\\\n\\text{subject to} \\quad & f(x_{k+1}, x_k, u_k, \\Delta t, t_k) = 0\\\\\n& c_k(x_k, u_k) \\geq 0 \\\\\n& x_1 = x_{\\text{init}} \\\\\n\\end{align*}\\] where  $J(x_{1:N}, u_{1:N-1})$  is a user-defined cost function,  $f(x_{k+1}, x_k, u_k, \\Delta t, t_k)$  is an  integrator  funtion encoding the dynamics of the system, and  $c_k(x_k, u_k)$  are user-defined constraints. The underlying nonlinear solver is  Ipopt.jl , which is a Julia interface to the  Ipopt  solver. "},{"id":245,"pagetitle":"Home","title":"Building Documentation","ref":"/DirectTrajOpt/dev/#Building-Documentation","content":" Building Documentation This package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility.  # first time only\n./docs/get_docs_utils.sh   # or ./get_docs_utils.sh if cwd is in ./docs/ To build the docs pages: julia --project=docs docs/make.jl or editing the docs live: julia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"], skip_files=[\"docs/src/index.md\"]) Note: servedocs  needs to watch a subset of the files in the  docs/  folder. If it watches files that are generated on a docs build/re-build,  servedocs  will continuously try to re-serve the pages. To prevent this, ensure all generated files are included in the skip dirs or skip files args for  servedocs . For example, if we forget index.md like so: julia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"]) it will not build and serve. \"It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to take away.\" - Antoine de Saint-Exupéry"},{"id":248,"pagetitle":"Explanation","title":"Quickstart Guide","ref":"/DirectTrajOpt/dev/generated/explanation/#Quickstart-Guide","content":" Quickstart Guide"},{"id":249,"pagetitle":"Explanation","title":"Installation","ref":"/DirectTrajOpt/dev/generated/explanation/#Installation","content":" Installation using DirectTrajOpt This package also provides various objects and bindings used in Quantum Optimal Control problems. This means various common constraints, integrators, objectives, and losses. This package also provides interfaces for the commonly needed dynamics, and evaluator objects to provide to the solver - which for now is Ipopt. This page was generated using  Literate.jl ."},{"id":252,"pagetitle":"Lib","title":"Library","ref":"/DirectTrajOpt/dev/lib/#Library","content":" Library"},{"id":253,"pagetitle":"Lib","title":"Constraints","ref":"/DirectTrajOpt/dev/lib/#Constraints","content":" Constraints"},{"id":254,"pagetitle":"Lib","title":"DirectTrajOpt.Constraints.EqualityConstraint","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Constraints.EqualityConstraint","content":" DirectTrajOpt.Constraints.EqualityConstraint  —  Type struct EqualityConstraint Represents a linear equality constraint. Fields ts::AbstractArray{Int} : the time steps at which the constraint is applied js::AbstractArray{Int} : the components of the trajectory at which the constraint is applied vals::Vector{R} : the values of the constraint vardim::Int : the dimension of a single time step of the trajectory label::String : a label for the constraint source"},{"id":255,"pagetitle":"Lib","title":"DirectTrajOpt.Constraints.EqualityConstraint","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Constraints.EqualityConstraint-Tuple{Symbol, AbstractVector{Int64}, Vector{Float64}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" DirectTrajOpt.Constraints.EqualityConstraint  —  Method EqualityConstraint(\n    name::Symbol,\n    ts::Vector{Int},\n    val::Vector{Float64},\n    traj::NamedTrajectory;\n    label=\"equality constraint on trajectory variable [name]\"\n) Constructs equality constraint for trajectory variable in NamedTrajectory source"},{"id":256,"pagetitle":"Lib","title":"DirectTrajOpt.Constraints.GlobalEqualityConstraint","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Constraints.GlobalEqualityConstraint-Tuple{Symbol, Vector{Float64}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" DirectTrajOpt.Constraints.GlobalEqualityConstraint  —  Method GlobalEqualityConstraint(\n    name::Symbol,\n    val::Vector{Float64},\n    traj::NamedTrajectory;\n    label=\"equality constraint on global variable [name]\"\n)::EqualityConstraint Constructs equality constraint for global variable in NamedTrajectory source"},{"id":257,"pagetitle":"Lib","title":"Integrators","ref":"/DirectTrajOpt/dev/lib/#Integrators","content":" Integrators"},{"id":258,"pagetitle":"Lib","title":"DirectTrajOpt.Integrators.dense","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Integrators.dense-Tuple{Any, Any, Any}","content":" DirectTrajOpt.Integrators.dense  —  Method dense(vals, structure, shape) Convert sparse data to dense matrix. Arguments vals : vector of values structure : vector of tuples of indices shape : tuple of matrix dimensions source"},{"id":259,"pagetitle":"Lib","title":"DirectTrajOpt.Integrators.show_diffs","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Integrators.show_diffs-Tuple{AbstractMatrix, AbstractMatrix}","content":" DirectTrajOpt.Integrators.show_diffs  —  Method show_diffs(A::Matrix, B::Matrix) Show differences between matrices. source"},{"id":260,"pagetitle":"Lib","title":"Objectives","ref":"/DirectTrajOpt/dev/lib/#Objectives","content":" Objectives"},{"id":261,"pagetitle":"Lib","title":"DirectTrajOpt.Objectives.Objective","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Objectives.Objective","content":" DirectTrajOpt.Objectives.Objective  —  Type Objective A structure for defining objective functions. Fields:      L : the objective function      ∇L : the gradient of the objective function      ∂²L : the Hessian of the objective function      ∂²L_structure : the structure of the Hessian of the objective function source"},{"id":262,"pagetitle":"Lib","title":"DirectTrajOpt.Objectives.GlobalObjective","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Objectives.GlobalObjective-Tuple{Function, AbstractVector{Symbol}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" DirectTrajOpt.Objectives.GlobalObjective  —  Method GlobalObjective(\n    ℓ::Function,\n    global_names::AbstractVector{Symbol},\n    traj::NamedTrajectory;\n    kwargs...\n)\nGlobalObjective(\n    ℓ::Function,\n    global_name::Symbol,\n    traj::NamedTrajectory;\n    kwargs...\n) Create an objective that only involves the global components. source"},{"id":263,"pagetitle":"Lib","title":"DirectTrajOpt.Objectives.KnotPointObjective","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Objectives.KnotPointObjective-Tuple{Function, AbstractVector{Symbol}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, AbstractVector}","content":" DirectTrajOpt.Objectives.KnotPointObjective  —  Method KnotPointObjective(\n    ℓ::Function,\n    names::AbstractVector{Symbol},\n    traj::NamedTrajectory,\n    params::AbstractVector;\n    kwargs...\n)\nKnotPointObjective(\n    ℓ::Function,\n    names::AbstractVector{Symbol},\n    traj::NamedTrajectory;\n    kwargs...\n)\nKnotPointObjective(\n    ℓ::Function,\n    name::Symbol,\n    args...;\n    kwargs...\n) Create a knot point summed objective function for trajectory optimization, where  ℓ(x, p)   on trajectory knot point variables  x  with parameters  p . If the parameters argument is  omitted,  ℓ(x)  is assumed  to be a function of  x  only. Arguments ℓ::Function : Function that defines the objective, ℓ(x, p) or ℓ(x). names::AbstractVector{Symbol} : Names of the trajectory variables to be optimized. traj::NamedTrajectory : The trajectory on which the objective is defined. params::AbstractVector : Parameters  p  for the objective function ℓ, for each time. Keyword Arguments times::AbstractVector{Int}=1:traj.T : Time indices at which the objective is evaluated. Qs::AbstractVector{Float64}=ones(traj.T) : Weights for the objective function at each time. source"},{"id":264,"pagetitle":"Lib","title":"DirectTrajOpt.Objectives.MinimumTimeObjective","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Objectives.MinimumTimeObjective-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" DirectTrajOpt.Objectives.MinimumTimeObjective  —  Method MinimumTimeObjective A type of objective that counts the time taken to complete a task.   D  is a scaling factor. source"},{"id":265,"pagetitle":"Lib","title":"DirectTrajOpt.Objectives.QuadraticRegularizer","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Objectives.QuadraticRegularizer-Tuple{Symbol, NamedTrajectories.StructNamedTrajectory.NamedTrajectory, AbstractVector{<:Real}}","content":" DirectTrajOpt.Objectives.QuadraticRegularizer  —  Method QuadraticRegularizer A quadratic regularizer for a trajectory component. Fields:      name : the name of the trajectory component to regularize      traj : the trajectory      R : the regularization matrix diagonal      baseline : the baseline values for the trajectory component      times : the times at which to evaluate the regularizer source"},{"id":266,"pagetitle":"Lib","title":"Dynamics","ref":"/DirectTrajOpt/dev/lib/#Dynamics","content":" Dynamics"},{"id":267,"pagetitle":"Lib","title":"DirectTrajOpt.Dynamics.TrajectoryDynamics","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Dynamics.TrajectoryDynamics","content":" DirectTrajOpt.Dynamics.TrajectoryDynamics  —  Type TrajectoryDynamics A struct for trajectory optimization dynamics, represented by integrators that compute single time step dynamics, and functions for jacobians and hessians. Fields integrators::Union{Nothing, Vector{<:AbstractIntegrator}} : Vector of integrators. F!::Function : Function to compute trajectory dynamics. ∂F!::Function : Function to compute the Jacobian of the dynamics. ∂fs::Vector{SparseMatrixCSC{Float64, Int}} : Vector of Jacobian matrices. μ∂²F!::Union{Function, Nothing} : Function to compute the Hessian of the Lagrangian. μ∂²fs::Vector{SparseMatrixCSC{Float64, Int}} : Vector of Hessian matrices. dim::Int : Total dimension of the dynamics. source"},{"id":268,"pagetitle":"Lib","title":"Problems","ref":"/DirectTrajOpt/dev/lib/#Problems","content":" Problems"},{"id":269,"pagetitle":"Lib","title":"DirectTrajOpt.Problems.DirectTrajOptProblem","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Problems.DirectTrajOptProblem","content":" DirectTrajOpt.Problems.DirectTrajOptProblem  —  Type mutable struct DirectTrajOptProblem <: AbstractProblem Stores all the information needed to set up and solve a DirectTrajOptProblem as well as the solution after the solver terminates. Fields optimizer::Ipopt.Optimizer : Ipopt optimizer object source"},{"id":270,"pagetitle":"Lib","title":"DirectTrajOpt.Problems.get_trajectory_constraints","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Problems.get_trajectory_constraints-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" DirectTrajOpt.Problems.get_trajectory_constraints  —  Method trajectory_constraints(traj::NamedTrajectory) Implements the initial and final value constraints and bounds constraints on the controls and states as specified by traj. source"},{"id":271,"pagetitle":"Lib","title":"Problem Solvers","ref":"/DirectTrajOpt/dev/lib/#Problem-Solvers","content":" Problem Solvers"},{"id":272,"pagetitle":"Lib","title":"Problem Solvers","ref":"/DirectTrajOpt/dev/lib/#Problem-Solvers-2","content":" Problem Solvers"},{"id":273,"pagetitle":"Lib","title":"DirectTrajOpt.IpoptSolverExt.IpoptOptions","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.IpoptSolverExt.IpoptOptions","content":" DirectTrajOpt.IpoptSolverExt.IpoptOptions  —  Type Solver options for Ipopt\n\nhttps://coin-or.github.io/Ipopt/OPTIONS.html#OPT_print_options_documentation source"},{"id":274,"pagetitle":"Lib","title":"DirectTrajOpt.Solvers.solve!","ref":"/DirectTrajOpt/dev/lib/#DirectTrajOpt.Solvers.solve!-Tuple{DirectTrajOptProblem}","content":" DirectTrajOpt.Solvers.solve!  —  Method solve!(prob::DirectTrajOptProblem;         init traj=nothing,         save path=nothing,         max iter=prob.ipopt options.max iter,         linear solver=prob.ipopt options.linear solver,         print level=prob.ipopt options.print level,         remove slack variables=false,         callback=nothing         # state type=:unitary,         # print_fidelity=false,     ) Call optimization solver to solve the quantum control problem with parameters and callbacks. Arguments prob::DirectTrajOptProblem : The quantum control problem to solve. init_traj::NamedTrajectory : Initial guess for the control trajectory. If not provided, a random guess will be generated. save_path::String : Path to save the problem after optimization. max_iter::Int : Maximum number of iterations for the optimization solver. linear_solver::String : Linear solver to use for the optimization solver (e.g., \"mumps\", \"paradiso\", etc). print_level::Int : Verbosity level for the solver. callback::Function : Callback function to call during optimization steps. source"},{"id":277,"pagetitle":"Home","title":"NamedTrajectories.jl","ref":"/NamedTrajectories/dev/#NamedTrajectories.jl","content":" NamedTrajectories.jl NamedTrajectories.jl  is a package for working with trajectories of named variables. It is designed to be used with the  Piccolo.jl  ecosystem."},{"id":278,"pagetitle":"Home","title":"Installation","ref":"/NamedTrajectories/dev/#Installation","content":" Installation NamedTrajectories.jl is registered! Install in the REPL by entering pkg mode with  ]  and then running  pkg> add NamedTrajectories or to install the latest master branch run pkg> add NamedTrajectories#main"},{"id":279,"pagetitle":"Home","title":"Features","ref":"/NamedTrajectories/dev/#Features","content":" Features Abstract away messy indexing and vectorization details required for interfacing with numerical solvers. Easily handle multiple trajectories with different names, e.g. various states and controls. Simple plotting of trajectories. Provide a variety of helpful methods for common tasks."},{"id":280,"pagetitle":"Home","title":"Basic Usage","ref":"/NamedTrajectories/dev/#Basic-Usage","content":" Basic Usage Users can define  NamedTrajectory  types which have lots of useful functionality. For example, you can access the data by name or index.  In the case of an index, a  KnotPoint  is returned which contains the data for that timestep. using NamedTrajectories\n\n# define number of timesteps and timestep\nT = 10\ndt = 0.1\n\n# build named tuple of components and data matrices\ncomponents = (\n    x = rand(3, T),\n    u = rand(2, T),\n)\n\n# build trajectory\ntraj = NamedTrajectory(components; timestep=dt, controls=:u)\n\n# access data by name\ntraj.x # returns 3x10 matrix of x data\ntraj.u # returns 2x10 matrix of u data\n\nz1 = traj[1] # returns KnotPoint with x and u data\n\nz1.x # returns 3 element vector of x data at timestep 1\nz1.u # returns 2 element vector of u data at timestep 1\n\ntraj.data # returns data as 5x10 matrix\ntraj.names # returns names as tuple (:x, :u)"},{"id":281,"pagetitle":"Home","title":"Motivation","ref":"/NamedTrajectories/dev/#Motivation","content":" Motivation NamedTrajectories.jl  is designed to aid in the messy indexing involved in solving trajectory optimization problems of the form \\[\\begin{aligned}\n    \\arg \\min_{\\mathbf{Z}}\\quad & J(\\mathbf{Z}) \\\\\n    \\nonumber \\text{s.t.}\\qquad & \\mathbf{f}(\\mathbf{Z}) = 0 \\\\\n    \\nonumber & \\mathbf{g}(\\mathbf{Z}) \\le 0  \n\\end{aligned}\\] where  $\\mathbf{Z}$  is a trajectory. In more detail, this problem might look something like \\[\\begin{align*}\n\\underset{u^1_{1:T}, \\dots, u^{n_c}_{1:T}}{\\underset{x^1_{1:T}, \\cdots, x^{n_s}_{1:T}}{\\text{minimize}}} &\\quad J \\left(x^{1:n_s}_{1:T},u^{1:n_c}_{1:T} \\right) \\\\\n\\text{subject to} & \\quad f \\left(x^{1:n_s}_{1:T},u^{1:n_c}_{1:T} \\right) = 0 \\\\\n& \\quad x^i_1 = x^i_{\\text{initial}} \\\\\n& \\quad x^i_T = x^i_{\\text{final}} \\\\\n& \\quad u^i_1 = u^i_{\\text{initial}} \\\\\n& \\quad u^i_T = u^i_{\\text{final}} \\\\\n& \\quad x^i_{\\min} < x^i_t < x^i_{\\max} \\\\\n& \\quad u^i_{\\min} < u^i_t < u^i_{\\max} \\\\\n\\end{align*}\\] where  $x^i_t$  is the  $i$  th state variable and  $u^i_t$  is the  $i$  th control variable at timestep  $t$ ; state and control variables can be of arbitrary dimension. The function  $f$  is a nonlinear constraint function and  $J$  is the objective function. These problems can have an arbitrary number of state ( $n_s$ ) and control ( $n_c$ ) variables, and the number of timesteps  $T$  can vary as well.   It is common practice in trajectory optimization to bundle all of the state and control variables together into a single  knot point \\[z_t = \\begin{pmatrix}\n    x^1_t \\\\\n    \\vdots \\\\\n    x^{n_s}_t \\\\\n    u^1_t \\\\\n    \\vdots \\\\\n    u^{n_c}_t\n  \\end{pmatrix}.\\] The trajectory optimization problem can then be succinctly written as \\[\\begin{align*}\n\\underset{z_{1:T}}{\\text{minimize}} &\\quad J \\left(z_{1:T} \\right) \\\\\n\\text{subject to} & \\quad f \\left(z_{1:T} \\right) = 0 \\\\\n& \\quad z_1 = z_{\\text{initial}} \\\\\n& \\quad z_T = z_{\\text{final}} \\\\\n& \\quad z_{\\min} < z_t < z_{\\max} \\\\\n\\end{align*}\\] The  NamedTrajectories  package provides a  NamedTrajectory  type which abstracts away the messy indexing and vectorization details required for interfacing with numerical solvers.  It also provides a variety of helpful methods for common tasks.  For example, you can access the data by name or index.  In the case of an index, a  KnotPoint  is returned which contains the data for that timestep."},{"id":282,"pagetitle":"Home","title":"Building Documentation","ref":"/NamedTrajectories/dev/#Building-Documentation","content":" Building Documentation This package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility.  # first time only\n./docs/get_docs_utils.sh   # or ./get_docs_utils.sh if cwd is in ./docs/ To build the docs pages: julia --project=docs docs/make.jl or editing the docs live: julia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"], skip_files=[\"docs/src/index.md\"]) Note: servedocs  needs to watch a subset of the files in the  docs/  folder. If it watches files that are generated on a docs build/re-build,  servedocs  will continuously try to re-serve the pages. To prevent this, ensure all generated files are included in the skip dirs or skip files args for  servedocs . For example, if we forget index.md like so: julia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"]) it will not build and serve. \"It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to take away.\" - Antoine de Saint-Exupéry"},{"id":285,"pagetitle":"Constructors","title":"Constructors","ref":"/NamedTrajectories/dev/generated/man/constructors/#Constructors","content":" Constructors To construct a  NamedTrajectory  using NamedTrajectories.jl, we simply need to utilize the  NamedTrajectory  constructor. using NamedTrajectories\n\n# define number of timesteps and timestep\nT = 10\ndt = 0.1 0.1 build named tuple of components and data matrices. components = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = fill(dt, 1, T),\n) (x = [0.9628175240473713 0.3487349603966 … 0.6097651084688113 0.1624714001595805; 0.013306912633498591 0.6774438750446986 … 0.33347149967314493 0.5859441609043685; 0.8384223337590788 0.6700460098253304 … 0.564242121436599 0.3919177145913163], u = [0.41559161226644303 0.42038825033973015 … 0.8580970018915984 0.0665648417742346; 0.9889923080767276 0.9192976054727785 … 0.024770610926479586 0.5692319902643868], Δt = [0.1 0.1 … 0.1 0.1]) we must specify a timestep and control variable for the trajectory. timestep = :Δt\ncontrol = :u :u we can now create a  NamedTrajectory  object. traj = NamedTrajectory(components; timestep=timestep, controls=control) T = 10, (x = 1:3, u = 4:5, → Δt = 6:6) Construct  NamedTrajectory  from previous constructed one. traj = NamedTrajectory(components, traj) # TODO: should this constructor be reimplemented for v0.4.0? traj = NamedTrajectory(traj; components=(x=1:3, u=4:5, Δt=6:6)) T = 10, (x = 1:3, u = 4:5, → Δt = 6:6) This page was generated using  Literate.jl ."},{"id":288,"pagetitle":"Modifying trajectories","title":"Modifying trajectories","ref":"/NamedTrajectories/dev/generated/man/modifying/#Modifying-trajectories","content":" Modifying trajectories Modifying existing trajectories can be useful for a variety of reasons. Sometimes, you may want to change the values of the states, controls, or other components of the trajectory. Other times, you may want to add or remove components from the trajectory. using NamedTrajectories Create a random trajectory with 5 time steps, a state variable  x  of dimension 3, and a control variable  u  of dimension 2 traj = rand(NamedTrajectory, 5)\ntraj.names (:x, :u, :Δt) Add a new state variable  y  to the trajectory. Notice this is in-place. y_data = rand(4, 5)\ntraj = add_component(traj, :y, y_data)\ntraj.names (:x, :u, :Δt, :y) Remove the state variable  y  from the trajectory. This is not in place. restored_traj = remove_component(traj, :y)\nrestored_traj.names (:x, :u, :Δt)"},{"id":289,"pagetitle":"Modifying trajectories","title":"Adding suffixes","ref":"/NamedTrajectories/dev/generated/man/modifying/#Adding-suffixes","content":" Adding suffixes Another common operation is to add or remove a suffix from the components of a trajectory. This can be useful when you want to create a modified version of a trajectory that is related to the original trajectory in some way, or when you want to create a new trajectory that is a combination of two or more existing trajectories. For now, these tools are used to create a new trajectory. Add a suffix \"_new\" to the state variable  x modified_traj = add_suffix(traj, \"_modified\")\nmodified_traj.names (:x_modified, :u_modified, :Δt_modified, :y_modified) The modified trajectory contains the same data modified_traj.x_modified == traj.x true"},{"id":290,"pagetitle":"Modifying trajectories","title":"Merging trajectories","ref":"/NamedTrajectories/dev/generated/man/modifying/#Merging-trajectories","content":" Merging trajectories You can also merge two or more trajectories into a single trajectory. This can be useful when you want to combine data. Mergining trajectories is like taking a direct sum of the underlying data. Merge the original trajectory with the modified trajectory merged_traj = merge(traj, modified_traj)\nmerged_traj.names |> println (:x, :y, :x_modified, :y_modified, :u, :Δt, :u_modified, :Δt_modified) You can also extract a specific suffix from the components of a trajectory extracted_traj = get_suffix(merged_traj, \"_modified\")\nextracted_traj.names (:x_modified, :y_modified, :u_modified, :Δt_modified) If you want the original names, you can remove the suffix original_traj = get_suffix(merged_traj, \"_modified\", remove=true)\noriginal_traj.names (:x, :y, :u, :Δt)"},{"id":291,"pagetitle":"Modifying trajectories","title":"Merging with conflicts","ref":"/NamedTrajectories/dev/generated/man/modifying/#Merging-with-conflicts","content":" Merging with conflicts If there are any conflicting symbols, you can specify how to resolve the conflict. conflicting_traj = rand(NamedTrajectory, 5)\ntraj.names, conflicting_traj.names ((:x, :u, :Δt, :y), (:x, :u, :Δt)) In this case, keep the  u  data from the first trajectory and the  x  data and timestep from the second trajectory merged_traj = merge(traj, conflicting_traj; merge_names=(u=1, x=2, Δt=2))\nprintln(merged_traj.u == traj.u, \", \", merged_traj.u == conflicting_traj.u)\nprintln(merged_traj.x == traj.x, \", \", merged_traj.x == conflicting_traj.x) true, false\nfalse, true Merged names merged_traj.names (:y, :x, :u, :Δt)"},{"id":292,"pagetitle":"Modifying trajectories","title":"Advanced usage","ref":"/NamedTrajectories/dev/generated/man/modifying/#Advanced-usage","content":" Advanced usage Sometimes it may be desirable to have direct access to the underlying data matrix/vector associated with the trajectory. In other circumstances it is more useful to employ the built-in per-component and per-knot-point indexing functionality. We detail the relationship between these different methods of access here. traj = rand(NamedTrajectory, 5) T = 5, (x = 1:3, u = 4:5, → Δt = 6:6) The \"backing store\" of a  NamedTrajectory  is its  datavec  field, a  Vector{<:Real} : traj.datavec 30-element Vector{Float64}:\n  1.6354306966035863\n -0.4820292889723425\n -1.2769831017849889\n -0.08581985759536252\n -1.4223808183276458\n  1.0\n -1.1014478082355497\n  0.07078585610538077\n  0.15897439809817204\n -1.474852859105885\n  ⋮\n -1.2621765317138662\n -0.17798567947562388\n  1.0\n -0.6682321230943697\n -0.12416171693987821\n  0.8299457432154517\n  0.5680278863655875\n -0.5944955195280806\n  1.0 The  data  field holds a reshaped \"view\" of the \"backing store\", in a form that is somewhat easier to work with: traj.data 6×5 reshape(view(::Vector{Float64}, :), 6, 5) with eltype Float64:\n  1.63543    -1.10145    -1.17234     1.589     -0.668232\n -0.482029    0.0707859  -0.167242   -1.39737   -0.124162\n -1.27698     0.158974   -0.89103     0.133216   0.829946\n -0.0858199  -1.47485     0.660301   -1.26218    0.568028\n -1.42238     1.67645     0.0826623  -0.177986  -0.594496\n  1.0         1.0         1.0         1.0        1.0"},{"id":293,"pagetitle":"Modifying trajectories","title":"Indexing","ref":"/NamedTrajectories/dev/generated/man/modifying/#Indexing","content":" Indexing The  data  matrix is of dimension  (traj.dim, traj.T) , where  length(traj.names) == traj.dim The nth component's indices are given by  traj.components[traj.names[n]] println(traj.names)\nprintln(traj.components) (:x, :u, :Δt)\n(x = 1:3, u = 4:5, Δt = 6:6) For instance, the indices of a given component at a given knot point are given as follows: idx = 1 # x\nt = 3\nslice = traj.datavec[((t - 1) * traj.T) .+ traj.components[traj.names[idx]]]\nprintln(slice == traj[t].x == traj.x[:, t]) false More generally, the indices of a given component across all knot points are given as follows: idx = 1 # x\nprintln([((k - 1) * traj.dim) .+ getproperty(traj.components, traj.names[idx]) for k in 1:traj.T])\nidx = 2 # u\nprintln([((k - 1) * traj.dim) .+ getproperty(traj.components, traj.names[idx]) for k in 1:traj.T]) UnitRange{Int64}[1:3, 7:9, 13:15, 19:21, 25:27]\nUnitRange{Int64}[4:5, 10:11, 16:17, 22:23, 28:29]"},{"id":294,"pagetitle":"Modifying trajectories","title":"Writability","ref":"/NamedTrajectories/dev/generated/man/modifying/#Writability","content":" Writability"},{"id":295,"pagetitle":"Modifying trajectories","title":"Views and Backing Stores","ref":"/NamedTrajectories/dev/generated/man/modifying/#Views-and-Backing-Stores","content":" Views and Backing Stores In Julia, a \"view\" ( SubArray ) is intrinsically linked to some \"parent\" Array. Any in-place modification of one is reflected by the other. The following are \"safe\" operations on a NamedTrajectory (in-place modification of the  datavec ): traj = rand(NamedTrajectory, 5)\ntraj.datavec\nprintln(traj.datavec)\ntraj.datavec[1] *= 0.\nprintln(traj.datavec)\ntraj.datavec[:] = rand(length(traj.datavec))\nprintln(traj.datavec) [0.8028433760794489, 0.027456650872982578, 2.276915957698631, 1.103250253447141, -0.755961150412618, 1.0, 0.10894711432114726, -0.06611382643016923, -0.600630905167814, -1.8140211530942179, -1.1911668531582364, 1.0, -1.162039308713697, 1.8511348174408926, -0.2593852012179556, 0.3123529613981112, 1.0556950522959923, 1.0, -2.1959294556147264, 0.41624131334910924, -1.4517023212095712, -0.39068303067437504, -1.724277893996568, 1.0, 0.36598834880024306, 0.10296164032287432, -0.5936427498594017, 0.48053307871485607, 0.23479626979904836, 1.0]\n[0.0, 0.027456650872982578, 2.276915957698631, 1.103250253447141, -0.755961150412618, 1.0, 0.10894711432114726, -0.06611382643016923, -0.600630905167814, -1.8140211530942179, -1.1911668531582364, 1.0, -1.162039308713697, 1.8511348174408926, -0.2593852012179556, 0.3123529613981112, 1.0556950522959923, 1.0, -2.1959294556147264, 0.41624131334910924, -1.4517023212095712, -0.39068303067437504, -1.724277893996568, 1.0, 0.36598834880024306, 0.10296164032287432, -0.5936427498594017, 0.48053307871485607, 0.23479626979904836, 1.0]\n[0.8434156330545541, 0.41818378196693207, 0.09820861906668443, 0.639511117061102, 0.8217226148292688, 0.5460788302759556, 0.6770318059511068, 0.08566762925008964, 0.5178071999626173, 0.09714723738834785, 0.804474062652966, 0.7926548690274869, 0.772611491825437, 0.69946037640629, 0.08632893517158513, 0.6562064918164395, 0.10188169740937147, 0.6874467656161934, 0.5775892316630243, 0.3374559525469686, 0.01736540351710747, 0.08618165842433234, 0.2960619705212786, 0.7970377351745325, 0.172568788194442, 0.13760128276823524, 0.8503659954555058, 0.2964128870408852, 0.16340926594698246, 0.40970566491442295] The following is an example of an \"unsafe\" operation (non-in-place modification of the  datavec ): traj = rand(NamedTrajectory, 5)\nprintln(traj.datavec == traj.data[:])\ntraj.datavec = rand(length(traj.datavec))\nprintln(traj.datavec == traj.data[:]) # the `data` field now points to a \"backing store\" that is no longer accessible via `traj.datavec`; this will lead to undefined behavior: true\ntrue In general, reassigning the values of any of the fields of a trajectory may lead to undefined behavior: fieldnames(NamedTrajectory) (:datavec, :T, :timestep, :dim, :dims, :bounds, :initial, :final, :goal, :components, :names, :state_names, :control_names, :global_data, :global_dim, :global_dims, :global_components, :global_names) TODO: Prevent this issue by catching attempts to set sensitive fields in  Base.setproperty!(::NamedTrajectory, ::Symbol, ::Any)  ( datavec  and  data  are the primary concern in this regard; however, issuing a warning of some kind may be appropriate). Particularly because it is confusing that  traj.datavec = zeros(length(datavec))  is \"discouraged\", while  traj.x = zeros(traj.dims.x, traj.T)  and  traj[1].x = zeros(traj.dims.x)  are both valid."},{"id":296,"pagetitle":"Modifying trajectories","title":"Components and Knot Points","ref":"/NamedTrajectories/dev/generated/man/modifying/#Components-and-Knot-Points","content":" Components and Knot Points traj = rand(NamedTrajectory, 5) T = 5, (x = 1:3, u = 4:5, → Δt = 6:6) Trajectory components are accessible (as a \"view\") via  getproperty : traj.x 3×5 view(reshape(view(::Vector{Float64}, :), 6, 5), 1:3, :) with eltype Float64:\n  0.256047  0.32409   -0.759972   1.63493  -2.34927\n  0.575055  0.990308   0.261997  -0.77453   0.157425\n -2.11507   0.927518  -0.115837  -1.58901  -0.44308 Components are also writable via  setproperty! : traj.x = rand(traj.dims.x, traj.T)\ntraj.x 3×5 view(reshape(view(::Vector{Float64}, :), 6, 5), 1:3, :) with eltype Float64:\n 0.246747  0.736262  0.199643  0.795236  0.813822\n 0.554747  0.384812  0.98011   0.816128  0.603529\n 0.270326  0.494728  0.368658  0.792124  0.0220346 or may be modified directly: traj.x[1] *= 0.\ntraj.x 3×5 view(reshape(view(::Vector{Float64}, :), 6, 5), 1:3, :) with eltype Float64:\n 0.0       0.736262  0.199643  0.795236  0.813822\n 0.554747  0.384812  0.98011   0.816128  0.603529\n 0.270326  0.494728  0.368658  0.792124  0.0220346 Knot points are likewise accessible via  getindex : traj[1] KnotPoint{Float64, (:x, :u, :Δt), Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, Tuple{Symbol, Symbol, Symbol}, Tuple{Symbol, Symbol}}(1, [0.0, 0.5547474607566832, 0.2703260662402086, -0.5923966027291019, 1.3740095733414937, 1.0], 1.0, (x = 1:3, u = 4:5, Δt = 6:6), (:x, :u, :Δt), (:u, :Δt)) A  KnotPoint  behaves much like a  NamedTrajectory , with respect to getting, setting, and/or modifying its components: traj[1].u 2-element view(reshape(view(::Vector{Float64}, :), 6, 5), 4:5, 1) with eltype Float64:\n -0.5923966027291019\n  1.3740095733414937 traj[1].u = rand(traj.dims.u)\ntraj[1].u 2-element view(reshape(view(::Vector{Float64}, :), 6, 5), 4:5, 1) with eltype Float64:\n 0.4830057268512431\n 0.7968658091549703 traj[1].u[1] *= 0\ntraj[1].u 2-element view(reshape(view(::Vector{Float64}, :), 6, 5), 4:5, 1) with eltype Float64:\n 0.0\n 0.7968658091549703 The parent trajectory will reflect any modifications made in this fashion: traj.datavec 30-element Vector{Float64}:\n  0.0\n  0.5547474607566832\n  0.2703260662402086\n  0.0\n  0.7968658091549703\n  1.0\n  0.7362620774593057\n  0.38481203575290024\n  0.4947284515359086\n  1.0686536907280946\n  ⋮\n -0.5481862043675071\n  1.3205160085620342\n  1.0\n  0.8138221384567376\n  0.6035290154220926\n  0.022034630932233013\n -0.1625533769420321\n -0.1636028606842222\n  1.0 This page was generated using  Literate.jl ."},{"id":299,"pagetitle":"Parameters","title":"Parameters","ref":"/NamedTrajectories/dev/generated/man/params_in_struct/#Parameters","content":" Parameters NamedTrajectory.jl support passing parameters as a Tuple when construct a  NamedTrajectory . using NamedTrajectories First we need to define number of timesteps and timestep T = 10\ndt = 0.1 0.1 then build named tuple of components and data matrices. components = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = fill(dt, 1, T),\n) (x = [0.2718268609483908 0.6807075986710212 … 0.45636412558017747 0.7950523292289744; 0.20733397030861367 0.5959038696970981 … 0.2196728814923854 0.35337921490871194; 0.11759481701224228 0.03672851432177404 … 0.56628538262703 0.4494826490073661], u = [0.16005856816737685 0.8013351474681975 … 0.2015083319652453 0.3331687694794665; 0.7083704176275818 0.18001489149442085 … 0.3150393634292823 0.5365452924030382], Δt = [0.1 0.1 … 0.1 0.1]) we must specify a timestep and control variable for the trajectory. timestep = :Δt\ncontrol = :u :u some global params as a NamedTuple params = (\n    α = rand(1),\n    β = rand(1)\n) (α = [0.06505918676797695], β = [0.9821467682535238]) we can now create a  NamedTrajectory  object with parameters specification. traj = NamedTrajectory(components, params; timestep=timestep, controls=control) T = 10, (x = 1:3, u = 4:5, → Δt = 6:6), (α = 1:1, β = 2:2) This page was generated using  Literate.jl ."},{"id":302,"pagetitle":"Plotting","title":"Plotting","ref":"/NamedTrajectories/dev/generated/plotting/#Plotting","content":" Plotting Visualizing trajectories is crucial for understanding the solutions of trajectory optmization problems and  NamedTrajectories  exports a  plot  function that contains a lot of functionality that is continually being added to. Makie.jl  is used as the plotting framework. An extension package is used to load plotting functionality whenever a version of Makie is installed in the current environment. For example, use  CairoMakie  to creates high quality vector graphics. The main recipe for named trajectory plotting is as follows:"},{"id":303,"pagetitle":"Plotting","title":"NamedTrajectories.Plotting.plot_name","ref":"/NamedTrajectories/dev/generated/plotting/#NamedTrajectories.Plotting.plot_name-generated-plotting","content":" NamedTrajectories.Plotting.plot_name  —  Function plot_name(traj::NamedTrajectory, name::Symbol; kwargs...) Plot a single component of a  NamedTrajectory  using Makie. The default plot type is  Series . Series attributes can be passed as keyword arguments. source The  plot  function is a wrapper around  plot_name  that allows for easy plotting of  NamedTrajectory  objects. The  plot  function has the following signature: plot(traj::NamedTrajectory, args...; kwargs...)"},{"id":304,"pagetitle":"Plotting","title":"Basic example","ref":"/NamedTrajectories/dev/generated/plotting/#Basic-example","content":" Basic example Use a Makie backend to automatically load the NamedTrajectories plotting extension using CairoMakie\nusing NamedTrajectories\n\n# define the number timestamps\nT = 100\nΔt = 0.1\nts = [0:T-1...] * Δt\n\n# define sinusoidal state trajectories\nX = zeros(3, T)\nX[1, :] = sin.(3 * 2π * ts / (2 * (T - 1) * Δt))\nX[2, :] = -sin.(5 * 2π * ts / (2 * (T - 1) * Δt))\nX[3, :] = sin.(9 * 2π * ts / (2 * (T - 1) * Δt))\n\n# define gaussian shaped controls\nU = stack(\n    [\n        exp.(-((ts .- ts[length(ts)÷3]) / 2.0).^2) .* sin.(5.0 * ts),\n        exp.(-((ts .- ts[2(length(ts)÷3)]) / 1.5).^2) .* sin.(4.0 * ts)\n    ];\n    dims=1\n)\nV = exp.(-((ts .- ts[length(ts)÷2]) ./ 1.5).^2) .* sin.(6.0 * ts)\n\n# create the trajectory\ntraj = NamedTrajectory(\n    (\n        x=X,\n        u=U,\n        v=V,\n        Δt=fill(Δt, T),\n    );\n    timestep=:Δt,\n    controls=(:u, :v)\n)\n\n# plot the trajectory\nplot(traj)"},{"id":305,"pagetitle":"Plotting","title":"Selectively plotting components","ref":"/NamedTrajectories/dev/generated/plotting/#Selectively-plotting-components","content":" Selectively plotting components We can selectively plot components of the trajectory by passing a  Vector  of  Symbol s to the  components  keyword argument. For example, if we only wanted to plot the state and the first control we could do the following: plot(traj, [:x, :u])"},{"id":306,"pagetitle":"Plotting","title":"Playing with transformations","ref":"/NamedTrajectories/dev/generated/plotting/#Playing-with-transformations","content":" Playing with transformations We can also apply transformations to the components of the trajectory. Transformations are performed on columns of the data. For example, if we wanted to plot absolute values of the states we could do the following: transformations = [(:x => x -> abs.(x))]\n\nplot(traj, [:x]; transformations=transformations) We can also pass multiple transformations to the same component, with selective labels and titles: # define the transformations\ntransformations = [\n    (:x => x -> [x[1] + x[2], x[3] - x[2]]),\n    (:x => x -> [x[1] - x[2], x[3] + x[2]])\n]\n\n# plot the trajectory, with only the transformation and the `u` control\nplot(traj, [:u]; transformations=transformations,) This page was generated using  Literate.jl ."},{"id":309,"pagetitle":"Quickstart Guide","title":"Quickstart Guide","ref":"/NamedTrajectories/dev/generated/quickstart/#Quickstart-Guide","content":" Quickstart Guide"},{"id":310,"pagetitle":"Quickstart Guide","title":"Getting set up","ref":"/NamedTrajectories/dev/generated/quickstart/#Getting-set-up","content":" Getting set up To install  NamedTrajectories  simply enter the package manager in the Julia REPL with  ]  and run pkg> add NamedTrajectories Then just use the package as usual with using NamedTrajectories For the following examples let's work with a simple trajectory \\[\\qty{z_t = \\mqty(x_t \\\\ u_t)}_{t=1:T}\\] where  $x_t$  is the state and  $u_t$  is the control at a time indexed by  $t$ . Together  $z_t$  is referred to as a  knot point  and a  NamedTrajectory  essentially just stores a collection of knot points and makes it easy to access the state and control variables."},{"id":311,"pagetitle":"Quickstart Guide","title":"Creating a variable-timestep NamedTrajectory","ref":"/NamedTrajectories/dev/generated/quickstart/#Creating-a-variable-timestep-NamedTrajectory","content":" Creating a variable-timestep  NamedTrajectory Here we will create a  NamedTrajectory  with a variable timestep. # define the number of timesteps\nT = 10\nΔt = 0.1\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = fill(Δt, T),\n)\n\n# we must specify a timestep and control variable for the NamedTrajectory.\ntimestep = :Δt\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(data; timestep=timestep, controls=control)\n\n# we can return the names of the stored variables\ntraj.names (:x, :u, :Δt)"},{"id":312,"pagetitle":"Quickstart Guide","title":"Adding more problem data","ref":"/NamedTrajectories/dev/generated/quickstart/#Adding-more-problem-data","content":" Adding more problem data In many settings we will want to specify the problem data of our  NamedTrajectory  – e.g. bounds, initial values, final values, and goal values. # define the number of timesteps\nT = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = rand(T),\n)\n\n# define initial values\ninitial = (\n    x = [1.0, 0.0, 0.0],\n    u = [0.0, 0.0],\n)\n\n# define final value, here just on the control\nfinal = (\n    u = [0.0, 0.0],\n)\n\n# define bounds\nbounds = (\n    x = 1.0,\n    u = 1.0\n)\n\n# set a goal for the state\ngoal = (\n    x = [0.0, 0.0, 1.0],\n)\n\n# we must specify a timestep and control variable for the NamedTrajectory\ntimestep = :Δt\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(\n    data;\n    timestep=timestep,\n    controls=control,\n    initial=initial,\n    final=final,\n    bounds=bounds,\n    goal=goal\n)\n\n# we can then show the bounds\ntraj.bounds (x = ([-1.0, -1.0, -1.0], [1.0, 1.0, 1.0]), u = ([-1.0, -1.0], [1.0, 1.0]))"},{"id":313,"pagetitle":"Quickstart Guide","title":"Retrieving data","ref":"/NamedTrajectories/dev/generated/quickstart/#Retrieving-data","content":" Retrieving data There are a number of ways to access data, for example traj.x 3×10 view(reshape(view(::Vector{Float64}, :), 6, 10), 1:3, :) with eltype Float64:\n 0.234899  0.282492  0.618059  0.725283  …  0.659934  0.165419  0.693729\n 0.387263  0.110341  0.958561  0.394752     0.777666  0.454633  0.841186\n 0.463879  0.54179   0.597356  0.151702     0.270157  0.17907   0.563139 returns the data matrix associated with the state variable  x . traj.data 6×10 reshape(view(::Vector{Float64}, :), 6, 10) with eltype Float64:\n 0.234899  0.282492   0.618059   0.725283  …  0.659934  0.165419  0.693729\n 0.387263  0.110341   0.958561   0.394752     0.777666  0.454633  0.841186\n 0.463879  0.54179    0.597356   0.151702     0.270157  0.17907   0.563139\n 0.71582   0.89088    0.0198109  0.97469      0.860554  0.767788  0.668355\n 0.256218  0.0146609  0.802187   0.484401     0.898134  0.729091  0.751755\n 0.26408   0.492589   0.950954   0.681639  …  0.507405  0.341683  0.695943 returns the all of the data as a matrix where each column is a knot point. traj.datavec 60-element Vector{Float64}:\n 0.2348985406852031\n 0.38726264151004763\n 0.46387866191280136\n 0.7158202890419685\n 0.2562175040218829\n 0.26407986520510707\n 0.2824921755138401\n 0.11034080379560107\n 0.5417899693470425\n 0.8908803914985743\n ⋮\n 0.767787840205316\n 0.7290905476336951\n 0.34168303328293437\n 0.6937294587364305\n 0.8411860316620383\n 0.5631386792269946\n 0.6683550273460511\n 0.7517550872073977\n 0.6959428893544926 returns the all of the data as a view of the data matrix as a vector – useful for passing data to solvers. traj[1] KnotPoint{Float64, (:x, :u, :Δt), Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, Tuple{Symbol, Symbol, Symbol}, Tuple{Symbol, Symbol}}(1, [0.2348985406852031, 0.38726264151004763, 0.46387866191280136, 0.7158202890419685, 0.2562175040218829, 0.26407986520510707], 0.26407986520510707, (x = 1:3, u = 4:5, Δt = 6:6), (:x, :u, :Δt), (:u, :Δt)) returns a  KnotPoint . traj[1].x 3-element view(reshape(view(::Vector{Float64}, :), 6, 10), 1:3, 1) with eltype Float64:\n 0.2348985406852031\n 0.38726264151004763\n 0.46387866191280136 returns the state at the first knot point. get_times(traj) 10-element Vector{Float64}:\n 0.0\n 0.26407986520510707\n 0.7566686325653337\n 1.7076221416898565\n 2.3892607008886095\n 3.3437714847444235\n 4.160569502738081\n 5.118876245751638\n 5.626280945500885\n 5.9679639787838195 returns the times of the knot points. get_timesteps(traj) 10-element reshape(view(reshape(view(::Vector{Float64}, :), 6, 10), 6:6, :), 10) with eltype Float64:\n 0.26407986520510707\n 0.4925887673602266\n 0.9509535091245227\n 0.6816385591987532\n 0.9545107838558141\n 0.8167980179936574\n 0.9583067430135565\n 0.5074046997492473\n 0.34168303328293437\n 0.6959428893544926 returns the timesteps of the knot points, as vector."},{"id":314,"pagetitle":"Quickstart Guide","title":"Retrieving metadata","ref":"/NamedTrajectories/dev/generated/quickstart/#Retrieving-metadata","content":" Retrieving metadata We can also retrieve metadata about the trajectory, for example traj.names (:x, :u, :Δt) returns the names of the variables stored in the trajectory. traj.dims (x = 3, u = 2, Δt = 1) returns the dimensions of the variables stored in the trajectory. traj.T 10 returns the number of knot points in the trajectory. traj.components (x = 1:3, u = 4:5, Δt = 6:6) returns the components of the trajectory."},{"id":315,"pagetitle":"Quickstart Guide","title":"Updating problem data","ref":"/NamedTrajectories/dev/generated/quickstart/#Updating-problem-data","content":" Updating problem data The  NamedTrajectory  can be updated by accessing fields and replacing the data. We also have  update!  to update trajectory components, and   update_bound! , which allows you to pass in the same kinds of bounds available at construction (e.g., an  Int  or  Tuple ). The bound will get shaped to match the trajectory component dimensions just like at construction. These methods cannot be used to update non-existent bounds or components. For efficiency, a trajectory cannot add new data after it is constructed. However, we have convenience methods like  add_component  that build a new trajectory with added data. update_bound!(traj, :x, 2.) # TODO: consider fleshing out this section with more examples of updating trajectory components, knot points, globals, bounds, etc. This page was generated using  Literate.jl ."},{"id":318,"pagetitle":"Library","title":"API","ref":"/NamedTrajectories/dev/lib/#API","content":" API"},{"id":319,"pagetitle":"Library","title":"NamedTrajectory methods","ref":"/NamedTrajectories/dev/lib/#NamedTrajectory-methods","content":" NamedTrajectory methods"},{"id":320,"pagetitle":"Library","title":"Base.merge","ref":"/NamedTrajectories/dev/lib/#Base.merge-Tuple{NamedTrajectory, NamedTrajectory}","content":" Base.merge  —  Method merge(traj1::NamedTrajectory, traj2::NamedTrajectory)\nmerge(trajs::AbstractVector{<:NamedTrajectory}) Returns a new NamedTrajectory object by merging  NamedTrajectory  objects.  Merge names are used to specify which components to merge by index. If no merge names are provided, all components are merged and name collisions are not allowed. If merge names are provided, the names are merged using the data from the index provided in the merge names. Keyword Arguments timestep::Symbol : The timestep symbol to use for free time problems. Default to the last trajectory. merge_names::Union{Nothing, NamedTuple{<:Any, <:Tuple{Vararg{Int}}}}=nothing : The names to merge by index. source"},{"id":321,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_component","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.add_component-Tuple{NamedTrajectory, Symbol, AbstractVecOrMat{Float64}}","content":" NamedTrajectories.MethodsNamedTrajectory.add_component  —  Method add_component(traj, name::Symbol, data::AbstractVecOrMat) Add a component to the trajectory. Keyword arguments:     -  type::Symbol : The type of the component, can be  :state ,  :control ,  :slack , or  :global . Default is  :state . source"},{"id":322,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_components","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.add_components-Tuple{NamedTrajectory, NamedTuple}","content":" NamedTrajectories.MethodsNamedTrajectory.add_components  —  Method add_components(traj, comps) Add components to the trajectory. Keyword arguments:     -  type::Symbol : The type of the component, can be  :state ,  :control ,  :slack , or  :global . Default is  :state . source"},{"id":323,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_suffix","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.add_suffix","content":" NamedTrajectories.MethodsNamedTrajectory.add_suffix  —  Function add_suffix(obj::T, suffix::String) Add the suffix to the symbols of the object. source"},{"id":324,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_component_names","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.get_component_names-Tuple{NamedTrajectory, AbstractVector{Int64}}","content":" NamedTrajectories.MethodsNamedTrajectory.get_component_names  —  Method get_component_names(traj::NamedTrajectory, comps::AbstractVector{<:Int}) Returns the name of the component with the given indices. If only one component is found, the name is returned as a single symbol. Else, the names are returned as a vector of symbols. The filter requires that the components are a complete subset of the given indices, so that a partial match is excluded from the returned names. source"},{"id":325,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_components","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.get_components-Tuple{Union{Tuple, AbstractVector}, NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_components  —  Method get_components(names, ::NamedTrajectory) Returns a NamedTuple containing the names and corresponding data matrices of the trajectory. source"},{"id":326,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_duration","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.get_duration-Tuple{NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_duration  —  Method get_duration(::NamedTrajectory) Returns the duration of a trajectory. source"},{"id":327,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_suffix","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.get_suffix","content":" NamedTrajectories.MethodsNamedTrajectory.get_suffix  —  Function get_suffix(obj::T, suffix::String; remove::Bool=false) Get the data with the suffix from the object. Remove the suffix if  remove=true . source"},{"id":328,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_times","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.get_times-Tuple{NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_times  —  Method get_times(traj)::Vector{Float64} Returns the times of a trajectory as a vector. source"},{"id":329,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_timesteps","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.get_timesteps-Tuple{NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_timesteps  —  Method get_timesteps(::NamedTrajectory) Returns the timesteps of a trajectory as a vector. source"},{"id":330,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.merge_outer","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.merge_outer-Tuple{AbstractVector}","content":" NamedTrajectories.MethodsNamedTrajectory.merge_outer  —  Method merge_outer(objs::AbstractVector{<:Any}) Merge objects. An error is reported if a key collision is detected. source"},{"id":331,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_component","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.remove_component-Tuple{NamedTrajectory, Symbol}","content":" NamedTrajectories.MethodsNamedTrajectory.remove_component  —  Method remove_component(traj, name::Symbol) Remove a component from the trajectory. source"},{"id":332,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_components","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.remove_components-Tuple{NamedTrajectory, AbstractVector{<:Symbol}}","content":" NamedTrajectories.MethodsNamedTrajectory.remove_components  —  Method remove_components(traj, names::Vector{Symbol}) Remove a set of components from the trajectory. source"},{"id":333,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_suffix","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.remove_suffix","content":" NamedTrajectories.MethodsNamedTrajectory.remove_suffix  —  Function remove_suffix(obj::T, suffix::String) Remove the suffix from the symbols of the object. source"},{"id":334,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update!","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.update!-Tuple{NamedTrajectory, AbstractVector{Float64}}","content":" NamedTrajectories.MethodsNamedTrajectory.update!  —  Method update!(traj, datavec::AbstractVector{Float64}) Update the trajectory with a new datavec. Keyword arguments:     -  type::Symbol : The type of the datavec, can be  :data ,  :global , or  :both . Default is  global . source"},{"id":335,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update!","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.update!-Tuple{NamedTrajectory, Symbol, AbstractMatrix{Float64}}","content":" NamedTrajectories.MethodsNamedTrajectory.update!  —  Method update!(traj, name::Symbol, data::AbstractMatrix{Float64}) Update a component of the trajectory. source"},{"id":336,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update_bound!","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsNamedTrajectory.update_bound!-Tuple{NamedTrajectory, Symbol, Any}","content":" NamedTrajectories.MethodsNamedTrajectory.update_bound!  —  Method update_bound!(traj, name, new_bound) Update the bound of a component of the trajectory. source"},{"id":337,"pagetitle":"Library","title":"Base.getproperty","ref":"/NamedTrajectories/dev/lib/#Base.getproperty-Tuple{KnotPoint, Symbol}","content":" Base.getproperty  —  Method getproperty(slice::KnotPoint, symb::Symbol) Returns the component of the knot point with name  symb  (as a view) or the property of the knot point with name  symb . source"},{"id":338,"pagetitle":"Library","title":"Base.setproperty!","ref":"/NamedTrajectories/dev/lib/#Base.setproperty!-Tuple{KnotPoint, Symbol, Any}","content":" Base.setproperty!  —  Method setproperty!(slice::KnotPoint, symb::Symbol, val::Any) Dispatches setting properties of knot points as either setting a component or a property via  update!  or  setfield! , respectively. source"},{"id":339,"pagetitle":"Library","title":"NamedTrajectories.MethodsKnotPoint.update!","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.MethodsKnotPoint.update!-Tuple{KnotPoint, Symbol, AbstractVector{Float64}}","content":" NamedTrajectories.MethodsKnotPoint.update!  —  Method update!(slice::KnotPoint, symb::Symbol, data::AbstractVector{Float64}) Update a component of the knot point. source"},{"id":340,"pagetitle":"Library","title":"Random trajectory methods","ref":"/NamedTrajectories/dev/lib/#Random-trajectory-methods","content":" Random trajectory methods"},{"id":341,"pagetitle":"Library","title":"Base.rand","ref":"/NamedTrajectories/dev/lib/#Base.rand-Tuple{Type{NamedTrajectory}, Int64}","content":" Base.rand  —  Method rand(\n    ::Type{NamedTrajectory},\n    T::Int;\n    timestep_value::Float64=1.0,\n    timestep_name::Symbol=:Δt,\n    timestep::Union{Float64,Symbol}=free_time ? timestep_name : timestep_value,\n    state_dim::Int=3,\n    control_dim::Int=2\n) Create a random  NamedTrajectory  with  T  time steps, a state variable  x  of dimension   state_dim , and a control variable  u  of dimension  control_dim . The time step is a symbol  timestep_name  and the time step value is  timestep_value .  source"},{"id":342,"pagetitle":"Library","title":"Struct Methods","ref":"/NamedTrajectories/dev/lib/#Struct-Methods","content":" Struct Methods"},{"id":343,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Type NamedTrajectory{R <: Real} Container for trajectory optimization problems, which includes the trajectory data, bounds dimensions, initial and final conditions, goal states, and components. This struct is designed to hold trajectory data in a named format, allowing for easy access to knot points by  Symbol . NamedTrajectory is designed to make allocation-free access easy to write. The data can be updated after construction, but the fields cannot. source"},{"id":344,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Tuple{NamedTuple{N, <:Tuple{Vararg{AbstractMatrix{<:Real}}}} where N, NamedTuple{GN, <:Tuple{Vararg{AbstractVector{<:Real}}}} where GN}","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Method NamedTrajectory(component_data, global_components_data) Construct a  NamedTrajectory  from component data and global component data source"},{"id":345,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Tuple{NamedTuple{N, <:Tuple{Vararg{AbstractMatrix{<:Real}}}} where N}","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Method NamedTrajectory(component_data) Construct a  NamedTrajectory  from component data. source"},{"id":346,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Tuple{NamedTuple{N, <:Tuple{Vararg{AbstractVecOrMat{<:Real}}}} where N}","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Method NamedTrajectory(component_data::NamedTuple, timestep; kwargs...) Construct a  NamedTrajectory  from mixed Matrix/Vector component data. source"},{"id":347,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{NamedTrajectory}, Tuple{R}} where R<:Real","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Method NamedTrajectory(data, traj) Construct a  NamedTrajectory  from an existing  NamedTrajectory . source"},{"id":348,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{R}, Tuple{AbstractMatrix{R}, NamedTuple{N, <:Tuple{Vararg{UnitRange{Int64}}}} where N}} where R<:Real","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Method NamedTrajectory(data, components; kwargs...) Construct a  NamedTrajectory  from a data matrix and components. source"},{"id":349,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{R}, Tuple{AbstractVector{R}, NamedTuple{N, <:Tuple{Vararg{UnitRange{Int64}}}} where N, Int64}} where R<:Real","content":" NamedTrajectories.StructNamedTrajectory.NamedTrajectory  —  Method NamedTrajectory(datavec, components, T) Construct a named trajectory from a data vector, components, and knot points. source"},{"id":350,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.get_bounds_from_dims","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.get_bounds_from_dims-Tuple{NamedTuple, NamedTuple{<:Any, <:Tuple{Vararg{Int64}}}}","content":" NamedTrajectories.StructNamedTrajectory.get_bounds_from_dims  —  Method get_bounds_from_dims(bounds, dims; dtype=Float64) Process  bounds  from allowed types using  dims  and convert to  dtype . source"},{"id":351,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.inspect_dims_pairs","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.inspect_dims_pairs-Union{Tuple{R}, Tuple{Vector{Pair{Symbol, Int64}}, NamedTuple{bname, <:Tuple{Vararg{Tuple{R⃗, R⃗}}} where R⃗<:AbstractVector{R}} where bname, NamedTuple{iname, <:Tuple{Vararg{R⃗}} where R⃗<:AbstractVector{R}} where iname, NamedTuple{fname, <:Tuple{Vararg{R⃗}} where R⃗<:AbstractVector{R}} where fname, NamedTuple{gname, <:Tuple{Vararg{R⃗}} where R⃗<:AbstractVector{R}} where gname}} where R<:Real","content":" NamedTrajectories.StructNamedTrajectory.inspect_dims_pairs  —  Method inspect_dims_pairs(dims_pairs, bounds, initial, final, goal) Check for proper formatting of trajectory components. source"},{"id":352,"pagetitle":"Library","title":"NamedTrajectories.StructNamedTrajectory.inspect_names","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructNamedTrajectory.inspect_names-NTuple{6, Tuple{Vararg{Symbol}}}","content":" NamedTrajectories.StructNamedTrajectory.inspect_names  —  Method inspect_names(names, controls, initial, final, goal, bounds) Check for missing names in the trajectory components. source"},{"id":353,"pagetitle":"Library","title":"NamedTrajectories.StructKnotPoint.KnotPoint","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.StructKnotPoint.KnotPoint","content":" NamedTrajectories.StructKnotPoint.KnotPoint  —  Type KnotPoint constructor source"},{"id":354,"pagetitle":"Library","title":"Trajectory Utilities","ref":"/NamedTrajectories/dev/lib/#Trajectory-Utilities","content":" Trajectory Utilities"},{"id":355,"pagetitle":"Library","title":"NamedTrajectories.Utils.derivative","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.Utils.derivative-Tuple{AbstractMatrix, AbstractVecOrMat}","content":" NamedTrajectories.Utils.derivative  —  Method derivative(X::AbstractMatrix, Δt::AbstractVecOrMat)\nderivative(X::AbstractMatrix, Δt::Float64) Compute the derivative of the data matrix  X . source"},{"id":356,"pagetitle":"Library","title":"NamedTrajectories.Utils.integral","ref":"/NamedTrajectories/dev/lib/#NamedTrajectories.Utils.integral-Tuple{AbstractMatrix, AbstractVector}","content":" NamedTrajectories.Utils.integral  —  Method integral(X::AbstractMatrix, Δt::AbstractVector)\nintegral(X::AbstractMatrix, Δt::Float64) Compute the integral of the data matrix  X . source"},{"id":359,"pagetitle":"Home","title":"TrajectoryIndexingUtils.jl","ref":"/TrajectoryIndexingUtils/dev/#TrajectoryIndexingUtils.jl","content":" TrajectoryIndexingUtils.jl This is a super lightweight package that exports two functions:  index  and  slice .  These functions have helped to ease the burden of handling messy indexing into trajectory data vectors of the form  \\[\\vec Z = \\text{vec}\\left(z_1, z_2, \\ldots, z_T\\right) \\in \\mathbf{R}^{T \\cdot d}\\] where each element  $z_t$  is referred to as a  knot point  and normally contains  state  variables and  control  variables. In a simple situation we might have  $z_t = \\text{vec} (x_t, u_t) \\in \\mathbf{R}^{d = n+m}$ , for the state  $x_t \\in \\mathbf{R}^n$  and control  $u_t \\in \\mathbf{R}^m$ .  In this case, with   dim = n + m , we can use  slice  and  index , to extract what we want from  $\\vec Z$  in the following way: extract  $z_t$ :    julia   zₜ = Z⃗[slice(t, dim)] extract  $x_t$ :    julia   xₜ = Z⃗[slice(t, 1:n, dim)] extract  $u_t$ :    julia   uₜ = Z⃗[slice(t, (1:m) .+ n, dim)] extract  $i$ -th component of  $x_t$ :    julia   xₜⁱ = Z⃗[index(t, i, dim)] extract  $j$ -th component of  $u_t$ :    julia   uₜʲ = Z⃗[index(t, j + n, dim)] With this, the user is still responsible for keeping track of the component indices for  $x$  and  $u$ , and possibly other variables. To alleviate this nuisance, the package  NamedTrajectories.jl  provides a richer alternative for handling trajectory data with arbitrarily named components, please check it out!"},{"id":360,"pagetitle":"Home","title":"Installation","ref":"/TrajectoryIndexingUtils/dev/#Installation","content":" Installation TrajectoryIndexingUtils.jl is registered! Install in the REPL by entering pkg mode with  ]  and then running  pkg> add TrajectoryIndexingUtils"},{"id":361,"pagetitle":"Home","title":"Methods","ref":"/TrajectoryIndexingUtils/dev/#Methods","content":" Methods"},{"id":362,"pagetitle":"Home","title":"The index function","ref":"/TrajectoryIndexingUtils/dev/#The-index-function","content":" The  index  function index(t::Int, dim::Int) -> zₜ[dim]\nindex(t::Int, pos::Int, dim::Int) -> zₜ[pos]"},{"id":363,"pagetitle":"Home","title":"The slice function","ref":"/TrajectoryIndexingUtils/dev/#The-slice-function","content":" The  slice  function slice(t::Int, dim::Int; stretch=0) -> zₜ[1:dim + stretch] # can be used to extract, e.g., [xₜ; xₜ₊₁], with stretch = dim\nslice(t::Int, pos::Int, dim::Int) -> zₜ[1:pos]\nslice(t::Int, pos1::Int, pos2::Int, dim::Int) -> zₜ[pos1:pos2]\nslice(t::Int, indices::AbstractVector{Int}, dim::Int) -> zₜ[indices]\nslice(ts::UnitRange{Int}, dim::Int) -> vec(zₜ for t ∈ ts)"},{"id":364,"pagetitle":"Home","title":"Building Documentation","ref":"/TrajectoryIndexingUtils/dev/#Building-Documentation","content":" Building Documentation This package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility.  # first time only\n./docs/get_docs_utils.sh   # or ./get_docs_utils.sh if cwd is in ./docs/ To build the docs pages: julia --project=docs docs/make.jl or editing the docs live: julia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(skip_files=[\"docs/src/index.md\"]) Note: servedocs  needs to watch a subset of the files in the  docs/  folder. If it watches files that are generated on a docs build/re-build,  servedocs  will continuously try to re-serve the pages. To prevent this, ensure all generated files are included in the skip dirs or skip files args for  servedocs . For example, if we forget index.md like so: julia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs() it will not build and serve. \"It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to take away.\" - Antoine de Saint-Exupéry"},{"id":367,"pagetitle":"Library","title":"TrajectoryIndexingUtils methods","ref":"/TrajectoryIndexingUtils/dev/lib/#TrajectoryIndexingUtils-methods","content":" TrajectoryIndexingUtils methods This module contains helper functions for indexing and taking slices of the full problem variable vector definitions: problem vector:    Z = [z₁, z₂, ..., zₜ] knot point:   zₜ = [xₜ, uₜ] augmented state vector:   xₜ = [ψ̃ₜ, ψ̃²ₜ, ..., ψ̃ⁿₜ, ∫aₜ, aₜ, daₜ, ..., dᶜ⁻¹aₜ] where c = control_order also, below, we use  dim(zₜ) = dim  examples: Z[index(t, pos, dim)]               = zₜ[pos]\nZ[index(t, dim)]                    = zₜ[dim]\nZ[slice(t, pos1, pos2, dim)]        = zₜ[pos1:pos2]\nZ[slice(t, pos, dim)]               = zₜ[1:pos]\nZ[slice(t, dim)]                    = zₜ[1:dim] := zₜ\nZ[slice(t, dim; stretch=stretch)]   = zₜ[1:(dim + stretch)]\nZ[slice(t, indices, dim)]           = zₜ[indices]\nZ[slice(t1:t2, dim)]                = [zₜ₁;...;zₜ₂] The functions are also used to access the zₜ vectors, e.g. zₜ[slice(i, isodim)]                             = ψ̃ⁱₜ\nzₜ[n_wfn_states .+ slice(1, ncontrols)]          = ∫aₜ\nzₜ[n_wfn_states .+ slice(2, ncontrols)]          = aₜ\nzₜ[n_wfn_states .+ slice(augdim + 1, ncontrols)] = uₜ = ddaₜ Examples below are run with: using TrajectoryIndexingUtils\nZ = collect(1.5:12.5)  # Example vector as Float64\ndim = 3  # Example dimension"},{"id":368,"pagetitle":"Library","title":"API","ref":"/TrajectoryIndexingUtils/dev/lib/#API","content":" API"},{"id":369,"pagetitle":"Library","title":"TrajectoryIndexingUtils.index","ref":"/TrajectoryIndexingUtils/dev/lib/#TrajectoryIndexingUtils.index-Tuple{Any, Any}","content":" TrajectoryIndexingUtils.index  —  Method index(t::Int, dim::Int) Calculate the index in the full problem vector for a given time step  t  and dimension  dim . Assumes  pos  is equal to  dim . julia> Z[index(1, dim)]\n3.5 source"},{"id":370,"pagetitle":"Library","title":"TrajectoryIndexingUtils.index","ref":"/TrajectoryIndexingUtils/dev/lib/#TrajectoryIndexingUtils.index-Tuple{Int64, Int64, Int64}","content":" TrajectoryIndexingUtils.index  —  Method index(t::Int, pos::Int, dim::Int) Calculate the index in the full problem vector for a given time step  t , position  pos , and dimension  dim . julia> Z[index(1, 1, 3)]\n1.5 source"},{"id":371,"pagetitle":"Library","title":"TrajectoryIndexingUtils.slice","ref":"/TrajectoryIndexingUtils/dev/lib/#TrajectoryIndexingUtils.slice-NTuple{4, Int64}","content":" TrajectoryIndexingUtils.slice  —  Method slice(t::Int, pos1::Int, pos2::Int, dim::Int) Calculate slice of the full problem vector for a given time step  t , starting position  pos1 , and ending position  pos2 . julia> Z[slice(2, 1, 3, 3)]\n3-element Vector{Float64}:\n 4.5\n 5.5\n 6.5 source"},{"id":372,"pagetitle":"Library","title":"TrajectoryIndexingUtils.slice","ref":"/TrajectoryIndexingUtils/dev/lib/#TrajectoryIndexingUtils.slice-Tuple{Int64, AbstractVector{Int64}, Int64}","content":" TrajectoryIndexingUtils.slice  —  Method slice(t::Int, indices::AbstractVector{Int}, dim::Int) Calculate slice of the problem vector for a given time step  t  and a vector of indices  indices . julia> Z[slice(2, [1, 3], 3)]\n2-element Vector{Float64}:\n 4.5\n 6.5 source"},{"id":373,"pagetitle":"Library","title":"TrajectoryIndexingUtils.slice","ref":"/TrajectoryIndexingUtils/dev/lib/#TrajectoryIndexingUtils.slice-Tuple{Int64, Int64, Int64}","content":" TrajectoryIndexingUtils.slice  —  Method slice(t::Int, pos::Int, dim::Int) Calculate slice of the problem vector for a given time step  t , up to position  pos . Equivalent to  slice(t, 1, pos, dim) .' julia> Z[slice(2, 2, 3)]\n2-element Vector{Float64}:\n 4.5\n 5.5 source"},{"id":374,"pagetitle":"Library","title":"TrajectoryIndexingUtils.slice","ref":"/TrajectoryIndexingUtils/dev/lib/#TrajectoryIndexingUtils.slice-Tuple{Int64, Int64}","content":" TrajectoryIndexingUtils.slice  —  Method slice(t::Int, dim::Int; stretch=0) Calculate slice of the problem vector for a given time step  t , with an optional stretch parameter julia> Z[slice(2, 3; stretch=1)]\n4-element Vector{Float64}:\n 4.5\n 5.5\n 6.5\n 7.5 source"},{"id":375,"pagetitle":"Library","title":"TrajectoryIndexingUtils.slice","ref":"/TrajectoryIndexingUtils/dev/lib/#TrajectoryIndexingUtils.slice-Tuple{UnitRange{Int64}, Int64}","content":" TrajectoryIndexingUtils.slice  —  Method slice(ts::UnitRange{Int}, dim::Int) Calculate slice of the problem vector for a range of time steps  ts  that covers each of the knot-points in those steps. julia> Z[slice(1:2, 3)]\n6-element Vector{Float64}:\n 1.5\n 2.5\n 3.5\n 4.5\n 5.5\n 6.5 source"},{"id":378,"pagetitle":"Home","title":"PiccoloPlots.jl","ref":"/PiccoloPlots/dev/#PiccoloPlots.jl","content":" PiccoloPlots.jl PiccoloPlots.jl  is designed to hold plotting recipes for the Piccolo.jl package. It utilzes the  plot  method of the  NamedTrajectories.jl ."},{"id":379,"pagetitle":"Home","title":"Installation","ref":"/PiccoloPlots/dev/#Installation","content":" Installation PiccoloPlots.jl can be installed using the Julia package manager. From the Julia REPL, type  ]  to enter the Pkg REPL mode and run: julia> ] add PiccoloPlots"},{"id":380,"pagetitle":"Home","title":"Usage","ref":"/PiccoloPlots/dev/#Usage","content":" Usage As a simple example, we provide the  plot_unitary_populations  function which plots the populations of select columns of the unitary matrix. This can be employed as follows: using NamedTrajectories\nusing PiccoloQuantumObjects\nusing PiccoloPlots\n\n# Define the Hamiltonian H = X + a_1(t)Z + a_2(t)Y\nH_drift = PAULIS[:X]\nH_drives = [PAULIS[:Z], PAULIS[:Y]]\n\n# Generate control trajectory \nN = 100\n\nΔt = 0.1\nts = collect(0:Δt:Δt*(N-1))\n\na = 0.1 * randn(length(H_drives), length(ts))\n\n# Generate the unitaries\nUs = exp.(-im * [(H_drift + sum(a[:, k] .* H_drives)) * ts[k] for k = 1:N])\n\n# Create a NamedTrajectory\ntraj = NamedTrajectory(\n    (\n        Ũ⃗ = hcat(operator_to_iso_vec.(Us)...),\n        a = a,\n        Δt = ts,\n    );\n    controls = :a,\n    timestep = :Δt,\n)\n\n# Plot the populations of the first and second qubits\nplot_unitary_populations(traj)"},{"id":381,"pagetitle":"Home","title":"Building Documentation","ref":"/PiccoloPlots/dev/#Building-Documentation","content":" Building Documentation This package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility.  # first time only\n./docs/get_docs_utils.sh   # or ./get_docs_utils.sh if cwd is in ./docs/ To build the docs pages: julia --project=docs docs/make.jl or editing the docs live: julia --project=docs\n> using LiveServer, PiccoloPlots, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"], skip_files=[\"docs/src/index.md\"]) Note: servedocs  needs to watch a subset of the files in the  docs/  folder. If it watches files that are generated on a docs build/re-build,  servedocs  will continuously try to re-serve the pages. To prevent this, ensure all generated files are included in the skip dirs or skip files args for  servedocs . For example, if we forget index.md like so: julia --project=docs\n> using LiveServer, PiccoloPlots, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"]) it will not build and serve. \"It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to take away.\" - Antoine de Saint-Exupéry"},{"id":384,"pagetitle":"Quickstart Guide","title":"Quickstart Guide","ref":"/PiccoloPlots/dev/generated/quickstart/#Quickstart-Guide","content":" Quickstart Guide Here is a simple example where we set up a  NamedTrajectory  with some dummy data and plot populations of the columns of the unitary matrix. First we will load some of the necessary packages: using CairoMakie\nusing NamedTrajectories\nusing PiccoloQuantumObjects\nusing PiccoloPlots Next we will define some Hamiltonians H_drives = [PAULIS[:Z], PAULIS[:Y]]\nH_drift = PAULIS[:X] 2×2 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im Now we will generate some dummy control data N = 100\nΔt = 0.1\nts = 0:Δt:Δt*(N-1)\nA = 0.1 * randn(length(H_drives), length(ts)) 2×100 Matrix{Float64}:\n -0.0691354  -0.109738   -0.191474  …   0.0652727  -0.00588133  -0.17103\n -0.155649   -0.0854705   0.080649     -0.0370055   0.13235      0.169081 Now we will generate the unitaries Us = exp.(-im * [(H_drift + sum(A[:, k] .* H_drives)) * ts[k] for k = 1:N])\nUs[1] 2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0-0.0im  1.0+0.0im And create the trajectory traj = NamedTrajectory(\n    (\n        Ũ⃗ = hcat(operator_to_iso_vec.(Us)...), # here we store the isomorphisms\n        a = A,\n        Δt = ts\n    );\n    controls = :a,\n    timestep = :Δt\n) T = 100, (Ũ⃗ = 1:8, a = 9:10, → Δt = 11:11) Finally we will plot the populations plot_unitary_populations(traj) We can also only plot the first column (or any other subset of columns) plot_unitary_populations(traj; unitary_columns=[1]) This page was generated using  Literate.jl ."},{"id":387,"pagetitle":"Library","title":"Library","ref":"/PiccoloPlots/dev/lib/#Library","content":" Library"},{"id":388,"pagetitle":"Library","title":"PiccoloPlots.QuantumObjectPlots.plot_unitary_populations","ref":"/PiccoloPlots/dev/lib/#PiccoloPlots.QuantumObjectPlots.plot_unitary_populations-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" PiccoloPlots.QuantumObjectPlots.plot_unitary_populations  —  Method plot_unitary_populations(\n    traj::NamedTrajectory;\n    unitary_columns::AbstractVector{Int}=1:2,\n    unitary_name::Symbol=:Ũ⃗,\n    control_name::Symbol=:a,\n    kwargs...\n) Plot the populations of the unitary columns of the unitary matrix in the trajectory.  kwargs  are passed to  NamedTrajectories.plot . Keyword Arguments unitary_columns::AbstractVector{Int} : The columns of the unitary matrix to plot the populations of. Default is  1:2 . unitary_name::Symbol : The name of the unitary matrix in the trajectory. Default is  :Ũ⃗ . control_name::Symbol : The name of the control in the trajectory. Default is  :a . kwargs... : Additional keyword arguments passed to  NamedTrajectories.plot . source"},{"id":391,"pagetitle":"Home","title":"QuantumCollocationCore","ref":"/QuantumCollocationCore/dev/#QuantumCollocationCore","content":" QuantumCollocationCore QuantumCollocationCore.jl  provides a core library for quantum collocation methods. It is designed to be used in conjunction with the  QuantumCollocation.jl  package and the  Piccolo.jl  ecosystem, which provides a high-level interface for solving quantum optimal control problems using direct collocation. The underlying nonlinear solver is  Ipopt.jl , which is a Julia interface to the  Ipopt  solver. "},{"id":394,"pagetitle":"Explanation","title":"Quickstart Guide","ref":"/QuantumCollocationCore/dev/generated/explanation/#Quickstart-Guide","content":" Quickstart Guide"},{"id":395,"pagetitle":"Explanation","title":"Installation","ref":"/QuantumCollocationCore/dev/generated/explanation/#Installation","content":" Installation using QuantumCollocationCore"},{"id":396,"pagetitle":"Explanation","title":"This package also provides various objects and bindings used in Quantum Optimal Control problems.","ref":"/QuantumCollocationCore/dev/generated/explanation/#This-package-also-provides-various-objects-and-bindings-used-in-Quantum-Optimal-Control-problems.","content":" This package also provides various objects and bindings used in Quantum Optimal Control problems. This means various common constraints, integrators, objectives, and losses. This package also provides interfaces for the commonly needed dynamics, and evaluator objects to provide to the solver - which for now is Ipopt. This page was generated using  Literate.jl ."},{"id":399,"pagetitle":"Lib","title":"Library","ref":"/QuantumCollocationCore/dev/lib/#Library","content":" Library"},{"id":400,"pagetitle":"Lib","title":"Constraints","ref":"/QuantumCollocationCore/dev/lib/#Constraints","content":" Constraints"},{"id":401,"pagetitle":"Lib","title":"QuantumCollocationCore.Constraints.EqualityConstraint","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Constraints.EqualityConstraint","content":" QuantumCollocationCore.Constraints.EqualityConstraint  —  Type struct EqualityConstraint Represents a linear equality constraint. Fields ts::AbstractArray{Int} : the time steps at which the constraint is applied js::AbstractArray{Int} : the components of the trajectory at which the constraint is applied vals::Vector{R} : the values of the constraint vardim::Int : the dimension of a single time step of the trajectory label::String : a label for the constraint source"},{"id":402,"pagetitle":"Lib","title":"QuantumCollocationCore.Constraints.NonlinearEqualityConstraint","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Constraints.NonlinearEqualityConstraint","content":" QuantumCollocationCore.Constraints.NonlinearEqualityConstraint  —  Type struct NonlinearEqualityConstraint Represents a nonlinear equality constraint. Fields g::Function : the constraint function ∂g::Function : the Jacobian of the constraint function ∂g_structure::Vector{Tuple{Int, Int}} : the structure of the Jacobian  i.e. all non-zero entries μ∂²g::Function : the Hessian of the constraint function μ∂²g_structure::Vector{Tuple{Int, Int}} : the structure of the Hessian dim::Int : the dimension of the constraint function params::Dict{Symbol, Any} : a dictionary of parameters source"},{"id":403,"pagetitle":"Lib","title":"QuantumCollocationCore.Constraints.NonlinearInequalityConstraint","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Constraints.NonlinearInequalityConstraint","content":" QuantumCollocationCore.Constraints.NonlinearInequalityConstraint  —  Type struct NonlinearInequalityConstraint Represents a nonlinear inequality constraint. Fields g::Function : the constraint function ∂g::Function : the Jacobian of the constraint function ∂g_structure::Vector{Tuple{Int, Int}} : the structure of the Jacobian  i.e. all non-zero entries μ∂²g::Function : the Hessian of the constraint function μ∂²g_structure::Vector{Tuple{Int, Int}} : the structure of the Hessian dim::Int : the dimension of the constraint function params::Dict{Symbol, Any} : a dictionary of parameters containing additional  information about the constraint source"},{"id":404,"pagetitle":"Lib","title":"QuantumCollocationCore.Constraints.ComplexModulusContraint","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Constraints.ComplexModulusContraint-Tuple{Symbol, Float64, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" QuantumCollocationCore.Constraints.ComplexModulusContraint  —  Method ComplexModulusContraint(symb::Symbol, R::Float64, traj::NamedTrajectory) Returns a ComplexModulusContraint for the complex control NamedTrajector symbol where R is the maximum allowed complex modulus. source"},{"id":405,"pagetitle":"Lib","title":"QuantumCollocationCore.Constraints.ComplexModulusContraint","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Constraints.ComplexModulusContraint-Tuple{}","content":" QuantumCollocationCore.Constraints.ComplexModulusContraint  —  Method ComplexModulusContraint(<keyword arguments>) Returns a NonlinearInequalityConstraint on the complex modulus of a complex control TODO: Changed zdim -> dim. Constraint should be tested for global params. Arguments R::Union{Float64,Nothing}=nothing : the maximum allowed complex modulus comps::Union{AbstractVector{Int},Nothing}=nothing : the components of the complex control,  both the real and imaginary parts times::Union{AbstractVector{Int},Nothing}=nothing : the times at which the constraint is applied dim::Union{Int,Nothing}=nothing : the dimension of a single time step of the trajectory T::Union{Int,Nothing}=nothing : the number of time steps source"},{"id":406,"pagetitle":"Lib","title":"QuantumCollocationCore.Constraints.FinalFidelityConstraint","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Constraints.FinalFidelityConstraint-Tuple{}","content":" QuantumCollocationCore.Constraints.FinalFidelityConstraint  —  Method FinalFidelityConstraint(<keyword arguments>) Returns a NonlinearInequalityConstraint representing a constraint on the minimum allowed fidelity. Arguments fidelity_function::Union{Function,Nothing}=nothing : the fidelity function value::Union{Float64,Nothing}=nothing : the minimum fidelity value allowed  by the constraint comps::Union{AbstractVector{Int},Nothing}=nothing : the components of the  state to which the fidelity function is applied goal::Union{AbstractVector{Float64},Nothing}=nothing : the goal state statedim::Union{Int,Nothing}=nothing : the dimension of the state zdim::Union{Int,Nothing}=nothing : the dimension of a single time step of the trajectory T::Union{Int,Nothing}=nothing : the number of time steps subspace::Union{AbstractVector{<:Integer}, Nothing}=nothing : the subspace indices of the fidelity source"},{"id":407,"pagetitle":"Lib","title":"QuantumCollocationCore.Constraints.FinalQuantumStateFidelityConstraint","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Constraints.FinalQuantumStateFidelityConstraint-Tuple{Symbol, Float64, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" QuantumCollocationCore.Constraints.FinalQuantumStateFidelityConstraint  —  Method FinalQuantumStateFidelityConstraint(statesymb::Symbol, val::Float64, traj::NamedTrajectory) Returns a FinalFidelityConstraint for the unitary fidelity function where statesymb is the NamedTrajectory symbol representing the unitary. source"},{"id":408,"pagetitle":"Lib","title":"QuantumCollocationCore.Constraints.FinalUnitaryFidelityConstraint","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Constraints.FinalUnitaryFidelityConstraint-Tuple{Symbol, Float64, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" QuantumCollocationCore.Constraints.FinalUnitaryFidelityConstraint  —  Method FinalUnitaryFidelityConstraint(statesymb::Symbol, val::Float64, traj::NamedTrajectory) Returns a FinalFidelityConstraint for the unitary fidelity function where statesymb is the NamedTrajectory symbol representing the unitary. source"},{"id":409,"pagetitle":"Lib","title":"QuantumCollocationCore.Constraints.FinalUnitaryFreePhaseFidelityConstraint","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Constraints.FinalUnitaryFreePhaseFidelityConstraint-Tuple{}","content":" QuantumCollocationCore.Constraints.FinalUnitaryFreePhaseFidelityConstraint  —  Method FinalUnitaryFreePhaseFidelityConstraint Returns a NonlinearInequalityConstraint representing a constraint on the minimum allowed fidelity for a free phase unitary. source"},{"id":410,"pagetitle":"Lib","title":"QuantumCollocationCore.Constraints.constrain!","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Constraints.constrain!-Tuple{Ipopt.Optimizer, Vector{MathOptInterface.VariableIndex}, Vector{LinearConstraint}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" QuantumCollocationCore.Constraints.constrain!  —  Method constrain!(opt::Ipopt.Optimizer, vars::Vector{MOI.VariableIndex}, cons::Vector{LinearConstraint}, traj::NamedTrajectory; verbose=false) Supplies a set of LinearConstraints to  IPOPT using MathOptInterface source"},{"id":411,"pagetitle":"Lib","title":"QuantumCollocationCore.Constraints.trajectory_constraints","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Constraints.trajectory_constraints-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" QuantumCollocationCore.Constraints.trajectory_constraints  —  Method trajectory_constraints(traj::NamedTrajectory) Implements the initial and final value constraints and bounds constraints on the controls and states as specified by traj. source"},{"id":412,"pagetitle":"Lib","title":"Integrators","ref":"/QuantumCollocationCore/dev/lib/#Integrators","content":" Integrators"},{"id":413,"pagetitle":"Lib","title":"QuantumCollocationCore.Integrators.UnitaryPadeIntegrator","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Integrators.UnitaryPadeIntegrator","content":" QuantumCollocationCore.Integrators.UnitaryPadeIntegrator  —  Type source"},{"id":414,"pagetitle":"Lib","title":"QuantumCollocationCore.Integrators.UnitaryPadeIntegrator","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Integrators.UnitaryPadeIntegrator-Tuple{Symbol, Union{Symbol, Tuple{Vararg{Symbol}}}, PiccoloQuantumObjects.QuantumSystems.QuantumSystem, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","content":" QuantumCollocationCore.Integrators.UnitaryPadeIntegrator  —  Method UnitaryPadeIntegrator(\n    unitary_name::Symbol,\n    drive_name::Union{Symbol,Tuple{Vararg{Symbol}}},\n    G::Function,\n    ∂G::Function,\n    traj::NamedTrajectory;\n    order::Int=4,\n    calculate_pade_operators_structure::Bool=true,\n    autodiff::Bool=false\n) Construct a  UnitaryPadeIntegrator  which computes \\[\\text{isovec}\\qty(B^{(n)}(a_t) U_{t+1} - F^{(n)}(a_t) U_t)\\] where  U_t  is the unitary at time  t ,  a_t  is the control at time  t , and  B^{(n)}(a_t)  and  F^{(n)}(a_t)  are the  n th order Pade operators of the exponential of the drift operator  G(a_t) . Arguments unitary_name::Symbol : the name of the unitary in the trajectory drive_name::Union{Symbol,Tuple{Vararg{Symbol}}} : the name of the drive(s) in the trajectory G::Function : a function which takes the control vector  a_t  and returns the drive  G(a_t) ,  $G(a_t) = \\text{iso}(-i H(a_t))$ ∂G::Function : a function which takes the control vector  a_t  and returns a vector of matrices  $\\qty(\\ldots, \\pdv{G}{a^j_t}, \\ldots)$ traj::NamedTrajectory : the trajectory Keyword Arguments order::Int=4 : the order of the Pade approximation. Must be in  [4, 6, 8, 10, 12, 14, 16, 18, 20] . source"},{"id":415,"pagetitle":"Lib","title":"Losses","ref":"/QuantumCollocationCore/dev/lib/#Losses","content":" Losses"},{"id":416,"pagetitle":"Lib","title":"QuantumCollocationCore.Losses.iso_fidelity","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Losses.iso_fidelity-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}}","content":" QuantumCollocationCore.Losses.iso_fidelity  —  Method iso_fidelity(ψ̃, ψ̃_goal) Calculate the fidelity between two quantum states  ψ  and  ψ_goal . source"},{"id":417,"pagetitle":"Lib","title":"QuantumCollocationCore.Losses.iso_infidelity","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Losses.iso_infidelity","content":" QuantumCollocationCore.Losses.iso_infidelity  —  Function iso_infidelity(ψ̃, ψ̃goal) Returns the iso_infidelity between two quantum statevectors specified in the  $\\mathbb{C}^n \\to \\mathbb{R}^{2n}$  isomorphism space. source"},{"id":418,"pagetitle":"Lib","title":"QuantumCollocationCore.Losses.iso_vec_unitary_fidelity","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Losses.iso_vec_unitary_fidelity-Tuple{AbstractVector, AbstractVector}","content":" QuantumCollocationCore.Losses.iso_vec_unitary_fidelity  —  Method iso_vec_unitary_fidelity(Ũ⃗::AbstractVector, Ũ⃗_goal::AbstractVector) Returns the fidelity between the isomorphic unitary vector  $\\vec{\\widetilde{U}} \\sim U \\in SU(n)$  and the isomorphic goal unitary vector  $\\vec{\\widetilde{U}}_{\\text{goal}}$ . \\[\\begin{aligned}\n\\mathcal{F}(\\vec{\\widetilde{U}}, \\vec{\\widetilde{U}}_{\\text{goal}}) &= \\frac{1}{n} \\abs{\\tr \\qty(U_{\\text{goal}}^\\dagger U)} \\\\\n&= \\frac{1}{n} \\sqrt{T_R^{2} + T_I^{2}}\n\\end{aligned}\\] where  $T_R = \\langle \\vec{\\widetilde{U}}_{\\text{goal}, R}, \\vec{\\widetilde{U}}_R \\rangle + \\langle \\vec{\\widetilde{U}}_{\\text{goal}, I}, \\vec{\\widetilde{U}}_I \\rangle$  and  $T_I = \\langle \\vec{\\widetilde{U}}_{\\text{goal}, R}, \\vec{\\widetilde{U}}_I \\rangle - \\langle \\vec{\\widetilde{U}}_{\\text{goal}, I}, \\vec{\\widetilde{U}}_R \\rangle$ . source"},{"id":419,"pagetitle":"Lib","title":"QuantumCollocationCore.Losses.unitary_fidelity","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Losses.unitary_fidelity-Tuple{AbstractMatrix, AbstractMatrix}","content":" QuantumCollocationCore.Losses.unitary_fidelity  —  Method unitary_fidelity(U::Matrix, U_goal::Matrix; kwargs...)\nunitary_fidelity(Ũ⃗::AbstractVector, Ũ⃗_goal::AbstractVector; kwargs...) Calculate the fidelity between two unitary operators  U  and  U_goal . \\[\\mathcal{F}(U, U_{\\text{goal}}) = \\frac{1}{n} \\abs{\\tr \\qty(U_{\\text{goal}}^\\dagger U)}\\] where  $n$  is the dimension of the unitary operators. Keyword Arguments subspace::AbstractVector{Int} : The subspace to calculate the fidelity over. source"},{"id":420,"pagetitle":"Lib","title":"Objectives","ref":"/QuantumCollocationCore/dev/lib/#Objectives","content":" Objectives"},{"id":421,"pagetitle":"Lib","title":"QuantumCollocationCore.Objectives.Objective","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Objectives.Objective","content":" QuantumCollocationCore.Objectives.Objective  —  Type Objective A structure for defining objective functions. The  terms  field contains all the arguments needed to construct the objective function. Fields:      L : the objective function      ∇L : the gradient of the objective function      ∂²L : the Hessian of the objective function      ∂²L_structure : the structure of the Hessian of the objective function      terms : a vector of dictionaries containing the terms of the objective function source"},{"id":422,"pagetitle":"Lib","title":"QuantumCollocationCore.Objectives.L1Regularizer","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Objectives.L1Regularizer-Tuple{}","content":" QuantumCollocationCore.Objectives.L1Regularizer  —  Method L1Regularizer Create an L1 regularizer for the trajectory component. The regularizer is defined as \\[J_{L1}(u) = \\sum_t \\abs{R \\cdot u_t}\\] where (R) is the regularization matrix and (u_t) is the trajectory component at time (t). source"},{"id":423,"pagetitle":"Lib","title":"QuantumCollocationCore.Objectives.MinimumTimeObjective","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Objectives.MinimumTimeObjective-Tuple{}","content":" QuantumCollocationCore.Objectives.MinimumTimeObjective  —  Method MinimumTimeObjective A type of objective that counts the time taken to complete a task. Fields:      D : a scaling factor      Δt_indices : the indices of the time steps      eval_hessian : whether to evaluate the Hessian source"},{"id":424,"pagetitle":"Lib","title":"QuantumCollocationCore.Objectives.PairwiseQuadraticRegularizer","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Objectives.PairwiseQuadraticRegularizer-Tuple{AbstractVector{<:Real}, AbstractVector{Int64}, Symbol, Symbol}","content":" QuantumCollocationCore.Objectives.PairwiseQuadraticRegularizer  —  Method PairwiseQuadraticRegularizer Create a pairwise quadratic regularizer for the trajectory component  name  with regularization strength  R . The regularizer is defined as \\[    J_{v⃗}(u) = \\sum_t \\frac{1}{2} \\Delta t_t^2 (v⃗_{1,t} - v⃗_{2,t})^T R (v⃗_{1,t} - v⃗_{2,t})\\] where  $v⃗_{1}$  and  $v⃗_{2}$  are selected by  name1  and  name2 . The indices specify the appropriate block diagonal components of the direct sum vector  v⃗ . TODO: Hessian not implemented Fields:      R : the regularization strength      times : the time steps to apply the regularizer      name1 : the first name      name2 : the second name      timestep_name : the symbol for the timestep      eval_hessian : whether to evaluate the Hessian source"},{"id":425,"pagetitle":"Lib","title":"QuantumCollocationCore.Objectives.PairwiseQuadraticRegularizer","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Objectives.PairwiseQuadraticRegularizer-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory, Union{Float64, AbstractVector{<:Float64}}, AbstractVector{<:Tuple{Symbol, Symbol}}}","content":" QuantumCollocationCore.Objectives.PairwiseQuadraticRegularizer  —  Method PairwiseQuadraticRegularizer A convenience constructor for creating a PairwiseQuadraticRegularizer for the trajectory component  name  with regularization strength  Rs  over the graph  graph . source"},{"id":426,"pagetitle":"Lib","title":"QuantumCollocationCore.Objectives.PairwiseUnitaryRobustnessObjective","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Objectives.PairwiseUnitaryRobustnessObjective-Tuple{}","content":" QuantumCollocationCore.Objectives.PairwiseUnitaryRobustnessObjective  —  Method PairwiseUnitaryRobustnessObjective(;\n    H1::Union{AbstractPiccoloOperator, Nothing}=nothing,\n    H2_error::Union{AbstractPiccoloOperator, Nothing}=nothing,\n    symb1::Symbol=:Ũ⃗1,\n    symb2::Symbol=:Ũ⃗2,\n    eval_hessian::Bool=false,\n) Create a control objective which penalizes the sensitivity of the infidelity to the provided operators defined in the subspaces of the control dynamics, thereby realizing robust control. source"},{"id":427,"pagetitle":"Lib","title":"QuantumCollocationCore.Objectives.QuadraticRegularizer","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Objectives.QuadraticRegularizer-Tuple{}","content":" QuantumCollocationCore.Objectives.QuadraticRegularizer  —  Method QuadraticRegularizer A quadratic regularizer for a trajectory component. Fields:      name : the name of the trajectory component to regularize      times : the times at which to evaluate the regularizer      dim : the dimension of the trajectory component      R : the regularization matrix      baseline : the baseline values for the trajectory component      eval_hessian : whether to evaluate the Hessian of the regularizer      timestep_name : the symbol for the timestep variable source"},{"id":428,"pagetitle":"Lib","title":"QuantumCollocationCore.Objectives.QuadraticSmoothnessRegularizer","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Objectives.QuadraticSmoothnessRegularizer-Tuple{}","content":" QuantumCollocationCore.Objectives.QuadraticSmoothnessRegularizer  —  Method QuadraticSmoothnessRegularizer A quadratic smoothness regularizer for a trajectory component. Fields:      name : the name of the trajectory component to regularize      times : the times at which to evaluate the regularizer      R : the regularization matrix      eval_hessian : whether to evaluate the Hessian of the regularizer source"},{"id":429,"pagetitle":"Lib","title":"QuantumCollocationCore.Objectives.QuantumObjective","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Objectives.QuantumObjective-Tuple{}","content":" QuantumCollocationCore.Objectives.QuantumObjective  —  Method QuantumObjective\n\nA generic objective function for quantum trajectories that use a loss. source"},{"id":430,"pagetitle":"Lib","title":"QuantumCollocationCore.Objectives.UnitaryFreePhaseInfidelityObjective","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Objectives.UnitaryFreePhaseInfidelityObjective-Union{Tuple{}, Tuple{R}} where R<:Real","content":" QuantumCollocationCore.Objectives.UnitaryFreePhaseInfidelityObjective  —  Method UnitaryFreePhaseInfidelityObjective A type of objective that measures the infidelity of a unitary operator to a target unitary operator, where the target unitary operator is allowed to have phases on qubit subspaces. Fields:      name : the name of the unitary operator in the trajectory      global_name : the name of the global phase in the trajectory      goal : the target unitary operator      Q : a scaling factor      eval_hessian : whether to evaluate the Hessian      subspace : the subspace in which to evaluate the objective source"},{"id":431,"pagetitle":"Lib","title":"QuantumCollocationCore.Objectives.UnitaryInfidelityObjective","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Objectives.UnitaryInfidelityObjective-Tuple{}","content":" QuantumCollocationCore.Objectives.UnitaryInfidelityObjective  —  Method UnitaryInfidelityObjective A type of objective that measures the infidelity of a unitary operator to a target unitary operator. Fields:      name : the name of the unitary operator in the trajectory      goal : the target unitary operator      Q : a scaling factor      eval_hessian : whether to evaluate the Hessian      subspace : the subspace in which to evaluate the objective source"},{"id":432,"pagetitle":"Lib","title":"QuantumCollocationCore.Objectives.UnitaryRobustnessObjective","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Objectives.UnitaryRobustnessObjective-Tuple{}","content":" QuantumCollocationCore.Objectives.UnitaryRobustnessObjective  —  Method UnitaryRobustnessObjective(;     H::::Union{AbstractPiccoloOperator, Nothing}=nothing,     eval_hessian::Bool=false,     symb::Symbol=:Ũ⃗ ) Create a control objective which penalizes the sensitivity of the infidelity to the provided operator defined in the subspace of the control dynamics, thereby realizing robust control. The control dynamics are \\[U_C(a)= \\prod_t \\exp{-i H_C(a_t)}\\] In the control frame, the H operator is (proportional to) \\[R_{Robust}(a) = \\frac{1}{T \\norm{H_e}_2} \\sum_t U_C(a_t)^\\dag H_e U_C(a_t) \\Delta t\\] where we have adjusted to a unitless expression of the operator. The robustness objective is \\[R_{Robust}(a) = \\frac{1}{N} \\norm{R}^2_F\\] where N is the dimension of the Hilbert space. source"},{"id":433,"pagetitle":"Lib","title":"QuantumCollocationCore.Objectives.sparse_to_moi","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Objectives.sparse_to_moi-Tuple{SparseArrays.SparseMatrixCSC}","content":" QuantumCollocationCore.Objectives.sparse_to_moi  —  Method sparse_to_moi(A::SparseMatrixCSC) Converts a sparse matrix to tuple of vector of nonzero indices and vector of nonzero values source"},{"id":434,"pagetitle":"Lib","title":"Dynamics","ref":"/QuantumCollocationCore/dev/lib/#Dynamics","content":" Dynamics"},{"id":435,"pagetitle":"Lib","title":"QuantumCollocationCore.Dynamics.QuantumDynamics","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Dynamics.QuantumDynamics","content":" QuantumCollocationCore.Dynamics.QuantumDynamics  —  Type QuantumDynamics <: AbstractDynamics source"},{"id":436,"pagetitle":"Lib","title":"Options","ref":"/QuantumCollocationCore/dev/lib/#Options","content":" Options"},{"id":437,"pagetitle":"Lib","title":"QuantumCollocationCore.Options.IpoptOptions","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Options.IpoptOptions","content":" QuantumCollocationCore.Options.IpoptOptions  —  Type Solver options for Ipopt\n\nhttps://coin-or.github.io/Ipopt/OPTIONS.html#OPT_print_options_documentation source"},{"id":438,"pagetitle":"Lib","title":"QuantumCollocationCore.Options.PiccoloOptions","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Options.PiccoloOptions","content":" QuantumCollocationCore.Options.PiccoloOptions  —  Type PiccoloOptions Options for the Piccolo quantum optimal control library. Fields verbose::Bool = true : Print verbose output verbose_evaluator::Bool = false : Print verbose output from the evaluator free_time::Bool = true : Allow free time optimization timesteps_all_equal::Bool = true : Use equal timesteps integrator::Symbol = :pade : Integrator to use pade_order::Int = 4 : Order of the Pade approximation rollout_integrator::Function = expv : Integrator to use for rollout eval_hessian::Bool = false : Evaluate the Hessian geodesic = true : Use the geodesic to initialize the optimization. blas_multithreading::Bool = true : Use BLAS multithreading. build_trajectory_constraints::Bool = true : Build trajectory constraints. complex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing : Name of the complex control norm constraint. complex_control_norm_constraint_radius::Float64 = 1.0 : Radius of the complex control norm constraint. bound_state::Bool = false : Bound the state. leakage_suppression::Bool = false : Suppress leakage. R_leakage::Float64 = 1.0 : Leakage suppression parameter. free_phase_infidelity::Bool = false : Free phase infidelity. phase_operators::Union{Nothing, AbstractVector{<:AbstractMatrix{<:Complex}}} = nothing : Phase operators. phase_name::Symbol = :ϕ : Name of the phase. source"},{"id":439,"pagetitle":"Lib","title":"Problem Solvers","ref":"/QuantumCollocationCore/dev/lib/#Problem-Solvers","content":" Problem Solvers"},{"id":440,"pagetitle":"Lib","title":"QuantumCollocationCore.ProblemSolvers.solve!","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.ProblemSolvers.solve!-Tuple{QuantumControlProblem}","content":" QuantumCollocationCore.ProblemSolvers.solve!  —  Method solve!(prob::QuantumControlProblem;         init traj=nothing,         save path=nothing,         max iter=prob.ipopt options.max iter,         linear solver=prob.ipopt options.linear solver,         print level=prob.ipopt options.print level,         remove slack variables=false,         callback=nothing         # state type=:unitary,         # print_fidelity=false,     ) Call optimization solver to solve the quantum control problem with parameters and callbacks. Arguments prob::QuantumControlProblem : The quantum control problem to solve. init_traj::NamedTrajectory : Initial guess for the control trajectory. If not provided, a random guess will be generated. save_path::String : Path to save the problem after optimization. max_iter::Int : Maximum number of iterations for the optimization solver. linear_solver::String : Linear solver to use for the optimization solver (e.g., \"mumps\", \"paradiso\", etc). print_level::Int : Verbosity level for the solver. remove_slack_variables::Bool : Remove slack variables from the trajectory after optimization. callback::Function : Callback function to call during optimization steps. source"},{"id":441,"pagetitle":"Lib","title":"Problems","ref":"/QuantumCollocationCore/dev/lib/#Problems","content":" Problems"},{"id":442,"pagetitle":"Lib","title":"QuantumCollocationCore.Problems.QuantumControlProblem","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Problems.QuantumControlProblem","content":" QuantumCollocationCore.Problems.QuantumControlProblem  —  Type mutable struct QuantumControlProblem <: AbstractProblem Stores all the information needed to set up and solve a QuantumControlProblem as well as the solution after the solver terminates. Fields optimizer::Ipopt.Optimizer : Ipopt optimizer object source"},{"id":443,"pagetitle":"Lib","title":"QuantumCollocationCore.Problems.get_constraints","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Problems.get_constraints-Tuple{QuantumControlProblem}","content":" QuantumCollocationCore.Problems.get_constraints  —  Method get_constraints(prob::QuantumControlProblem) Return the constraints of the  prob::QuantumControlProblem . source"},{"id":444,"pagetitle":"Lib","title":"QuantumCollocationCore.Problems.get_objective","ref":"/QuantumCollocationCore/dev/lib/#QuantumCollocationCore.Problems.get_objective-Tuple{QuantumControlProblem}","content":" QuantumCollocationCore.Problems.get_objective  —  Method get_objective(prob::QuantumControlProblem) Return the objective function of the  prob::QuantumControlProblem . source"},{"id":445,"pagetitle":"Lib","title":"Saving and Loading","ref":"/QuantumCollocationCore/dev/lib/#Saving-and-Loading","content":" Saving and Loading"}]