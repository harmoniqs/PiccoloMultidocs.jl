var documenterSearchIndex = {"docs":
[{"location":"generated/man/params_in_struct/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"generated/man/params_in_struct/","page":"Parameters","title":"Parameters","text":"NamedTrajectory.jl support passing parameters as a Tuple when construct a NamedTrajectory.","category":"page"},{"location":"generated/man/params_in_struct/","page":"Parameters","title":"Parameters","text":"using NamedTrajectories","category":"page"},{"location":"generated/man/params_in_struct/","page":"Parameters","title":"Parameters","text":"First we need to define number of timesteps and timestep","category":"page"},{"location":"generated/man/params_in_struct/","page":"Parameters","title":"Parameters","text":"T = 10\ndt = 0.1","category":"page"},{"location":"generated/man/params_in_struct/","page":"Parameters","title":"Parameters","text":"then build named tuple of components and data matrices.","category":"page"},{"location":"generated/man/params_in_struct/","page":"Parameters","title":"Parameters","text":"components = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = fill(dt, 1, T),\n)","category":"page"},{"location":"generated/man/params_in_struct/","page":"Parameters","title":"Parameters","text":"we must specify a timestep and control variable for the trajectory.","category":"page"},{"location":"generated/man/params_in_struct/","page":"Parameters","title":"Parameters","text":"timestep = :Δt\ncontrol = :u","category":"page"},{"location":"generated/man/params_in_struct/","page":"Parameters","title":"Parameters","text":"some global params as a NamedTuple","category":"page"},{"location":"generated/man/params_in_struct/","page":"Parameters","title":"Parameters","text":"params = (\n    α = rand(1),\n    β = rand(1)\n)","category":"page"},{"location":"generated/man/params_in_struct/","page":"Parameters","title":"Parameters","text":"we can now create a NamedTrajectory object with parameters specification.","category":"page"},{"location":"generated/man/params_in_struct/","page":"Parameters","title":"Parameters","text":"traj = NamedTrajectory(components, params; timestep=timestep, controls=control)","category":"page"},{"location":"generated/man/params_in_struct/","page":"Parameters","title":"Parameters","text":"","category":"page"},{"location":"generated/man/params_in_struct/","page":"Parameters","title":"Parameters","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/man/modifying/#Modifying-trajectories","page":"Modifying trajectories","title":"Modifying trajectories","text":"","category":"section"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"Modifying existing trajectories can be useful for a variety of reasons. Sometimes, you may want to change the values of the states, controls, or other components of the trajectory. Other times, you may want to add or remove components from the trajectory.","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"using NamedTrajectories","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"Create a random trajectory with 5 time steps, a state variable x of dimension 3, and a control variable u of dimension 2","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj = rand(NamedTrajectory, 5)\ntraj.names","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"Add a new state variable y to the trajectory. Notice this is in-place.","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"y_data = rand(4, 5)\ntraj = add_component(traj, :y, y_data)\ntraj.names","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"Remove the state variable y from the trajectory. This is not in place.","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"restored_traj = remove_component(traj, :y)\nrestored_traj.names","category":"page"},{"location":"generated/man/modifying/#Adding-suffixes","page":"Modifying trajectories","title":"Adding suffixes","text":"","category":"section"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"Another common operation is to add or remove a suffix from the components of a trajectory. This can be useful when you want to create a modified version of a trajectory that is related to the original trajectory in some way, or when you want to create a new trajectory that is a combination of two or more existing trajectories.","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"For now, these tools are used to create a new trajectory.","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"Add a suffix \"_new\" to the state variable x","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"modified_traj = add_suffix(traj, \"_modified\")\nmodified_traj.names","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"The modified trajectory contains the same data","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"modified_traj.x_modified == traj.x","category":"page"},{"location":"generated/man/modifying/#Merging-trajectories","page":"Modifying trajectories","title":"Merging trajectories","text":"","category":"section"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"You can also merge two or more trajectories into a single trajectory. This can be useful when you want to combine data. Mergining trajectories is like taking a direct sum of the underlying data.","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"Merge the original trajectory with the modified trajectory","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"merged_traj = merge(traj, modified_traj)\nmerged_traj.names |> println","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"You can also extract a specific suffix from the components of a trajectory","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"extracted_traj = get_suffix(merged_traj, \"_modified\")\nextracted_traj.names","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"If you want the original names, you can remove the suffix","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"original_traj = get_suffix(merged_traj, \"_modified\", remove=true)\noriginal_traj.names","category":"page"},{"location":"generated/man/modifying/#Merging-with-conflicts","page":"Modifying trajectories","title":"Merging with conflicts","text":"","category":"section"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"If there are any conflicting symbols, you can specify how to resolve the conflict.","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"conflicting_traj = rand(NamedTrajectory, 5)\ntraj.names, conflicting_traj.names","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"In this case, keep the u data from the first trajectory and the x data and timestep from the second trajectory","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"merged_traj = merge(traj, conflicting_traj; merge_names=(u=1, x=2, Δt=2))\nprintln(merged_traj.u == traj.u, \", \", merged_traj.u == conflicting_traj.u)\nprintln(merged_traj.x == traj.x, \", \", merged_traj.x == conflicting_traj.x)","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"Merged names","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"merged_traj.names","category":"page"},{"location":"generated/man/modifying/#Advanced-usage","page":"Modifying trajectories","title":"Advanced usage","text":"","category":"section"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"Sometimes it may be desirable to have direct access to the underlying data matrix/vector associated with the trajectory. In other circumstances it is more useful to employ the built-in per-component and per-knot-point indexing functionality. We detail the relationship between these different methods of access here.","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj = rand(NamedTrajectory, 5)","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"The \"backing store\" of a NamedTrajectory is its datavec field, a Vector{<:Real}:","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj.datavec","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"The data field holds a reshaped \"view\" of the \"backing store\", in a form that is somewhat easier to work with:","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj.data","category":"page"},{"location":"generated/man/modifying/#Indexing","page":"Modifying trajectories","title":"Indexing","text":"","category":"section"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"The data matrix is of dimension (traj.dim, traj.T), where length(traj.names) == traj.dim","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"The nth component's indices are given by traj.components[traj.names[n]]","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"println(traj.names)\nprintln(traj.components)","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"For instance, the indices of a given component at a given knot point are given as follows:","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"idx = 1 # x\nt = 3\nslice = traj.datavec[((t - 1) * traj.T) .+ traj.components[traj.names[idx]]]\nprintln(slice == traj[t].x == traj.x[:, t])","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"More generally, the indices of a given component across all knot points are given as follows:","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"idx = 1 # x\nprintln([((k - 1) * traj.dim) .+ getproperty(traj.components, traj.names[idx]) for k in 1:traj.T])\nidx = 2 # u\nprintln([((k - 1) * traj.dim) .+ getproperty(traj.components, traj.names[idx]) for k in 1:traj.T])","category":"page"},{"location":"generated/man/modifying/#Writability","page":"Modifying trajectories","title":"Writability","text":"","category":"section"},{"location":"generated/man/modifying/#Views-and-Backing-Stores","page":"Modifying trajectories","title":"Views and Backing Stores","text":"","category":"section"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"In Julia, a \"view\" (SubArray) is intrinsically linked to some \"parent\" Array. Any in-place modification of one is reflected by the other.","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"The following are \"safe\" operations on a NamedTrajectory (in-place modification of the datavec):","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj = rand(NamedTrajectory, 5)\ntraj.datavec\nprintln(traj.datavec)\ntraj.datavec[1] *= 0.\nprintln(traj.datavec)\ntraj.datavec[:] = rand(length(traj.datavec))\nprintln(traj.datavec)","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"The following is an example of an \"unsafe\" operation (non-in-place modification of the datavec):","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj = rand(NamedTrajectory, 5)\nprintln(traj.datavec == traj.data[:])\ntraj.datavec = rand(length(traj.datavec))\nprintln(traj.datavec == traj.data[:]) # the `data` field now points to a \"backing store\" that is no longer accessible via `traj.datavec`; this will lead to undefined behavior:","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"In general, reassigning the values of any of the fields of a trajectory may lead to undefined behavior:","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"fieldnames(NamedTrajectory)","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"TODO:","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"Prevent this issue by catching attempts to set sensitive fields in Base.setproperty!(::NamedTrajectory, ::Symbol, ::Any) (datavec and data are the primary concern in this regard; however, issuing a warning of some kind may be appropriate).\nParticularly because it is confusing that traj.datavec = zeros(length(datavec)) is \"discouraged\", while traj.x = zeros(traj.dims.x, traj.T) and traj[1].x = zeros(traj.dims.x) are both valid.","category":"page"},{"location":"generated/man/modifying/#Components-and-Knot-Points","page":"Modifying trajectories","title":"Components and Knot Points","text":"","category":"section"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj = rand(NamedTrajectory, 5)","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"Trajectory components are accessible (as a \"view\") via getproperty:","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj.x","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"Components are also writable via setproperty!:","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj.x = rand(traj.dims.x, traj.T)\ntraj.x","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"or may be modified directly:","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj.x[1] *= 0.\ntraj.x","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"Knot points are likewise accessible via getindex:","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj[1]","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"A KnotPoint behaves much like a NamedTrajectory, with respect to getting, setting, and/or modifying its components:","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj[1].u","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj[1].u = rand(traj.dims.u)\ntraj[1].u","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj[1].u[1] *= 0\ntraj[1].u","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"The parent trajectory will reflect any modifications made in this fashion:","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"traj.datavec","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"","category":"page"},{"location":"generated/man/modifying/","page":"Modifying trajectories","title":"Modifying trajectories","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/#API","page":"Library","title":"API","text":"","category":"section"},{"location":"lib/#NamedTrajectory-methods","page":"Library","title":"NamedTrajectory methods","text":"","category":"section"},{"location":"lib/#Base.merge-Tuple{NamedTrajectory, NamedTrajectory}","page":"Library","title":"Base.merge","text":"merge(traj1::NamedTrajectory, traj2::NamedTrajectory)\nmerge(trajs::AbstractVector{<:NamedTrajectory})\n\nReturns a new NamedTrajectory object by merging NamedTrajectory objects. \n\nMerge names are used to specify which components to merge by index. If no merge names are provided, all components are merged and name collisions are not allowed. If merge names are provided, the names are merged using the data from the index provided in the merge names.\n\nKeyword Arguments\n\ntimestep::Symbol: The timestep symbol to use for free time problems. Default to the last trajectory.\nmerge_names::Union{Nothing, NamedTuple{<:Any, <:Tuple{Vararg{Int}}}}=nothing: The names to merge by index.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.add_component-Tuple{NamedTrajectory, Symbol, AbstractVecOrMat{Float64}}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_component","text":"add_component(traj, name::Symbol, data::AbstractVecOrMat)\n\nAdd a component to the trajectory.\n\nKeyword arguments:     - type::Symbol: The type of the component, can be :state, :control, :slack, or :global. Default is :state.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.add_components-Tuple{NamedTrajectory, NamedTuple}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_components","text":"add_components(traj, comps)\n\nAdd components to the trajectory.\n\nKeyword arguments:     - type::Symbol: The type of the component, can be :state, :control, :slack, or :global. Default is :state.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.add_suffix","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_suffix","text":"add_suffix(obj::T, suffix::String)\n\nAdd the suffix to the symbols of the object.\n\n\n\n\n\n","category":"function"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.get_component_names-Tuple{NamedTrajectory, AbstractVector{Int64}}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_component_names","text":"get_component_names(traj::NamedTrajectory, comps::AbstractVector{<:Int})\n\nReturns the name of the component with the given indices. If only one component is found, the name is returned as a single symbol. Else, the names are returned as a vector of symbols.\n\nThe filter requires that the components are a complete subset of the given indices, so that a partial match is excluded from the returned names.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.get_components-Tuple{Union{Tuple, AbstractVector}, NamedTrajectory}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_components","text":"get_components(names, ::NamedTrajectory)\n\nReturns a NamedTuple containing the names and corresponding data matrices of the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.get_duration-Tuple{NamedTrajectory}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_duration","text":"get_duration(::NamedTrajectory)\n\nReturns the duration of a trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.get_suffix","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_suffix","text":"get_suffix(obj::T, suffix::String; remove::Bool=false)\n\nGet the data with the suffix from the object. Remove the suffix if remove=true.\n\n\n\n\n\n","category":"function"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.get_times-Tuple{NamedTrajectory}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_times","text":"get_times(traj)::Vector{Float64}\n\nReturns the times of a trajectory as a vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.get_timesteps-Tuple{NamedTrajectory}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_timesteps","text":"get_timesteps(::NamedTrajectory)\n\nReturns the timesteps of a trajectory as a vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.merge_outer-Tuple{AbstractVector}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.merge_outer","text":"merge_outer(objs::AbstractVector{<:Any})\n\nMerge objects. An error is reported if a key collision is detected.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.remove_component-Tuple{NamedTrajectory, Symbol}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_component","text":"remove_component(traj, name::Symbol)\n\nRemove a component from the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.remove_components-Tuple{NamedTrajectory, AbstractVector{<:Symbol}}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_components","text":"remove_components(traj, names::Vector{Symbol})\n\nRemove a set of components from the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.remove_suffix","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_suffix","text":"remove_suffix(obj::T, suffix::String)\n\nRemove the suffix from the symbols of the object.\n\n\n\n\n\n","category":"function"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.update!-Tuple{NamedTrajectory, AbstractVector{Float64}}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update!","text":"update!(traj, datavec::AbstractVector{Float64})\n\nUpdate the trajectory with a new datavec.\n\nKeyword arguments:     - type::Symbol: The type of the datavec, can be :data, :global, or :both. Default is global.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.update!-Tuple{NamedTrajectory, Symbol, AbstractMatrix{Float64}}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update!","text":"update!(traj, name::Symbol, data::AbstractMatrix{Float64})\n\nUpdate a component of the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.update_bound!-Tuple{NamedTrajectory, Symbol, Any}","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update_bound!","text":"update_bound!(traj, name, new_bound)\n\nUpdate the bound of a component of the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Base.getproperty-Tuple{KnotPoint, Symbol}","page":"Library","title":"Base.getproperty","text":"getproperty(slice::KnotPoint, symb::Symbol)\n\nReturns the component of the knot point with name symb (as a view) or the property of the knot point with name symb.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Base.setproperty!-Tuple{KnotPoint, Symbol, Any}","page":"Library","title":"Base.setproperty!","text":"setproperty!(slice::KnotPoint, symb::Symbol, val::Any)\n\nDispatches setting properties of knot points as either setting a component or a property via update! or setfield!, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.MethodsKnotPoint.update!-Tuple{KnotPoint, Symbol, AbstractVector{Float64}}","page":"Library","title":"NamedTrajectories.MethodsKnotPoint.update!","text":"update!(slice::KnotPoint, symb::Symbol, data::AbstractVector{Float64})\n\nUpdate a component of the knot point.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Random-trajectory-methods","page":"Library","title":"Random trajectory methods","text":"","category":"section"},{"location":"lib/#Base.rand-Tuple{Type{NamedTrajectory}, Int64}","page":"Library","title":"Base.rand","text":"rand(\n    ::Type{NamedTrajectory},\n    T::Int;\n    timestep_value::Float64=1.0,\n    timestep_name::Symbol=:Δt,\n    timestep::Union{Float64,Symbol}=free_time ? timestep_name : timestep_value,\n    state_dim::Int=3,\n    control_dim::Int=2\n)\n\nCreate a random NamedTrajectory with T time steps, a state variable x of dimension  state_dim, and a control variable u of dimension control_dim. The time step is a symbol timestep_name and the time step value is timestep_value. \n\n\n\n\n\n","category":"method"},{"location":"lib/#Struct-Methods","page":"Library","title":"Struct Methods","text":"","category":"section"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory{R <: Real}\n\nContainer for trajectory optimization problems, which includes the trajectory data, bounds dimensions, initial and final conditions, goal states, and components.\n\nThis struct is designed to hold trajectory data in a named format, allowing for easy access to knot points by Symbol.\n\nNamedTrajectory is designed to make allocation-free access easy to write. The data can be updated after construction, but the fields cannot.\n\n\n\n\n\n","category":"type"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Tuple{NamedTuple{N, <:Tuple{Vararg{AbstractMatrix{<:Real}}}} where N, NamedTuple{GN, <:Tuple{Vararg{AbstractVector{<:Real}}}} where GN}","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(component_data, global_components_data)\n\nConstruct a NamedTrajectory from component data and global component data\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Tuple{NamedTuple{N, <:Tuple{Vararg{AbstractMatrix{<:Real}}}} where N}","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(component_data)\n\nConstruct a NamedTrajectory from component data.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Tuple{NamedTuple{N, <:Tuple{Vararg{AbstractVecOrMat{<:Real}}}} where N}","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(component_data::NamedTuple, timestep; kwargs...)\n\nConstruct a NamedTrajectory from mixed Matrix/Vector component data.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{NamedTrajectory}, Tuple{R}} where R<:Real","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(data, traj)\n\nConstruct a NamedTrajectory from an existing NamedTrajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{R}, Tuple{AbstractMatrix{R}, NamedTuple{N, <:Tuple{Vararg{UnitRange{Int64}}}} where N}} where R<:Real","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(data, components; kwargs...)\n\nConstruct a NamedTrajectory from a data matrix and components.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.NamedTrajectory-Union{Tuple{R}, Tuple{AbstractVector{R}, NamedTuple{N, <:Tuple{Vararg{UnitRange{Int64}}}} where N, Int64}} where R<:Real","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.NamedTrajectory","text":"NamedTrajectory(datavec, components, T)\n\nConstruct a named trajectory from a data vector, components, and knot points.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.get_bounds_from_dims-Tuple{NamedTuple, NamedTuple{<:Any, <:Tuple{Vararg{Int64}}}}","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.get_bounds_from_dims","text":"get_bounds_from_dims(bounds, dims; dtype=Float64)\n\nProcess bounds from allowed types using dims and convert to dtype.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.inspect_dims_pairs-Union{Tuple{R}, Tuple{Vector{Pair{Symbol, Int64}}, NamedTuple{bname, <:Tuple{Vararg{Tuple{R⃗, R⃗}}} where R⃗<:AbstractVector{R}} where bname, NamedTuple{iname, <:Tuple{Vararg{R⃗}} where R⃗<:AbstractVector{R}} where iname, NamedTuple{fname, <:Tuple{Vararg{R⃗}} where R⃗<:AbstractVector{R}} where fname, NamedTuple{gname, <:Tuple{Vararg{R⃗}} where R⃗<:AbstractVector{R}} where gname}} where R<:Real","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.inspect_dims_pairs","text":"inspect_dims_pairs(dims_pairs, bounds, initial, final, goal)\n\nCheck for proper formatting of trajectory components.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructNamedTrajectory.inspect_names-NTuple{6, Tuple{Vararg{Symbol}}}","page":"Library","title":"NamedTrajectories.StructNamedTrajectory.inspect_names","text":"inspect_names(names, controls, initial, final, goal, bounds)\n\nCheck for missing names in the trajectory components.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.StructKnotPoint.KnotPoint","page":"Library","title":"NamedTrajectories.StructKnotPoint.KnotPoint","text":"KnotPoint constructor\n\n\n\n\n\n","category":"type"},{"location":"lib/#Trajectory-Utilities","page":"Library","title":"Trajectory Utilities","text":"","category":"section"},{"location":"lib/#NamedTrajectories.Utils.derivative-Tuple{AbstractMatrix, AbstractVecOrMat}","page":"Library","title":"NamedTrajectories.Utils.derivative","text":"derivative(X::AbstractMatrix, Δt::AbstractVecOrMat)\nderivative(X::AbstractMatrix, Δt::Float64)\n\nCompute the derivative of the data matrix X.\n\n\n\n\n\n","category":"method"},{"location":"lib/#NamedTrajectories.Utils.integral-Tuple{AbstractMatrix, AbstractVector}","page":"Library","title":"NamedTrajectories.Utils.integral","text":"integral(X::AbstractMatrix, Δt::AbstractVector)\nintegral(X::AbstractMatrix, Δt::Float64)\n\nCompute the integral of the data matrix X.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Interpolation-Methods","page":"Library","title":"Interpolation Methods","text":"","category":"section"},{"location":"lib/#NamedTrajectories.MethodsNamedTrajectory.trajectory_interpolation","page":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.trajectory_interpolation","text":"trajectory_interpolation(\n    traj::NamedTrajectory,\n    times::AbstractVector;\n    interpolations::NamedTuple=NamedTuple(zip(traj.names, fill(:linear, length(traj.names))))\n)\n\nInterpolate a NamedTrajectory at specified time points.\n\nArguments\n\ntraj::NamedTrajectory: The trajectory to interpolate.\ntimes::AbstractVector: The time points at which to interpolate the trajectory.\n\nKeyword Arguments\n\ninterpolations::NamedTuple: A named tuple specifying the interpolation method for each  component. Supported methods are :constant, :linear, and :spline. Defaults to  :linear for all components.\n\nReturns\n\nNamedTrajectory: A new trajectory with interpolated values at the specified times.\n\nNotes\n\nComponents not specified in interpolations will be dropped from the returned trajectory.\nThe timestep component is automatically included with linear interpolation if not specified.\nSpline interpolation requires derivative components (e.g., du for component u).\n\nExamples\n\n# Linear interpolation at new time points\nnew_times = [0.0, 0.5, 1.0, 1.5, 2.0]\nnew_traj = trajectory_interpolation(traj, new_times)\n\n# Mix of interpolation methods\ninterpolations = (x = :linear, u = :spline, Δt = :linear)\nnew_traj = trajectory_interpolation(traj, new_times; interpolations=interpolations)\n\n\n\n\n\ntrajectory_interpolation(\n    traj::NamedTrajectory,\n    T::Int;\n    kwargs...\n)\n\nInterpolate a NamedTrajectory to a new number of time steps.\n\nArguments\n\ntraj::NamedTrajectory: The trajectory to interpolate.\nT::Int: The number of time steps in the interpolated trajectory.\n\nKeyword Arguments\n\nkwargs...: Additional keyword arguments passed to the main trajectory_interpolation method.\n\nReturns\n\nNamedTrajectory: A new trajectory with T time steps, evenly spaced between the original  start and end times.\n\nExamples\n\n# Interpolate to 100 time steps\nnew_traj = trajectory_interpolation(traj, 100)\n\n# With custom interpolation methods\nnew_traj = trajectory_interpolation(traj, 100; interpolations=(x=:spline, u=:linear))\n\n\n\n\n\n","category":"function"},{"location":"generated/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"Visualizing trajectories is crucial for understanding the solutions of trajectory optmization problems and NamedTrajectories exports a plot function that contains a lot of functionality that is continually being added to.","category":"page"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"Makie.jl is used as the plotting framework. An extension package is used to load plotting functionality whenever a version of Makie is installed in the current environment. For example, use CairoMakie to creates high quality vector graphics.","category":"page"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"The main recipe for named trajectory plotting is as follows:","category":"page"},{"location":"generated/plotting/#NamedTrajectories.Plotting.plot_name-generated-plotting","page":"Plotting","title":"NamedTrajectories.Plotting.plot_name","text":"plot_name(traj::NamedTrajectory, name::Symbol; kwargs...)\n\nPlot a single component of a NamedTrajectory using Makie.\n\nThe default plot type is Series. Series attributes can be passed as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"The plot function is a wrapper around plot_name that allows for easy plotting of NamedTrajectory objects. The plot function has the following signature:","category":"page"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"plot(traj::NamedTrajectory, args...; kwargs...)","category":"page"},{"location":"generated/plotting/#Basic-example","page":"Plotting","title":"Basic example","text":"","category":"section"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"Use a Makie backend to automatically load the NamedTrajectories plotting extension","category":"page"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"using CairoMakie\nusing NamedTrajectories\n\n# define the number timestamps\nT = 100\nΔt = 0.1\nts = [0:T-1...] * Δt\n\n# define sinusoidal state trajectories\nX = zeros(3, T)\nX[1, :] = sin.(3 * 2π * ts / (2 * (T - 1) * Δt))\nX[2, :] = -sin.(5 * 2π * ts / (2 * (T - 1) * Δt))\nX[3, :] = sin.(9 * 2π * ts / (2 * (T - 1) * Δt))\n\n# define gaussian shaped controls\nU = stack(\n    [\n        exp.(-((ts .- ts[length(ts)÷3]) / 2.0).^2) .* sin.(5.0 * ts),\n        exp.(-((ts .- ts[2(length(ts)÷3)]) / 1.5).^2) .* sin.(4.0 * ts)\n    ];\n    dims=1\n)\nV = exp.(-((ts .- ts[length(ts)÷2]) ./ 1.5).^2) .* sin.(6.0 * ts)\n\n# create the trajectory\ntraj = NamedTrajectory(\n    (\n        x=X,\n        u=U,\n        v=V,\n        Δt=fill(Δt, T),\n    );\n    timestep=:Δt,\n    controls=(:u, :v)\n)\n\n# plot the trajectory\nplot(traj)","category":"page"},{"location":"generated/plotting/#Selectively-plotting-components","page":"Plotting","title":"Selectively plotting components","text":"","category":"section"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"We can selectively plot components of the trajectory by passing a Vector of Symbols to the components keyword argument. For example, if we only wanted to plot the state and the first control we could do the following:","category":"page"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"plot(traj, [:x, :u])","category":"page"},{"location":"generated/plotting/#Playing-with-transformations","page":"Plotting","title":"Playing with transformations","text":"","category":"section"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"We can also apply transformations to the components of the trajectory. Transformations are performed on columns of the data.","category":"page"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"For example, if we wanted to plot absolute values of the states we could do the following:","category":"page"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"transformations = [(:x => x -> abs.(x))]\n\nplot(traj, [:x]; transformations=transformations)","category":"page"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"We can also pass multiple transformations to the same component, with selective labels and titles:","category":"page"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"# define the transformations\ntransformations = [\n    (:x => x -> [x[1] + x[2], x[3] - x[2]]),\n    (:x => x -> [x[1] - x[2], x[3] + x[2]])\n]\n\n# plot the trajectory, with only the transformation and the `u` control\nplot(traj, [:u]; transformations=transformations,)","category":"page"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"","category":"page"},{"location":"generated/plotting/","page":"Plotting","title":"Plotting","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=\"center\">\n  <a href=\"https://github.com/harmoniqs/Piccolo.jl\">\n    <img src=\"assets/logo.svg\" alt=\"logo\" width=\"25%\"/>\n  </a> \n</div>\n\n<div align=\"center\">\n  <table>\n    <tr>\n      <td align=\"center\">\n        <b>Documentation</b>\n        <br>\n        <a href=\"https://docs.harmoniqs.co/NamedTrajectories/stable/\">\n          <img src=\"https://img.shields.io/badge/docs-stable-blue.svg\" alt=\"Stable\"/>\n        </a>\n        <a href=\"https://docs.harmoniqs.co/NamedTrajectories/dev/\">\n          <img src=\"https://img.shields.io/badge/docs-dev-blue.svg\" alt=\"Dev\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Build Status</b>\n        <br>\n        <a href=\"https://github.com/harmoniqs/NamedTrajectories.jl/actions/workflows/CI.yml?query=branch%3Amain\">\n          <img src=\"https://github.com/harmoniqs/NamedTrajectories.jl/actions/workflows/CI.yml/badge.svg?branch=main\" alt=\"Build Status\"/>\n        </a>\n        <a href=\"https://codecov.io/gh/harmoniqs/NamedTrajectories.jl\">\n          <img src=\"https://codecov.io/gh/harmoniqs/NamedTrajectories.jl/branch/main/graph/badge.svg\" alt=\"Coverage\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>License</b>\n        <br>\n        <a href=\"https://opensource.org/licenses/MIT\">\n          <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"MIT License\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Support</b>\n        <br>\n        <a href=\"https://unitary.fund\">\n          <img src=\"https://img.shields.io/badge/Supported%20By-Unitary%20Fund-FFFF00.svg\" alt=\"Unitary Fund\"/>\n        </a>\n      </td>\n    </tr>\n  </table>\n</div>\n\n<div align=\"center\">\n  <i>An elegant way to handle messy trajectory data</i>\n  <br>\n</div>","category":"page"},{"location":"#NamedTrajectories.jl","page":"Home","title":"NamedTrajectories.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NamedTrajectories.jl is a package for working with trajectories of named variables. It is designed to be used with the Piccolo.jl ecosystem.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NamedTrajectories.jl is registered! Install in the REPL by entering pkg mode with ] and then running ","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add NamedTrajectories","category":"page"},{"location":"","page":"Home","title":"Home","text":"or to install the latest master branch run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add NamedTrajectories#main","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Abstract away messy indexing and vectorization details required for interfacing with numerical solvers.\nEasily handle multiple trajectories with different names, e.g. various states and controls.\nSimple plotting of trajectories.\nProvide a variety of helpful methods for common tasks.","category":"page"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Users can define NamedTrajectory types which have lots of useful functionality. For example, you can access the data by name or index.  In the case of an index, a KnotPoint is returned which contains the data for that timestep.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using NamedTrajectories\n\n# define number of timesteps and timestep\nT = 10\ndt = 0.1\n\n# build named tuple of components and data matrices\ncomponents = (\n    x = rand(3, T),\n    u = rand(2, T),\n)\n\n# build trajectory\ntraj = NamedTrajectory(components; timestep=dt, controls=:u)\n\n# access data by name\ntraj.x # returns 3x10 matrix of x data\ntraj.u # returns 2x10 matrix of u data\n\nz1 = traj[1] # returns KnotPoint with x and u data\n\nz1.x # returns 3 element vector of x data at timestep 1\nz1.u # returns 2 element vector of u data at timestep 1\n\ntraj.data # returns data as 5x10 matrix\ntraj.names # returns names as tuple (:x, :u)","category":"page"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NamedTrajectories.jl is designed to aid in the messy indexing involved in solving trajectory optimization problems of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\n    arg min_mathbfZquad  J(mathbfZ) \n    nonumber textstqquad  mathbff(mathbfZ) = 0 \n    nonumber  mathbfg(mathbfZ) le 0  \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where mathbfZ is a trajectory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In more detail, this problem might look something like","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\nundersetu^1_1T dots u^n_c_1Tundersetx^1_1T cdots x^n_s_1Ttextminimize quad J left(x^1n_s_1Tu^1n_c_1T right) \ntextsubject to  quad f left(x^1n_s_1Tu^1n_c_1T right) = 0 \n quad x^i_1 = x^i_textinitial \n quad x^i_T = x^i_textfinal \n quad u^i_1 = u^i_textinitial \n quad u^i_T = u^i_textfinal \n quad x^i_min  x^i_t  x^i_max \n quad u^i_min  u^i_t  u^i_max \nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"where x^i_t is the i th state variable and u^i_t is the i th control variable at timestep t; state and control variables can be of arbitrary dimension. The function f is a nonlinear constraint function and J is the objective function. These problems can have an arbitrary number of state (n_s) and control (n_c) variables, and the number of timesteps T can vary as well.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is common practice in trajectory optimization to bundle all of the state and control variables together into a single knot point","category":"page"},{"location":"","page":"Home","title":"Home","text":"z_t = beginpmatrix\n    x^1_t \n    vdots \n    x^n_s_t \n    u^1_t \n    vdots \n    u^n_c_t\n  endpmatrix","category":"page"},{"location":"","page":"Home","title":"Home","text":"The trajectory optimization problem can then be succinctly written as","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\nundersetz_1Ttextminimize quad J left(z_1T right) \ntextsubject to  quad f left(z_1T right) = 0 \n quad z_1 = z_textinitial \n quad z_T = z_textfinal \n quad z_min  z_t  z_max \nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"The NamedTrajectories package provides a NamedTrajectory type which abstracts away the messy indexing and vectorization details required for interfacing with numerical solvers.  It also provides a variety of helpful methods for common tasks.  For example, you can access the data by name or index.  In the case of an index, a KnotPoint is returned which contains the data for that timestep.","category":"page"},{"location":"#Building-Documentation","page":"Home","title":"Building Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"# first time only\n./docs/get_docs_utils.sh   # or ./get_docs_utils.sh if cwd is in ./docs/","category":"page"},{"location":"","page":"Home","title":"Home","text":"To build the docs pages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=docs docs/make.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"or editing the docs live:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"], skip_files=[\"docs/src/index.md\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: servedocs needs to watch a subset of the files in the docs/ folder. If it watches files that are generated on a docs build/re-build, servedocs will continuously try to re-serve the pages.To prevent this, ensure all generated files are included in the skip dirs or skip files args for servedocs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, if we forget index.md like so:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=docs\n> using LiveServer, Piccolo, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"it will not build and serve.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\"It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to take away.\" - Antoine de Saint-Exupéry","category":"page"},{"location":"generated/quickstart/#Quickstart-Guide","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"section"},{"location":"generated/quickstart/#Getting-set-up","page":"Quickstart Guide","title":"Getting set up","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"To install NamedTrajectories simply enter the package manager in the Julia REPL with ] and run","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"pkg> add NamedTrajectories","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Then just use the package as usual with","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using NamedTrajectories","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"For the following examples let's work with a simple trajectory","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"qtyz_t = mqty(x_t  u_t)_t=1T","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"where x_t is the state and u_t is the control at a time indexed by t. Together z_t is referred to as a knot point and a NamedTrajectory essentially just stores a collection of knot points and makes it easy to access the state and control variables.","category":"page"},{"location":"generated/quickstart/#Creating-a-variable-timestep-NamedTrajectory","page":"Quickstart Guide","title":"Creating a variable-timestep NamedTrajectory","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Here we will create a NamedTrajectory with a variable timestep.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"# define the number of timesteps\nT = 10\nΔt = 0.1\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = fill(Δt, T),\n)\n\n# we must specify a timestep and control variable for the NamedTrajectory.\ntimestep = :Δt\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(data; timestep=timestep, controls=control)\n\n# we can return the names of the stored variables\ntraj.names","category":"page"},{"location":"generated/quickstart/#Adding-more-problem-data","page":"Quickstart Guide","title":"Adding more problem data","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"In many settings we will want to specify the problem data of our NamedTrajectory – e.g. bounds, initial values, final values, and goal values.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"# define the number of timesteps\nT = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = rand(T),\n)\n\n# define initial values\ninitial = (\n    x = [1.0, 0.0, 0.0],\n    u = [0.0, 0.0],\n)\n\n# define final value, here just on the control\nfinal = (\n    u = [0.0, 0.0],\n)\n\n# define bounds\nbounds = (\n    x = 1.0,\n    u = 1.0\n)\n\n# set a goal for the state\ngoal = (\n    x = [0.0, 0.0, 1.0],\n)\n\n# we must specify a timestep and control variable for the NamedTrajectory\ntimestep = :Δt\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(\n    data;\n    timestep=timestep,\n    controls=control,\n    initial=initial,\n    final=final,\n    bounds=bounds,\n    goal=goal\n)\n\n# we can then show the bounds\ntraj.bounds","category":"page"},{"location":"generated/quickstart/#Retrieving-data","page":"Quickstart Guide","title":"Retrieving data","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"There are a number of ways to access data, for example","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"traj.x","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"returns the data matrix associated with the state variable x.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"traj.data","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"returns the all of the data as a matrix where each column is a knot point.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"traj.datavec","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"returns the all of the data as a view of the data matrix as a vector – useful for passing data to solvers.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"traj[1]","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"returns a KnotPoint.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"traj[1].x","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"returns the state at the first knot point.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"get_times(traj)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"returns the times of the knot points.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"get_timesteps(traj)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"returns the timesteps of the knot points, as vector.","category":"page"},{"location":"generated/quickstart/#Retrieving-metadata","page":"Quickstart Guide","title":"Retrieving metadata","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also retrieve metadata about the trajectory, for example","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"traj.names","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"returns the names of the variables stored in the trajectory.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"traj.dims","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"returns the dimensions of the variables stored in the trajectory.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"traj.T","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"returns the number of knot points in the trajectory.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"traj.components","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"returns the components of the trajectory.","category":"page"},{"location":"generated/quickstart/#Updating-problem-data","page":"Quickstart Guide","title":"Updating problem data","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The NamedTrajectory can be updated by accessing fields and replacing the data.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We also have update! to update trajectory components, and  update_bound!, which allows you to pass in the same kinds of bounds available at construction (e.g., an Int or Tuple). The bound will get shaped to match the trajectory component dimensions just like at construction. These methods cannot be used to update non-existent bounds or components.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"For efficiency, a trajectory cannot add new data after it is constructed. However, we have convenience methods like add_component that build a new trajectory with added data.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"update_bound!(traj, :x, 2.) # TODO: consider fleshing out this section with more examples of updating trajectory components, knot points, globals, bounds, etc.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/man/constructors/#Constructors","page":"Constructors","title":"Constructors","text":"","category":"section"},{"location":"generated/man/constructors/","page":"Constructors","title":"Constructors","text":"To construct a NamedTrajectory using NamedTrajectories.jl, we simply need to utilize the NamedTrajectory constructor.","category":"page"},{"location":"generated/man/constructors/","page":"Constructors","title":"Constructors","text":"using NamedTrajectories\n\n# define number of timesteps and timestep\nT = 10\ndt = 0.1","category":"page"},{"location":"generated/man/constructors/","page":"Constructors","title":"Constructors","text":"build named tuple of components and data matrices.","category":"page"},{"location":"generated/man/constructors/","page":"Constructors","title":"Constructors","text":"components = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = fill(dt, 1, T),\n)","category":"page"},{"location":"generated/man/constructors/","page":"Constructors","title":"Constructors","text":"we must specify a timestep and control variable for the trajectory.","category":"page"},{"location":"generated/man/constructors/","page":"Constructors","title":"Constructors","text":"timestep = :Δt\ncontrol = :u","category":"page"},{"location":"generated/man/constructors/","page":"Constructors","title":"Constructors","text":"we can now create a NamedTrajectory object.","category":"page"},{"location":"generated/man/constructors/","page":"Constructors","title":"Constructors","text":"traj = NamedTrajectory(components; timestep=timestep, controls=control)","category":"page"},{"location":"generated/man/constructors/","page":"Constructors","title":"Constructors","text":"Construct NamedTrajectory from previous constructed one.","category":"page"},{"location":"generated/man/constructors/","page":"Constructors","title":"Constructors","text":"traj = NamedTrajectory(components, traj) # TODO: should this constructor be reimplemented for v0.4.0?","category":"page"},{"location":"generated/man/constructors/","page":"Constructors","title":"Constructors","text":"traj = NamedTrajectory(traj; components=(x=1:3, u=4:5, Δt=6:6))","category":"page"},{"location":"generated/man/constructors/","page":"Constructors","title":"Constructors","text":"","category":"page"},{"location":"generated/man/constructors/","page":"Constructors","title":"Constructors","text":"This page was generated using Literate.jl.","category":"page"}]
}
